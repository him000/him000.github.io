<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>MinimumCostToConnectSticks2</title>
      <link href="/2025/06/09/MinimumCostToConnectSticks2/"/>
      <url>/2025/06/09/MinimumCostToConnectSticks2/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.贪心.经典题目专题<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/6/9 11:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接棒材的最低费用(洛谷测试)</span></span><br><span class="line"><span class="comment">// 你有一些长度为正整数的棍子</span></span><br><span class="line"><span class="comment">// 这些长度以数组sticks的形式给出</span></span><br><span class="line"><span class="comment">// sticks[i]是第i个木棍的长度</span></span><br><span class="line"><span class="comment">// 你可以通过支付x+y的成本将任意两个长度为x和y的棍子连接成一个棍子</span></span><br><span class="line"><span class="comment">// 你必须连接所有的棍子，直到剩下一个棍子</span></span><br><span class="line"><span class="comment">// 返回以这种方式将所有给定的棍子连接成一个棍子的最小成本</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P1090</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下的code，提交时请把类名改成&quot;Main&quot;，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinimumCostToConnectSticks2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            n = (<span class="type">int</span>) in.nval;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                in.nextToken();</span><br><span class="line">                nums[i] = (<span class="type">int</span>) in.nval;</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(minCost());</span><br><span class="line">            out.flush();</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//噢噢 每次只用最小的棍子链接。 -》哈夫曼树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minCost</span><span class="params">()</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            heap.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (heap.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> heap.poll() + heap.poll();</span><br><span class="line">            ans += num;</span><br><span class="line">            heap.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 经典题目专题1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经典题目专题1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinimumCostToConnectSticks1</title>
      <link href="/2025/06/09/MinimumCostToConnectSticks1/"/>
      <url>/2025/06/09/MinimumCostToConnectSticks1/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.贪心.经典题目专题<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/6/9 11:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 连接棒材的最低费用(leetcode测试)</span></span><br><span class="line"><span class="comment">// 你有一些长度为正整数的棍子</span></span><br><span class="line"><span class="comment">// 这些长度以数组sticks的形式给出</span></span><br><span class="line"><span class="comment">// sticks[i]是第i个木棍的长度</span></span><br><span class="line"><span class="comment">// 你可以通过支付x+y的成本将任意两个长度为x和y的棍子连接成一个棍子</span></span><br><span class="line"><span class="comment">// 你必须连接所有的棍子，直到剩下一个棍子</span></span><br><span class="line"><span class="comment">// 返回以这种方式将所有给定的棍子连接成一个棍子的最小成本</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/minimum-cost-to-connect-sticks/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinimumCostToConnectSticks1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//噢噢 每次只用最小的棍子链接。 -》哈夫曼树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">connectSticks</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">            heap.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (heap.size() &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> heap.poll() + heap.poll();</span><br><span class="line">            ans += num;</span><br><span class="line">            heap.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 经典题目专题1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经典题目专题1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CourseScheduleIII</title>
      <link href="/2025/06/08/CourseScheduleIII/"/>
      <url>/2025/06/08/CourseScheduleIII/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.贪心.经典题目专题<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/6/8 17:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 课程表III</span></span><br><span class="line"><span class="comment">// 这里有n门不同的在线课程，按从1到n编号</span></span><br><span class="line"><span class="comment">// 给你一个数组courses</span></span><br><span class="line"><span class="comment">// 其中courses[i]=[durationi, lastDayi]表示第i门课将会持续上durationi天课</span></span><br><span class="line"><span class="comment">// 并且必须在不晚于lastDayi的时候完成</span></span><br><span class="line"><span class="comment">// 你的学期从第 1 天开始</span></span><br><span class="line"><span class="comment">// 且不能同时修读两门及两门以上的课程</span></span><br><span class="line"><span class="comment">// 返回你最多可以修读的课程数目</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/course-schedule-iii/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CourseScheduleIII</span> &#123;</span><br><span class="line">    <span class="comment">//错误思路！！！！！：急迫并不代表优先，常规思维应该是结束日期越早的  优先开始，此后如果遇到更优的上课时间段，则替换</span></span><br><span class="line">    <span class="comment">//策略: lastDayi - durationi 越小，代表越紧迫，按正序排</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">scheduleCourse0</span><span class="params">(<span class="type">int</span>[][] courses)</span>&#123;</span><br><span class="line">        Arrays.sort(courses, (a, b) -&gt; a[<span class="number">1</span>] - a[<span class="number">0</span>] - (b[<span class="number">1</span>] - b[<span class="number">0</span>]));</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, end = <span class="number">0</span>; i &lt; courses.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (end +  courses[i][<span class="number">0</span>] &lt;= courses[i][<span class="number">1</span>])&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                end += courses[i][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正确思路：结束时间排序，大根堆记录已修课程最大耗时点。 如果后续遇到更优耗时课程，则替换</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">scheduleCourse</span><span class="params">(<span class="type">int</span>[][] courses)</span>&#123;</span><br><span class="line">        Arrays.sort(courses, (a, b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//大根堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line">        <span class="comment">//记录最优耗时</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">time</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] cours : courses) &#123;</span><br><span class="line">            <span class="comment">//符合条件 直接入堆</span></span><br><span class="line">            <span class="keyword">if</span> (time + cours[<span class="number">0</span>] &lt;= cours[<span class="number">1</span>])&#123;</span><br><span class="line">                time += cours[<span class="number">0</span>];</span><br><span class="line">                queue.add(cours[<span class="number">0</span>]);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//看看当前答案是否更优</span></span><br><span class="line">                <span class="keyword">if</span> (!queue.isEmpty() &amp;&amp; queue.peek() &gt; cours[<span class="number">0</span>])&#123;</span><br><span class="line">                    time -= queue.peek() - cours[<span class="number">0</span>];</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    queue.add(cours[<span class="number">0</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 经典题目专题1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经典题目专题1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MeetingRoomsII</title>
      <link href="/2025/06/06/MeetingRoomsII/"/>
      <url>/2025/06/06/MeetingRoomsII/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.贪心.经典题目专题<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/6/6 21:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 会议室II</span></span><br><span class="line"><span class="comment">// 给你一个会议时间安排的数组 intervals</span></span><br><span class="line"><span class="comment">// 每个会议时间都会包括开始和结束的时间intervals[i]=[starti, endi]</span></span><br><span class="line"><span class="comment">//避免会议冲突， 满足所有会议安排，返回所需会议室的最小数量</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/meeting-rooms-ii/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MeetingRoomsII</span> &#123;</span><br><span class="line">    <span class="comment">//数组按开始时间排个序，然后每个会议的结束时间进小顶堆，只要会议的开始时间小于最早结束的会议，那就要新开会议</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minMeetingRooms1</span><span class="params">(<span class="type">int</span>[][] meeting)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> meeting.length;</span><br><span class="line">        Arrays.sort(meeting, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        PriorityQueue&lt;Integer&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!heap.isEmpty() &amp;&amp; heap.peek() &lt;= meeting[i][<span class="number">0</span>]) &#123;</span><br><span class="line">                heap.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            heap.add(meeting[i][<span class="number">1</span>]);</span><br><span class="line">            ans = Math.max(ans, heap.size());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 经典题目专题1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经典题目专题1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinDays</title>
      <link href="/2025/06/06/MinDays/"/>
      <url>/2025/06/06/MinDays/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.贪心.经典题目专题<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/6/6 21:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 吃掉N个橘子的最少天数</span></span><br><span class="line"><span class="comment">// 厨房里总共有 n 个橘子，你决定每一天选择如下方式之一吃这些橘子</span></span><br><span class="line"><span class="comment">// 1）吃掉一个橘子</span></span><br><span class="line"><span class="comment">// 2) 如果剩余橘子数 n 能被 2 整除，那么你可以吃掉 n/2 个橘子</span></span><br><span class="line"><span class="comment">// 3) 如果剩余橘子数 n 能被 3 整除，那么你可以吃掉 2*(n/3) 个橘子</span></span><br><span class="line"><span class="comment">// 每天你只能从以上 3 种方案中选择一种方案</span></span><br><span class="line"><span class="comment">// 请你返回吃掉所有 n 个橘子的最少天数</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/minimum-number-of-days-to-eat-n-oranges/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinDays</span> &#123;</span><br><span class="line">    <span class="comment">// 所有的答案都填在这个表里</span></span><br><span class="line">    <span class="comment">// 这个表对所有的过程共用</span></span><br><span class="line">    <span class="comment">//超时，若以用上</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Integer, Integer&gt; dp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDays</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp.containsKey(n)) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp.get(n);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不知道当前吃成什么样更优，所以吃成一半和吃成2/3比较</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Math.min(n % <span class="number">2</span> + <span class="number">1</span> + minDays(n / <span class="number">2</span>), n % <span class="number">3</span> + <span class="number">1</span> + minDays(n / <span class="number">3</span>));</span><br><span class="line">        dp.put(n, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 经典题目专题1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经典题目专题1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TwoCitySchedCost</title>
      <link href="/2025/06/06/TwoCitySchedCost/"/>
      <url>/2025/06/06/TwoCitySchedCost/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.贪心.经典题目专题<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/6/6 17:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 两地调度</span></span><br><span class="line"><span class="comment">// 公司计划面试2n个人，给定一个数组 costs</span></span><br><span class="line"><span class="comment">// 其中costs[i]=[aCosti, bCosti]</span></span><br><span class="line"><span class="comment">// 表示第i人飞往a市的费用为aCosti，飞往b市的费用为bCosti</span></span><br><span class="line"><span class="comment">// 返回将每个人都飞到a、b中某座城市的最低费用</span></span><br><span class="line"><span class="comment">// 要求每个城市都有n人抵达</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/two-city-scheduling/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TwoCitySchedCost</span> &#123;</span><br><span class="line">    <span class="comment">//很容易理解，始终都要去一个城市，那从a,b差价最大的开始选择，始终选比较便宜的</span></span><br><span class="line">    <span class="comment">//某个城市筹齐n个人后，后面直接加上剩余城市费用</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">twoCitySchedCost</span><span class="params">(<span class="type">int</span>[][] costs)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> costs.length / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//差价大的在前</span></span><br><span class="line">        Arrays.sort(costs, (a, b) -&gt; Math.abs(b[<span class="number">1</span>] - b[<span class="number">0</span>]) - Math.abs(a[<span class="number">1</span>] - a[<span class="number">0</span>]));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt0</span> <span class="operator">=</span> <span class="number">0</span>, cnt1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; costs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt0 &lt; n &amp;&amp; cnt1 &lt; n)&#123;</span><br><span class="line">                <span class="comment">//谁小选谁</span></span><br><span class="line">                <span class="keyword">if</span> (costs[i][<span class="number">0</span>] &gt;= costs[i][<span class="number">1</span>])&#123;</span><br><span class="line">                    ans += costs[i][<span class="number">1</span>];</span><br><span class="line">                    cnt1++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    ans += costs[i][<span class="number">0</span>];</span><br><span class="line">                    cnt0++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cnt0 == n)&#123;<span class="comment">//a城市选满了，只能选b</span></span><br><span class="line">                ans += costs[i][<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cnt1 == n)&#123;<span class="comment">//b城市选满了，只能选a</span></span><br><span class="line">                ans += costs[i][<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左神思路：</span></span><br><span class="line">    <span class="comment">//更简洁：是先按a的选，如果b更便宜就补差价，如果b更贵那也选ba差值最小的b。 然后剩下全选a</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">twoCitySchedCost2</span><span class="params">(<span class="type">int</span>[][] costs)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> costs.length;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[i] = costs[i][<span class="number">1</span>] - costs[i][<span class="number">0</span>];</span><br><span class="line">            sum += costs[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> n / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            sum += arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 经典题目专题1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经典题目专题1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LargestNumber</title>
      <link href="/2025/06/06/LargestNumber/"/>
      <url>/2025/06/06/LargestNumber/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.贪心.经典题目专题<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/6/6 15:53</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大数</span></span><br><span class="line"><span class="comment">// 给定一组非负整数nums</span></span><br><span class="line"><span class="comment">// 重新排列每个数的顺序（每个数不可拆分）使之组成一个最大的整数</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/largest-number/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LargestNumber</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接记住解法吧。。。</span></span><br><span class="line">    <span class="comment">//思路是b+a &gt; a+b,则a+b在前</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">largestNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        String[] arr = <span class="keyword">new</span> <span class="title class_">String</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            arr[i] = nums[i] + <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(arr, (a, b) -&gt; (b + a).compareTo(a + b));</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            sb.append(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">ans</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">        <span class="comment">//兼容全是0的情况</span></span><br><span class="line">        <span class="keyword">return</span> ans.charAt(<span class="number">0</span>) == <span class="string">&#x27;0&#x27;</span> ? <span class="string">&quot;0&quot;</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 经典题目专题1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 经典题目专题1 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PermutationLCS</title>
      <link href="/2025/05/26/PermutationLCS/"/>
      <url>/2025/05/26/PermutationLCS/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.根据数据量猜解法的技巧;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/5/26 15:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PermutationLCS</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] arr1 = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] arr2 = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(bf);</span><br><span class="line">        <span class="keyword">while</span> (st.nextToken() != StreamTokenizer.TT_EOF)&#123;</span><br><span class="line">            n = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">            map.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                arr1[i] = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">                <span class="comment">//标记在arr1中的顺序</span></span><br><span class="line">                map.put(arr1[i], i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                arr2[i] = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(compute());</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        bf.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//很有趣的解法， 标记arr2中的字符，在原arr1中的顺序，然后再根据这个顺序生成最长递增子序列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//标记顺序的数组</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">//遍历arr2,在arr1中的顺序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[i] = map.get(arr2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回最小递增子序列的长度</span></span><br><span class="line">        <span class="keyword">return</span> lcs(arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lcs</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">//从右往左遍历，看右边是否有比自己大的数，并记录长度。</span></span><br><span class="line">        <span class="type">int</span>[] ends = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>, find; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//在ends数组中，找比cur小的最左边的位置</span></span><br><span class="line">            find = left(ends, len, arr[i]);</span><br><span class="line">            <span class="comment">//找不到，直接插入</span></span><br><span class="line">            <span class="keyword">if</span> (find == -<span class="number">1</span>)&#123;</span><br><span class="line">                ends[len++] = arr[i];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ends[find] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在ends数组中，找比num小的最左边的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">left</span><span class="params">(<span class="type">int</span>[] ends, <span class="type">int</span> len, <span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = len - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (ends[mid] &lt;= num)&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 根据数据量猜解法的技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 根据数据量猜解法的技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PickNumbersClosedSum</title>
      <link href="/2025/05/21/PickNumbersClosedSum/"/>
      <url>/2025/05/21/PickNumbersClosedSum/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.根据数据量猜解法的技巧;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/5/21 15:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 选择k个数字使得两集合累加和相差不超过1</span></span><br><span class="line"><span class="comment">// 给定一个正数n，表示1~n这些数字都可以选择</span></span><br><span class="line"><span class="comment">// 给定一个正数k，表示要从1~n中选择k个数字组成集合A，剩下数字组成集合B</span></span><br><span class="line"><span class="comment">// 希望做到集合A和集合B的累加和相差不超过1</span></span><br><span class="line"><span class="comment">// 如果能做到，返回集合A选择了哪些数字，任何一种方案都可以</span></span><br><span class="line"><span class="comment">// 如果不能做到，返回长度为0的数组</span></span><br><span class="line"><span class="comment">// 2 &lt;= n &lt;= 10^6</span></span><br><span class="line"><span class="comment">// 1 &lt;= k &lt;= n</span></span><br><span class="line"><span class="comment">// 来自真实大厂笔试，没有测试链接，用对数器验证</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PickNumbersClosedSum</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这道题其实挺符合自然智慧。 要k个数组成集合，达成sum/2的结果</span></span><br><span class="line">    <span class="comment">//验证最大的k个数和最小的k个数能否达成sum/2的结果</span></span><br><span class="line">    <span class="comment">//如果最大的k个数能达成结果，那就证明一定有结果，那就直接用x个数往最大的数去递增</span></span><br><span class="line">    <span class="comment">// 最小的k个数与最大的k个数的间距差值=diff, x = sum/2/diff   ,剩余的最后一个数累加值=sum/2 % diff</span></span><br><span class="line">    <span class="comment">//求解思路很直接，只要有数能fuhe结果，那就直接把最小的数拉到最大，看差多少达成sum/2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] pick(<span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">//累加和</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> (n + <span class="number">1</span>) * n / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span>[] ans = generate(sum / <span class="number">2</span>, n, k);</span><br><span class="line">        <span class="comment">//如果是奇数， 尝试+1看看有没有结果</span></span><br><span class="line">        <span class="keyword">if</span> (ans.length == <span class="number">0</span> &amp;&amp; (sum &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">            ans = generate(sum / <span class="number">2</span> + <span class="number">1</span>, n, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 ~ n这些数字挑选k个</span></span><br><span class="line">    <span class="comment">// 能不能凑够累加和sum</span></span><br><span class="line">    <span class="comment">// 能的话，返回挑选了哪些数字</span></span><br><span class="line">    <span class="comment">// 不能的话，返回长度为0的数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] generate(<span class="type">long</span> sum, <span class="type">int</span> n, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">//最小的目标和</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">minKSum</span> <span class="operator">=</span> (k + <span class="number">1</span>) * k / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//最小k个数和最大数的差值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">range</span> <span class="operator">=</span> n - k;</span><br><span class="line">        <span class="comment">//无法达成目标</span></span><br><span class="line">        <span class="keyword">if</span> (sum &lt; minKSum || sum &gt; minKSum + (<span class="type">long</span>) range * k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 100 15 -&gt; 85</span></span><br><span class="line">        <span class="comment">//目标值和最小和之间需要累加的和</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">need</span> <span class="operator">=</span> sum - minKSum;</span><br><span class="line">        <span class="comment">//有多少个可以直接累加差值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rightSize</span> <span class="operator">=</span> (<span class="type">int</span>) (need / range);</span><br><span class="line">        <span class="comment">//如果有余，这个数就是累加上多余的数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">midIndex</span> <span class="operator">=</span> (k - rightSize) + (<span class="type">int</span>) (need % range);</span><br><span class="line">        <span class="comment">//最左侧最小和的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">leftSize</span> <span class="operator">=</span> k - rightSize - (need % range == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="comment">//累加最小和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; leftSize; i++) &#123;</span><br><span class="line">            ans[i] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果有余数，加上余数</span></span><br><span class="line">        <span class="keyword">if</span> (need % range != <span class="number">0</span>) &#123;</span><br><span class="line">            ans[leftSize] = midIndex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最右边已经累加差值的数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k - <span class="number">1</span>, j = <span class="number">0</span>; j &lt; rightSize; i--, j++) &#123;</span><br><span class="line">            ans[i] = n - j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//**************以下代码为了验证************</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了验证</span></span><br><span class="line">    <span class="comment">// 检验得到的结果是否正确</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">pass</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span>[] ans)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (canSplit(n, k)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans.length != k) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> (n + <span class="number">1</span>) * n / <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">pickSum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num : ans) &#123;</span><br><span class="line">                pickSum += num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Math.abs(pickSum - (sum - pickSum)) &lt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记忆化搜索</span></span><br><span class="line">    <span class="comment">// 不是最优解，只是为了验证</span></span><br><span class="line">    <span class="comment">// 返回能不能做到</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">canSplit</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> (n + <span class="number">1</span>) * n / <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">wantSum</span> <span class="operator">=</span> (sum / <span class="number">2</span>) + ((sum &amp; <span class="number">1</span>) == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][k + <span class="number">1</span>][wantSum + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> f(n, <span class="number">1</span>, k, wantSum, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> i, <span class="type">int</span> k, <span class="type">int</span> s, <span class="type">int</span>[][][] dp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (k &lt; <span class="number">0</span> || s &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == n + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> k == <span class="number">0</span> &amp;&amp; s == <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][k][s] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[i][k][s] == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> f(n, i + <span class="number">1</span>, k, s, dp) || f(n, i + <span class="number">1</span>, k - <span class="number">1</span>, s - i, dp);</span><br><span class="line">        dp[i][k][s] = ans ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了验证</span></span><br><span class="line">    <span class="comment">// 对数器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">60</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">testTime</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试开始&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * N) + <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * n) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span>[] ans = pick(n, k);</span><br><span class="line">            <span class="keyword">if</span> (!pass(n, k, ans)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;出错了!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 根据数据量猜解法的技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 根据数据量猜解法的技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BuyMonster</title>
      <link href="/2025/05/20/BuyMonster/"/>
      <url>/2025/05/20/BuyMonster/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.根据数据量猜解法的技巧;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/5/20 17:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuyMonster</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">10001</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] power = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] money = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main1</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(in);</span><br><span class="line">        <span class="keyword">while</span> (st.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            n = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">            m = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                power[i] = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">                money[i] = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">                m += power[i];</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(compute4());</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//牛客测试连接会超时</span></span><br><span class="line">    <span class="comment">// 假设a[i]数值的范围不大，但是b[i]数值的范围很大</span></span><br><span class="line">    <span class="comment">// 时间复杂度O(n * 所有怪兽的能力累加和)</span></span><br><span class="line">    <span class="comment">//dp[i][j]定义为：针对当前怪兽i，当前能力要达到j， 所需花费的最少钱</span></span><br><span class="line">    <span class="comment">//这里只需要讨论  j &gt;= power[i]的情况，因为很明显当前能力j小于power[i]时，无法通过怪兽。 （当前能力j是包含已经花了钱得到的能力的结果）</span></span><br><span class="line">    <span class="comment">//1.dp[i][j] = dp[i - 1][j]; 直接通过  ，不贿赂当前怪兽</span></span><br><span class="line">    <span class="comment">//2. dp[i - 1][j - power[i]] != -1 -&gt;  dp[i][j] = dp[i - 1][j - power[i]] + money[i]; //  花钱通过，贿赂当前怪兽，</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute3</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][power[<span class="number">0</span>]] = money[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//注意这里j最小得从当前怪兽的能力值开始</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> power[i]; j &lt;= m; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j - power[i]] != Integer.MAX_VALUE)&#123;<span class="comment">//有通过怪兽的记录</span></span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i - <span class="number">1</span>][j - power[i]] + money[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            ans = Math.min(ans, dp[n - <span class="number">1</span>][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        n = <span class="number">10</span>;</span><br><span class="line">        m = <span class="number">0</span>;</span><br><span class="line">        power = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">7</span>, <span class="number">19</span>, <span class="number">31</span>, <span class="number">25</span>, <span class="number">33</span>, <span class="number">31</span>, <span class="number">51</span>, <span class="number">43</span>, <span class="number">63</span>, <span class="number">63</span>&#125;;</span><br><span class="line">        money = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">4</span>, <span class="number">10</span>, <span class="number">1</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            m += power[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(compute4());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 就是方法3的空间压缩版本</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute4</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//0时花费为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[power[<span class="number">0</span>]] = money[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//依赖上一行左边和上一个格子的结果</span></span><br><span class="line">        <span class="comment">//所以j从右往左更新,且要用临时变量记录上一个格子的结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//注意这里j最小得从当前怪兽的能力值开始</span></span><br><span class="line"><span class="comment">//            for (int j = m; j &gt;= power[i]; j--) &#123;</span></span><br><span class="line"><span class="comment">////                cur = dp[j];</span></span><br><span class="line"><span class="comment">//                if (dp[j - power[i]] != Integer.MAX_VALUE)&#123;//有通过怪兽的记录</span></span><br><span class="line"><span class="comment">//                    //上一行结果的对比</span></span><br><span class="line"><span class="comment">//                    dp[j] = Math.min(dp[j], dp[j - power[i]] + money[i]);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">////                dp[j] = cur;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">            <span class="comment">//这里遍历到0 是因为要更新小于当前怪兽能力的为初始值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m, cur; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                cur = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= power[i] &amp;&amp; dp[j] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                    cur = dp[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j &gt;= power[i] &amp;&amp; dp[j - power[i]] != Integer.MAX_VALUE) &#123;</span><br><span class="line">                    cur = Math.min(cur, dp[j - power[i]] + money[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                dp[j] = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            ans = Math.min(ans, dp[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下是左神的代码，数据量不同时，另一种解法</span></span><br><span class="line">    <span class="comment">// 假设a[i]数值的范围很大，但是b[i]数值的范围不大</span></span><br><span class="line">    <span class="comment">// 时间复杂度O(n * 所有怪兽的钱数累加和)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute1</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] a, <span class="type">int</span>[] b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> money : b) &#123;</span><br><span class="line">            m += money;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp[i][j] : 花的钱不能超过j，通过前i个怪兽，最大能力是多少</span></span><br><span class="line">        <span class="comment">// 如果dp[i][j] == Integer.MIN_VALUE</span></span><br><span class="line">        <span class="comment">// 表示花的钱不能超过j，无论如何都无法通过前i个怪兽</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                dp[i][j] = Integer.MIN_VALUE;</span><br><span class="line">                <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j] &gt;= a[i]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j - b[i] &gt;= <span class="number">0</span> &amp;&amp; dp[i - <span class="number">1</span>][j - b[i]] != Integer.MIN_VALUE) &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - b[i]] + a[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[n][j] != Integer.MIN_VALUE) &#123;</span><br><span class="line">                ans = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 就是方法1的空间压缩版本</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute2</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] a, <span class="type">int</span>[] b)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> money : b) &#123;</span><br><span class="line">            m += money;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, cur; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                cur = Integer.MIN_VALUE;</span><br><span class="line">                <span class="keyword">if</span> (dp[j] &gt;= a[i]) &#123;</span><br><span class="line">                    cur = dp[j];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j - b[i] &gt;= <span class="number">0</span> &amp;&amp; dp[j - b[i]] != Integer.MIN_VALUE) &#123;</span><br><span class="line">                    cur = Math.max(cur, dp[j - b[i]] + a[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                dp[j] = cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[j] != Integer.MIN_VALUE) &#123;</span><br><span class="line">                ans = j;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 根据数据量猜解法的技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 根据数据量猜解法的技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Diving2</title>
      <link href="/2025/05/20/Diving2/"/>
      <url>/2025/05/20/Diving2/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.得到具体决策方案的技巧;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/5/20 17:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 讲解069 - 多维费用背包</span></span><br><span class="line"><span class="comment">// 不做空间压缩的版本</span></span><br><span class="line"><span class="comment">// 无法通过全部测试用例</span></span><br><span class="line"><span class="comment">// 这个题必须做空间压缩</span></span><br><span class="line"><span class="comment">// 空间压缩的实现在Diving2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Diving2</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, m ,v;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXM</span> <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">201</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] mrr = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] vrr = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] trr = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN][MAXN];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[][] path = <span class="keyword">new</span> <span class="title class_">String</span>[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt;= v; k++) &#123;</span><br><span class="line">                dp[j][k] = <span class="number">0</span>;</span><br><span class="line">                path[j][k] = <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//三维背包？</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(in);</span><br><span class="line">        <span class="keyword">while</span> (st.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            m = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">            v = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">            n = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">            <span class="comment">//次序是从1开始</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, a, b, c; i &lt;= n; i++) &#123;</span><br><span class="line">                a = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">                b = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">                c = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">                mrr[i] = a;</span><br><span class="line">                vrr[i] = b;</span><br><span class="line">                trr[i] = c;</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(compute());</span><br><span class="line">            out.println(path[m][v]);</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp[i][j][k] = dp[i - 1][j][k];</span></span><br><span class="line">    <span class="comment">//dp[i][j][k] = dp[i - 1][j - mrr[i]][k - vrr[i]] + trr[i];</span></span><br><span class="line">    <span class="comment">//直接把路径记录下来</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//空间压缩，只依赖上一层， 依赖上一层左边的格子，所以从右到左更新</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        String p2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> v; k &gt;=<span class="number">0</span>; k--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j &gt;= mrr[i] &amp;&amp; k &gt;= vrr[i])&#123;</span><br><span class="line">                        <span class="keyword">if</span> (path[j - mrr[i]][k - vrr[i]] == <span class="literal">null</span>) &#123;</span><br><span class="line">                            p2 = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            p2 = path[j - mrr[i]][k - vrr[i]] + <span class="string">&quot; &quot;</span> + i;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (dp[j][k] &lt; dp[j - mrr[i]][k - vrr[i]] + trr[i])&#123;</span><br><span class="line">                            dp[j][k] = dp[j - mrr[i]][k - vrr[i]] + trr[i];</span><br><span class="line">                            path[j][k] = p2;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (dp[j][k] == dp[j - mrr[i]][k - vrr[i]] + trr[i])&#123;</span><br><span class="line">                            <span class="comment">//路径字符序记录最小</span></span><br><span class="line">                            <span class="keyword">if</span> (path[j][k].compareTo(p2) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                                path[j][k] = p2;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 得到具体决策方案的技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 得到具体决策方案的技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Diving1</title>
      <link href="/2025/05/20/Diving1/"/>
      <url>/2025/05/20/Diving1/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.得到具体决策方案的技巧;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/5/20 15:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 讲解069 - 多维费用背包</span></span><br><span class="line"><span class="comment">// 不做空间压缩的版本</span></span><br><span class="line"><span class="comment">// 无法通过全部测试用例</span></span><br><span class="line"><span class="comment">// 这个题必须做空间压缩</span></span><br><span class="line"><span class="comment">// 空间压缩的实现在Diving2</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Diving1</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, m ,v;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXM</span> <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">201</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] mrr = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] vrr = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] trr = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM][MAXN][MAXN];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String[][][] path = <span class="keyword">new</span> <span class="title class_">String</span>[MAXM][MAXN][MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt;= v; k++) &#123;</span><br><span class="line">                    dp[i][j][k] = <span class="number">0</span>;</span><br><span class="line">                    path[i][j][k] = <span class="literal">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//三维背包？</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(in);</span><br><span class="line">        <span class="keyword">while</span> (st.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            m = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">            v = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">            n = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">            <span class="comment">//次序是从1开始</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, a, b, c; i &lt;= n; i++) &#123;</span><br><span class="line">                a = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">                b = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">                c = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">                mrr[i] = a;</span><br><span class="line">                vrr[i] = b;</span><br><span class="line">                trr[i] = c;</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(compute());</span><br><span class="line">            out.println(path[n][m][v]);</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp[i][j][k] = dp[i - 1][j][k];</span></span><br><span class="line">    <span class="comment">//dp[i][j][k] = dp[i - 1][j - mrr[i]][k - vrr[i]] + trr[i];</span></span><br><span class="line">    <span class="comment">//直接把路径记录下来</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        String p2;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt;= v; k++) &#123;</span><br><span class="line">                    dp[i][j][k] = dp[i - <span class="number">1</span>][j][k];</span><br><span class="line">                    path[i][j][k] = path[i - <span class="number">1</span>][j][k];</span><br><span class="line">                    <span class="keyword">if</span> (j &gt;= mrr[i] &amp;&amp; k &gt;= vrr[i])&#123;</span><br><span class="line">                        <span class="keyword">if</span> (path[i - <span class="number">1</span>][j - mrr[i]][k - vrr[i]] == <span class="literal">null</span>) &#123;</span><br><span class="line">                            p2 = i + <span class="string">&quot;&quot;</span>;</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            p2 = path[i - <span class="number">1</span>][j - mrr[i]][k - vrr[i]] + <span class="string">&quot; &quot;</span> + i;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (dp[i][j][k] &lt; dp[i - <span class="number">1</span>][j - mrr[i]][k - vrr[i]] + trr[i])&#123;</span><br><span class="line">                            dp[i][j][k] = dp[i - <span class="number">1</span>][j - mrr[i]][k - vrr[i]] + trr[i];</span><br><span class="line">                            path[i][j][k] = p2;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (dp[i][j][k] == dp[i - <span class="number">1</span>][j - mrr[i]][k - vrr[i]] + trr[i])&#123;</span><br><span class="line">                            <span class="comment">//路径字符序记录最小</span></span><br><span class="line">                            <span class="keyword">if</span> (path[i][j][k].compareTo(p2) &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                                path[i][j][k] = p2;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m][v];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 得到具体决策方案的技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 得到具体决策方案的技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LIS</title>
      <link href="/2025/05/20/LIS/"/>
      <url>/2025/05/20/LIS/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.得到具体决策方案的技巧;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/5/20 10:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最长递增子序列字典序最小的结果</span></span><br><span class="line"><span class="comment">// 给定数组arr，设长度为n</span></span><br><span class="line"><span class="comment">// 输出arr的最长递增子序列</span></span><br><span class="line"><span class="comment">// 如果有多个答案，请输出其中字典序最小的</span></span><br><span class="line"><span class="comment">// 注意这道题的字典序设定（根据提交的结果推论的）：</span></span><br><span class="line"><span class="comment">// 每个数字看作是单独的字符，比如120认为比36的字典序大</span></span><br><span class="line"><span class="comment">// 保证从左到右每个数字尽量小</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.nowcoder.com/practice/30fb9b3cab9742ecae9acda1c75bf927</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/T386911</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下的code，提交时请把类名改成&quot;Main&quot;，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LIS</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXM</span> <span class="operator">=</span> <span class="number">100001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, len;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] ends = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line"></span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(bf);</span><br><span class="line">        <span class="keyword">while</span> (st.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            n = (<span class="type">int</span>) st.nval;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                arr[i] = (<span class="type">int</span>) st.nval;</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(compute());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        bf.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        doLIS();</span><br><span class="line">        <span class="comment">//最长递增子序列长度</span></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//当等于最大值时，直接插入即可</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i] == len)&#123;</span><br><span class="line">                ans[dp[i]] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//没有值，直接插入</span></span><br><span class="line">            <span class="comment">//如果某个长度所对应的字符更小，则取该字符</span></span><br><span class="line">            <span class="comment">//最后形成的是倒叙的结果</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ans[dp[i]] == <span class="number">0</span> || ans[dp[i]] &gt; arr[i] &amp;&amp; arr[i] &gt; ans[dp[i] + <span class="number">1</span>])&#123;</span><br><span class="line">                ans[dp[i]] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里是顺推</span></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//            if (dp[i] == len) &#123;</span></span><br><span class="line"><span class="comment">//                // 注意这里</span></span><br><span class="line"><span class="comment">//                // 为什么不用判断直接设置</span></span><br><span class="line"><span class="comment">//                // 有讲究，课上重点讲了</span></span><br><span class="line"><span class="comment">//                ans[0] = arr[i];</span></span><br><span class="line"><span class="comment">//            &#125; else &#123;</span></span><br><span class="line"><span class="comment">//                if (ans[len - dp[i] - 1] &lt; arr[i]) &#123;</span></span><br><span class="line"><span class="comment">//                    // 注意这里</span></span><br><span class="line"><span class="comment">//                    // 为什么只需要判断比前一位(ans[k-dp[i]-1])大即可</span></span><br><span class="line"><span class="comment">//                    // 有讲究，课上重点讲了</span></span><br><span class="line"><span class="comment">//                    ans[len - dp[i]] = arr[i];</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(len);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> len; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                sb.append(ans[i]).append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sb.append(ans[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; len - 1; i++) &#123;</span></span><br><span class="line"><span class="comment">//            if (i &lt; len - 1)&#123;</span></span><br><span class="line"><span class="comment">//                sb.append(ans[i]).append(&quot; &quot;);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        sb.append(ans[len - 1]);</span></span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求最长递增子序列的长度</span></span><br><span class="line">    <span class="comment">//利用ends数组：从后往前遍历，右边比自己大的数有吗？ 有就新增放入到ends数组，并记录长度， 没有就替换当前位置。 意义在于从后往前递减序，并统计长度</span></span><br><span class="line">    <span class="comment">//核心在于维护ends递减序列</span></span><br><span class="line">    <span class="comment">//dp代表从i出发，往右边扩，能获得的最长递增子序列</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">doLIS</span><span class="params">()</span> &#123;</span><br><span class="line">        len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>, find; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//二分查找ends数组中，小于等于当前数的最左位置</span></span><br><span class="line">            find = bs(ends, len, arr[i]);</span><br><span class="line">            <span class="keyword">if</span> (find == -<span class="number">1</span>) &#123;<span class="comment">//没有比当前num更小的数</span></span><br><span class="line">                ends[len++] = arr[i];</span><br><span class="line">                dp[i] = len;<span class="comment">//记录从当前i出发，获得的最长递增子序列的长度;</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ends[find] = arr[i];</span><br><span class="line">                dp[i] = find + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ends是从大到小的</span></span><br><span class="line">    <span class="comment">//二分查找ends数组中，小于等于num的最左位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bs</span><span class="params">(<span class="type">int</span>[] ends, <span class="type">int</span> len, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = len - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (ends[mid] &lt;= num) &#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 得到具体决策方案的技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 得到具体决策方案的技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SmallestSufficientTeam</title>
      <link href="/2025/05/19/SmallestSufficientTeam/"/>
      <url>/2025/05/19/SmallestSufficientTeam/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.得到具体决策方案的技巧;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/5/19 21:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmallestSufficientTeam</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.先让每个成员拥有的技能变成状态</span></span><br><span class="line">    <span class="comment">//2.取或不取当前成员，直到达成条件。 返回所有答案所需最小成员</span></span><br><span class="line">    <span class="comment">//递归的所有答案中取最小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] smallestSufficientTeam(String[] req_skills, List&lt;List&lt;String&gt;&gt; people) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> req_skills.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> people.size();</span><br><span class="line">        HashMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(req_skills.length);</span><br><span class="line">        <span class="comment">//技能编号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; req_skills.length; i++) &#123;</span><br><span class="line">            map.put(req_skills[i], i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成成员技能状态</span></span><br><span class="line">        <span class="type">int</span>[] pskills = <span class="keyword">new</span> <span class="title class_">int</span>[people.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, status; i &lt; people.size(); i++) &#123;</span><br><span class="line">            status = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (String s : people.get(i)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(s))&#123;</span><br><span class="line">                    status |= <span class="number">1</span> &lt;&lt; map.get(s);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pskills[i] = status;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][<span class="number">1</span> &lt;&lt; n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> f(pskills, (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>, <span class="number">0</span>, dp);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, i = <span class="number">0</span>, s = (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>; s != <span class="number">0</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//当i剩最后一个时，s还没满足，只能选这个。 从递归顺序来看，m - 1是第一个返回结果</span></span><br><span class="line">            <span class="comment">//注意这里递归顺序， i+1是比i先递归返回，所以当这里不等于时，必然拿了i的技能结果</span></span><br><span class="line">            <span class="comment">//或者说 从逻辑顺序来说，是因为取了第i个技能，才导致他们不等（即因为取了i，所以这里s状态会不同）</span></span><br><span class="line">            <span class="keyword">if</span> (i == m - <span class="number">1</span> || dp[i][s] != dp[i + <span class="number">1</span>][s])&#123;</span><br><span class="line">                ans[j++] = i;</span><br><span class="line">                s -= s &amp; pskills[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//要么不取当前人，所需技能不变。 dp[i][status] = dp[i - 1][status]</span></span><br><span class="line">    <span class="comment">//要么取当前人， 1 + 减去当前能组成的技能  dp[i][status] =  1 + dp[i - 1][status - curstatus];</span></span><br><span class="line">    <span class="comment">//二者取最小值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] skills, <span class="type">int</span> status, <span class="type">int</span> i, <span class="type">int</span>[][] dp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (status == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == skills.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][status] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[i][status];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> f(skills, status, i + <span class="number">1</span>, dp);</span><br><span class="line">        <span class="type">int</span> <span class="variable">skill</span> <span class="operator">=</span> skills[i];</span><br><span class="line">        <span class="comment">//如果有当前需要满足的状态之一，就选</span></span><br><span class="line">        <span class="keyword">if</span> ((status &amp; skill) != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> f(skills, status - (status &amp; skill), i + <span class="number">1</span>, dp);</span><br><span class="line">            <span class="keyword">if</span>(ans2 != Integer.MAX_VALUE)&#123;</span><br><span class="line">                ans = Math.min(ans, <span class="number">1</span> + ans2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][status] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 得到具体决策方案的技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 得到具体决策方案的技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LCS</title>
      <link href="/2025/05/15/LCS/"/>
      <url>/2025/05/15/LCS/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.得到具体决策方案的技巧;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/5/15 23:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最长公共子序列其中一个结果</span></span><br><span class="line"><span class="comment">// 给定两个字符串str1和str2</span></span><br><span class="line"><span class="comment">// 输出两个字符串的最长公共子序列</span></span><br><span class="line"><span class="comment">// 如果最长公共子序列为空，则输出-1</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.nowcoder.com/practice/4727c06b9ee9446cab2e859b4bb86bb8</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下的code，提交时请把类名改成&quot;Main&quot;，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LCS</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//比较抽象的递归，</span></span><br><span class="line">    <span class="comment">//当前位置两个都不要， 要一个不要一个，  相同则要。 3种情况</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = in.readLine()) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="type">char</span>[] s1 = line.toCharArray();</span><br><span class="line">            line = in.readLine();</span><br><span class="line">            <span class="type">char</span>[] s2 = line.toCharArray();</span><br><span class="line">            out.println(compute(s1, s2));</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String <span class="title function_">compute</span><span class="params">(<span class="type">char</span>[] s1, <span class="type">char</span>[] s2)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建dp</span></span><br><span class="line">        <span class="type">int</span>[][] dp = dp0(s1, s2);</span><br><span class="line">        <span class="comment">//先拿到最终长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;-1&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//根据结果拿具体实例</span></span><br><span class="line">        <span class="comment">//分析：二维dp表</span></span><br><span class="line">        <span class="comment">// 如果s[l] == s[r],则一定是从斜对角由来</span></span><br><span class="line">        <span class="comment">//否则，哪边大就从那里过来</span></span><br><span class="line">        <span class="comment">//所以从dp入手</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(len);</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1[i] == s2[j])&#123;<span class="comment">//字符相同</span></span><br><span class="line">                sb.append(s1[i]);</span><br><span class="line">                i++;</span><br><span class="line">                j++;</span><br><span class="line">                len--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i + <span class="number">1</span>][j] &gt;= dp[i][j + <span class="number">1</span>])&#123;<span class="comment">//哪边大就从那里过来</span></span><br><span class="line">                    i++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前位置两个都不要， 要一个不要一个，  相同则要。 3种情况</span></span><br><span class="line"><span class="comment">//    private static int f(char[] s1, char[] s2, int l, int r, int[][] dp) &#123;</span></span><br><span class="line"><span class="comment">//        if (l == s1.length || r == s2.length)&#123;</span></span><br><span class="line"><span class="comment">//            return 0;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        if (dp[l][r] != 0) &#123;</span></span><br><span class="line"><span class="comment">//            return dp[l][r];</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        int ans = 0;</span></span><br><span class="line"><span class="comment">//        //只要相同就取，尽管后续有相同字符，但最终结果一定比当前小</span></span><br><span class="line"><span class="comment">//        if (s1[l] == s2[r])&#123;</span></span><br><span class="line"><span class="comment">//            ans = f(s1, s2, l + 1, r + 1, dp) + 1;</span></span><br><span class="line"><span class="comment">//        &#125;else &#123;</span></span><br><span class="line"><span class="comment">//            //这里是两侧只取一个做对比，舍弃了两侧都不要的情况（结果在两侧各取一个的结果集中）</span></span><br><span class="line"><span class="comment">//            ans = Math.max(f(s1, s2, l + 1, r, dp) , f(s1, s2, l + 1, r, dp));</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        dp[l][r] = ans;</span></span><br><span class="line"><span class="comment">//        return ans;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] dp0(<span class="type">char</span>[] s1, <span class="type">char</span>[] s2)&#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s1.length + <span class="number">1</span>][s2.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> s1.length - <span class="number">1</span>; l &gt;= <span class="number">0</span>; l--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> s2.length - <span class="number">1</span>; r &gt;= <span class="number">0</span>; r--) &#123;</span><br><span class="line">                <span class="comment">//只要相同就取，尽管后续有相同字符，但最终结果一定比当前小</span></span><br><span class="line">                <span class="keyword">if</span> (s1[l] == s2[r])&#123;</span><br><span class="line">                    dp[l][r] =  dp[l + <span class="number">1</span>][r + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//这里是两侧只取一个做对比，舍弃了两侧都不要的情况（结果在两侧各取一个的结果集中）</span></span><br><span class="line">                    dp[l][r] = Math.max(dp[l + <span class="number">1</span>][r] , dp[l][r + <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 得到具体决策方案的技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 得到具体决策方案的技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DIghtCount3</title>
      <link href="/2025/05/14/DIghtCount3/"/>
      <url>/2025/05/14/DIghtCount3/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.数位dp2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/5/14 18:32</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 范围内的数字计数</span></span><br><span class="line"><span class="comment">// 给定两个正整数a和b，求在[a,b]范围上的所有整数中</span></span><br><span class="line"><span class="comment">// 1 &lt;= a, b</span></span><br><span class="line"><span class="comment">// 某个数码d出现了多少次</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/digit-count-in-range/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DIghtCount3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">digitsCount</span><span class="params">(<span class="type">int</span> d, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count(b, d) - count(a - <span class="number">1</span>, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计1~num范围上所有的数中，数码d出现了多少次</span></span><br><span class="line">    <span class="comment">// 注意是1~num范围，不是0~num范围</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// left : 当前位左边的情况数</span></span><br><span class="line">        <span class="comment">// right : 当前位右边的情况数</span></span><br><span class="line">        <span class="comment">// 当前位的数字是cur</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>, tmp = num, left, cur; tmp != <span class="number">0</span>; right *= <span class="number">10</span>, tmp /= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 情况1：</span></span><br><span class="line">            <span class="comment">// d != 0</span></span><br><span class="line">            <span class="comment">// 1 ~ 30583 , d = 5</span></span><br><span class="line">            <span class="comment">// cur &lt; d的情况</span></span><br><span class="line">            <span class="comment">// 个位cur=3 : 0000~3057 5</span></span><br><span class="line">            <span class="comment">// 个位上没有额外加</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// cur &gt; d的情况</span></span><br><span class="line">            <span class="comment">// 十位cur=8 : 000~304 5 0~9</span></span><br><span class="line">            <span class="comment">// 十位上额外加 : 305 5 0~9</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// cur == d的情况</span></span><br><span class="line">            <span class="comment">// 百位cur=5 : 00~29 5 00~99</span></span><br><span class="line">            <span class="comment">// 百位上额外加 : 30 5 00~83</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// 情况2：</span></span><br><span class="line">            <span class="comment">// d == 0</span></span><br><span class="line">            <span class="comment">// 1 ~ 30583 d = 0</span></span><br><span class="line">            <span class="comment">// cur &gt; d的情况</span></span><br><span class="line">            <span class="comment">// 个位cur=3 : 0001~3057 0</span></span><br><span class="line">            <span class="comment">// 个位上额外加 : 3058 0</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// cur &gt; d的情况</span></span><br><span class="line">            <span class="comment">// 十位cur=8 : 001~304 0 0~9</span></span><br><span class="line">            <span class="comment">// 十位上额外加 : 305 0 0~9</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// cur &gt; d的情况</span></span><br><span class="line">            <span class="comment">// 百位cur=5 : 01~29 0 00~99</span></span><br><span class="line">            <span class="comment">// 百位上额外加 : 30 0 00~99</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// cur == d的情况</span></span><br><span class="line">            <span class="comment">// 千位cur=0 : 1~2 0 000~099</span></span><br><span class="line">            <span class="comment">// 千位上额外加 : 3 0 000~583</span></span><br><span class="line">            left = tmp / <span class="number">10</span>;</span><br><span class="line">            cur = tmp % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (d == <span class="number">0</span>) &#123;</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += left * right;</span><br><span class="line">            <span class="keyword">if</span> (cur &gt; d) &#123;</span><br><span class="line">                ans += right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == d) &#123;</span><br><span class="line">                ans += num % right + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数位dp2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数位dp2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DigitCount2</title>
      <link href="/2025/05/14/DigitCount2/"/>
      <url>/2025/05/14/DigitCount2/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.数位dp2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/5/14 18:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 范围内的数字计数</span></span><br><span class="line"><span class="comment">// 给定两个正整数a和b，求在[a,b]范围上的所有整数中</span></span><br><span class="line"><span class="comment">// 每个数码(digit)各出现了多少次</span></span><br><span class="line"><span class="comment">// 1 &lt;= a, b</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P2602</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下的code，提交时请把类名改成&quot;Main&quot;，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DigitCount2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">a</span> <span class="operator">=</span> (<span class="type">long</span>) in.nval;</span><br><span class="line">            in.nextToken();</span><br><span class="line">            <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">long</span>) in.nval;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) &#123;</span><br><span class="line">                out.print(digitsCount(i, a, b) + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(digitsCount(<span class="number">9</span>, a, b));</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心思想是统计每一位（个 十 百 千。。）是当前d时，可能的所有情况， 很巧妙的，即使是重复过的数字，例如xxdd, 也会重复计算，因为实际在之前每位时只统计过一次，所以这里不同位时也确实需要加上。</span></span><br><span class="line">    <span class="comment">//主要思路:统计当前每一位是d，根据当前数cur的情况区分左右可取情况数。 假设左边现有数是left，右边任选数是right，右边现有数是n % right + 1</span></span><br><span class="line">    <span class="comment">//这里为了代码好写，全都是先统计left - 1，再加上第left时的情况</span></span><br><span class="line">    <span class="comment">//1.cur &lt; d, 000~left-1，共left种情况 然后其余位任选, 即left * right</span></span><br><span class="line">    <span class="comment">//2.cur == d, 000~left-1，共left种情况, 其余位任选, 再加上left + 1时，右边的现有情况数. 即 left * right + n % right + 1</span></span><br><span class="line">    <span class="comment">//3.cur &gt; d， 000~left-1，共left种情况， 其余位任选， 再加上右边位置任选right， 即 left * right + right</span></span><br><span class="line">    <span class="comment">//特殊情况： 当d == 0 时，左边位数计算是从001~left-1的，所以计算时要先left--</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">count</span><span class="params">(<span class="type">long</span> num, <span class="type">int</span> d)</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>, tmp = num, left, cur; tmp != <span class="number">0</span>; right *= <span class="number">10</span>, tmp /= <span class="number">10</span>) &#123;</span><br><span class="line">            left = tmp / <span class="number">10</span>;</span><br><span class="line">            cur = tmp % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (d == <span class="number">0</span>) &#123;</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左边小于当前位时，右边任选情况下的情况数</span></span><br><span class="line">            ans += left * right;</span><br><span class="line">            <span class="keyword">if</span> (cur == d)&#123;<span class="comment">//右边现有情况数字</span></span><br><span class="line">                ans += num % right + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur &gt; d) &#123;<span class="comment">//右边任选</span></span><br><span class="line">                ans += right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//左神源代码</span></span><br><span class="line">    <span class="comment">//左神思路：超简单的代码</span></span><br><span class="line">    <span class="comment">//主要思路：从</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">digitsCount</span><span class="params">(<span class="type">int</span> d, <span class="type">long</span> a, <span class="type">long</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count(b, d) - count(a - <span class="number">1</span>, d);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数位dp2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数位dp2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DigitCount</title>
      <link href="/2025/05/12/DigitCount/"/>
      <url>/2025/05/12/DigitCount/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.数位dp2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/5/12 17:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数字1的个数</span></span><br><span class="line"><span class="comment">// 给定一个整数n</span></span><br><span class="line"><span class="comment">// 计算所有小于等于n的非负整数中数字1出现的个数</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/number-of-digit-one/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DigitCount</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//1位数时，结果是1   cnt[1] = 1</span></span><br><span class="line">    <span class="comment">//2位数时，1位数的1，10~19 共11个， 再加上 (2~9)1，共8个，所以一共20个 cnt[2] = 20</span></span><br><span class="line">    <span class="comment">//3位数时，100~199 共100个 再额外加上 101（1个）， 110~119（11个）， 1(2~9)1（8个）， 共20个1</span></span><br><span class="line">    <span class="comment">// 200~299即只需要加上2位数时候的1的个数，即20个，由此可得三位数1开头的100个 +  （1~9）开头的三位数时，其中 2位数时的1的个数 9 * 20= 180，共280个 还得再加上两位数时的个数 20个，所以一共300个</span></span><br><span class="line">    <span class="comment">//4位数时，1开头的1000~1999 共1000个， 再加上0~9开头的四位数时，其中 3位数时额外的1的个数 10 * cnt[3]</span></span><br><span class="line">    <span class="comment">//k位数时，1开头的共  10 ^ (k - 1) + 0~9开头的 k - 1位数时额外的1的个数 10 * cnt[k - 1]</span></span><br><span class="line">    <span class="comment">//由上可得cnt[k] = 10 ^ (k - 1) + 10 * cnt[k - 1]</span></span><br><span class="line">    <span class="comment">//cnt[1] = 1;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">countDigitOne1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取n的位数len</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> n / <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (target &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            target /= <span class="number">10</span>;</span><br><span class="line">            offset *= <span class="number">10</span>;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递推结果</span></span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[len + <span class="number">1</span>];</span><br><span class="line">        cnt[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, d = <span class="number">10</span>; i &lt;= len; i++, d *= <span class="number">10</span>) &#123;</span><br><span class="line">            cnt[i] = d + <span class="number">10</span> * cnt[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//位数小于当前位的结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> cnt[len - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> (n / offset) % <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//如果当前位等于1,直接加上除去当前位所剩数子，再递归下一位求和</span></span><br><span class="line">        <span class="keyword">if</span> (first == <span class="number">1</span>)&#123;</span><br><span class="line">            ans += n % offset + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//把所有小于当前位的结果加上</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; first; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                    ans += offset;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//剩余位数任选</span></span><br><span class="line">                ans += cnt[len - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递归其他位</span></span><br><span class="line">        <span class="keyword">return</span> ans + f(cnt, n, offset / <span class="number">10</span>, len - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前面位数相同</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] cnt, <span class="type">int</span> n, <span class="type">int</span> offset, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> (n / offset) % <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//把所有小于当前位的结果加上</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cur; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                ans += offset;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//剩余位数任选</span></span><br><span class="line">            ans += cnt[len - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前位相同的情况</span></span><br><span class="line">        <span class="comment">//如果当前位等于1,直接加上除去当前位所剩数子，再递归下一位求和</span></span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="number">1</span>)&#123;</span><br><span class="line">            ans += n % offset + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += f(cnt, n, offset / <span class="number">10</span>, len - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据左神思路写的代码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">countDigitOne</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count(n, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心思想是统计每一位（个 十 百 千。。）是当前d时，可能的所有情况， 很巧妙的，即使是重复过的数字，例如xxdd, 也会重复计算，因为实际在之前每位时只统计过一次，所以这里不同位时也确实需要加上。</span></span><br><span class="line">    <span class="comment">//主要思路:统计当前每一位是d，根据当前数cur的情况区分左右可取情况数。 假设左边现有数是left，右边任选数是right，右边现有数是n % right + 1</span></span><br><span class="line">    <span class="comment">//这里为了代码好写，全都是先统计left - 1，再加上第left时的情况</span></span><br><span class="line">    <span class="comment">//1.cur &lt; d, 000~left-1，共left种情况 然后其余位任选, 即left * right</span></span><br><span class="line">    <span class="comment">//2.cur == d, 000~left-1，共left种情况, 其余位任选, 再加上left + 1时，右边的现有情况数. 即 left * right + n % right + 1</span></span><br><span class="line">    <span class="comment">//3.cur &gt; d， 000~left-1，共left种情况， 其余位任选， 再加上右边位置任选right， 即 left * right + right</span></span><br><span class="line">    <span class="comment">//特殊情况： 当d == 0 时，左边位数计算是从001~left-1的，所以计算时要先left--</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> d)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>, tmp = num, left, cur; tmp != <span class="number">0</span>; right *= <span class="number">10</span>, tmp /= <span class="number">10</span>) &#123;</span><br><span class="line">            left = tmp / <span class="number">10</span>;</span><br><span class="line">            cur = tmp % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (d == <span class="number">0</span>) &#123;</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左边小于当前位时，右边任选情况下的情况数</span></span><br><span class="line">            ans += left * right;</span><br><span class="line">            <span class="keyword">if</span> (cur == d)&#123;<span class="comment">//右边现有情况数字</span></span><br><span class="line">                ans += num % right + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur &gt; d) &#123;<span class="comment">//右边任选</span></span><br><span class="line">                ans += right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//左神源代码</span></span><br><span class="line">    <span class="comment">//左神思路：超简单的代码</span></span><br><span class="line">    <span class="comment">//主要思路：从</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">digitsCount</span><span class="params">(<span class="type">int</span> d, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> count(b, d) - count(a - <span class="number">1</span>, d);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 统计1~num范围上所有的数中，数码d出现了多少次</span></span><br><span class="line">    <span class="comment">// 注意是1~num范围，不是0~num范围</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">count0</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// left : 当前位左边的情况数</span></span><br><span class="line">        <span class="comment">// right : 当前位右边的情况数</span></span><br><span class="line">        <span class="comment">// 当前位的数字是cur</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> <span class="number">1</span>, tmp = num, left, cur; tmp != <span class="number">0</span>; right *= <span class="number">10</span>, tmp /= <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="comment">// 情况1：</span></span><br><span class="line">            <span class="comment">// d != 0</span></span><br><span class="line">            <span class="comment">// 1 ~ 30583 , d = 5</span></span><br><span class="line">            <span class="comment">// cur &lt; d的情况</span></span><br><span class="line">            <span class="comment">// 个位cur=3 : 0000~3057 5</span></span><br><span class="line">            <span class="comment">// 个位上没有额外加</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// cur &gt; d的情况</span></span><br><span class="line">            <span class="comment">// 十位cur=8 : 000~304 5 0~9</span></span><br><span class="line">            <span class="comment">// 十位上额外加 : 305 5 0~9</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// cur == d的情况</span></span><br><span class="line">            <span class="comment">// 百位cur=5 : 00~29 5 00~99</span></span><br><span class="line">            <span class="comment">// 百位上额外加 : 30 5 00~83</span></span><br><span class="line">            <span class="comment">// ...</span></span><br><span class="line">            <span class="comment">// 情况2：</span></span><br><span class="line">            <span class="comment">// d == 0</span></span><br><span class="line">            <span class="comment">// 1 ~ 30583 d = 0</span></span><br><span class="line">            <span class="comment">// cur &gt; d的情况</span></span><br><span class="line">            <span class="comment">// 个位cur=3 : 0001~3057 0</span></span><br><span class="line">            <span class="comment">// 个位上额外加 : 3058 0</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// cur &gt; d的情况</span></span><br><span class="line">            <span class="comment">// 十位cur=8 : 001~304 0 0~9</span></span><br><span class="line">            <span class="comment">// 十位上额外加 : 305 0 0~9</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// cur &gt; d的情况</span></span><br><span class="line">            <span class="comment">// 百位cur=5 : 01~29 0 00~99</span></span><br><span class="line">            <span class="comment">// 百位上额外加 : 30 0 00~99</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// cur == d的情况</span></span><br><span class="line">            <span class="comment">// 千位cur=0 : 1~2 0 000~099</span></span><br><span class="line">            <span class="comment">// 千位上额外加 : 3 0 000~583</span></span><br><span class="line">            left = tmp / <span class="number">10</span>;</span><br><span class="line">            cur = tmp % <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (d == <span class="number">0</span>) &#123;</span><br><span class="line">                left--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += left * right;</span><br><span class="line">            <span class="keyword">if</span> (cur &gt; d) &#123;</span><br><span class="line">                ans += right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur == d) &#123;</span><br><span class="line">                ans += num % right + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        countDigitOne(<span class="number">110</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数位dp2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数位dp2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FindIntegers</title>
      <link href="/2025/05/08/FindIntegers/"/>
      <url>/2025/05/08/FindIntegers/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.数位dp2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/5/8 21:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不含连续1的非负整数</span></span><br><span class="line"><span class="comment">// 给定一个正整数n，请你统计在[0, n]范围的非负整数中</span></span><br><span class="line"><span class="comment">// 有多少个整数的二进制表示中不存在连续的1</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/non-negative-integers-without-consecutive-ones/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindIntegers</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将n转为二进制表示，然后走数位dp套路</span></span><br><span class="line">    <span class="comment">//只要判断当前位是否是1即可，1就f(i) = f(i- 2) + f(i - 1); 0 就继续下一个，不会有大于当前数的情况,所以不用关注是否可以任选，（无法任选）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findIntegers</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//先按照f(i) = f(i- 2) + f(i - 1)，生成辅助数组</span></span><br><span class="line">        <span class="comment">//下标为位数，第几位自由发挥下能获得的结果</span></span><br><span class="line">        <span class="comment">//第32位字符位，可用共31位</span></span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">31</span>];</span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">1</span>;<span class="comment">//空串</span></span><br><span class="line">        cnt[<span class="number">1</span>] = <span class="number">2</span>;<span class="comment">//0 和 1两位</span></span><br><span class="line">        <span class="comment">//下标为实际位数，从1位开始计算，例如100为3位，高位为第三位。</span></span><br><span class="line">        <span class="comment">// 也可理解为长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= <span class="number">30</span>; i++) &#123;</span><br><span class="line">            cnt[i] = cnt[i - <span class="number">1</span>] + cnt[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f(cnt, n, <span class="number">31</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//  即cur == 1 -&gt; f(i) = f(i+1) + f(i + 2);  cur == 0 -&gt;  f(i) = f(i+1);</span></span><br><span class="line">    <span class="comment">//len 为长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] cnt, <span class="type">int</span> n, <span class="type">int</span> len)</span>&#123;</span><br><span class="line">        <span class="comment">//当前符合</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (((<span class="number">1</span> &lt;&lt; (len - <span class="number">1</span>)) &amp; n) != <span class="number">0</span>)&#123;<span class="comment">//当前位有1</span></span><br><span class="line">            <span class="comment">//当前位选0时，后续位置任选情况下，结算结果</span></span><br><span class="line">            ans += cnt[len - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//判断如果前一位也是1，当前位不能选1了，直接返回当前位选0的结果，结束递归</span></span><br><span class="line">            <span class="keyword">if</span> (((<span class="number">1</span> &lt;&lt; len) &amp; n) != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> ans;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//1.当前位只有0，继续递归下一个</span></span><br><span class="line">        <span class="comment">//2.当前位有1，当前位照填1，递归下个</span></span><br><span class="line">        ans += f(cnt, n, len - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数位dp2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数位dp2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MengNumber</title>
      <link href="/2025/05/08/MengNumber/"/>
      <url>/2025/05/08/MengNumber/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.数位dp2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/5/8 14:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 萌数</span></span><br><span class="line"><span class="comment">// 如果一个数字，存在长度至少为2的回文子串，那么这种数字被称为萌数</span></span><br><span class="line"><span class="comment">// 比如101、110、111、1234321、45568</span></span><br><span class="line"><span class="comment">// 求[l,r]范围上，有多少个萌数</span></span><br><span class="line"><span class="comment">// 由于答案可能很大，所以输出答案对1000000007求余</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P3413</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下的code，提交时请把类名改成&quot;Main&quot;，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MengNumber</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN][<span class="number">11</span>][<span class="number">11</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>; a &lt; n; a++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">0</span>; b &lt;= <span class="number">10</span>; b++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>; c &lt;= <span class="number">10</span>; c++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> <span class="number">0</span>; d &lt;= <span class="number">1</span>; d++) &#123;</span><br><span class="line">                        dp[a][b][c][d] = -<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        String[] strs = br.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        out.println(compute(strs[<span class="number">0</span>].toCharArray(), strs[<span class="number">1</span>].toCharArray()));</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查是不是萌叔</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">char</span>[] l)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pp</span> <span class="operator">=</span> -<span class="number">2</span>, p = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, cur; i &lt; l.length; i++) &#123;</span><br><span class="line">            cur = l[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur == p || cur == pp)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pp = p;</span><br><span class="line">            p = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//问题转化为求0.。x范围上 不是萌数的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">(<span class="type">char</span>[] l, <span class="type">char</span>[] r)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> (cnt(r) - cnt(l) + MOD) % MOD;</span><br><span class="line">        <span class="comment">//检查l本身是不是萌数</span></span><br><span class="line">        <span class="keyword">if</span> (check(l))&#123;</span><br><span class="line">            ans = (ans + <span class="number">1</span>) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//0..x范围萌数有多少个</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">cnt</span><span class="params">(<span class="type">char</span>[] num)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> num.length;</span><br><span class="line">        <span class="comment">//获得num的值</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">all</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//从最后一位开始累加求余</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            all = (all + base * (num[i] - <span class="string">&#x27;0&#x27;</span>)) % MOD;</span><br><span class="line">            base = (base * <span class="number">10</span>) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求不是萌数的个数</span></span><br><span class="line">        build(n);</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) ((all - f(num, <span class="number">0</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>) + MOD) % MOD);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不是萌数的个数</span></span><br><span class="line">    <span class="comment">// 要符合i-2 != i - 1 &amp;&amp; i - 1 != i &amp;&amp; i-2 != i</span></span><br><span class="line">    <span class="comment">//len为剩余长度，pp为上上个数字，p为上个数字, has代表是否有选过数字</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里到底要不要不选数字呢？是不是还要一个是否有选数字的标识呢？什么时候要这个标识呢？</span></span><br><span class="line">    <span class="comment">//一般如果遍历所有子数字，都要有has，就相当于一个是否有选过数字的总开关和入口</span></span><br><span class="line">    <span class="comment">//这里用p == 10来代表前一位没有选数字，来省去has参数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">char</span>[] num, <span class="type">int</span> i, <span class="type">int</span> pp, <span class="type">int</span> p, <span class="type">int</span> free)</span>&#123;</span><br><span class="line">        <span class="comment">//当前递归符合条件返回答案</span></span><br><span class="line">        <span class="keyword">if</span> (i == num.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[i][pp][p][free] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[i][pp][p][free];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span>  num[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">//未选过数字</span></span><br><span class="line">        <span class="keyword">if</span> (p == <span class="number">10</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (free == <span class="number">0</span>)&#123;<span class="comment">//当前来到num的最高位</span></span><br><span class="line">                <span class="comment">//继续不选数字</span></span><br><span class="line">                ans = (ans + f(num, i + <span class="number">1</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">1</span>)) % MOD;</span><br><span class="line">                <span class="comment">//选小于当前数的数字</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; cur; j++) &#123;</span><br><span class="line">                    ans = (ans + f(num, i + <span class="number">1</span>, p, j, <span class="number">1</span>)) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//选当前位的数字</span></span><br><span class="line">                ans = (ans + f(num, i + <span class="number">1</span>, p, cur, <span class="number">0</span>)) % MOD;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//之前没选择过数字，现在任选</span></span><br><span class="line">                ans = (ans + f(num, i + <span class="number">1</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">1</span>)) % MOD; <span class="comment">// 依然不选数字</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= <span class="number">9</span>; j++) &#123;</span><br><span class="line">                    ans = (ans + f(num, i + <span class="number">1</span>, p, j, <span class="number">1</span>)) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//上个数字位和当前数字位相同，不能任选</span></span><br><span class="line">            <span class="keyword">if</span> (free == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//选小于当前位数的，且符合非萌数定义的</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cur; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j != p &amp;&amp; j != pp)&#123;</span><br><span class="line">                        ans = (ans + f(num, i + <span class="number">1</span>, p, j, <span class="number">1</span>)) % MOD;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当前位不构成萌叔， 选当前位的数字</span></span><br><span class="line">                <span class="keyword">if</span> (cur != p &amp;&amp; cur != pp)&#123;</span><br><span class="line">                    ans = (ans + f(num, i + <span class="number">1</span>, p, cur, <span class="number">0</span>)) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//任选数字，筛选过滤</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= <span class="number">9</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j != p &amp;&amp; j != pp)&#123;</span><br><span class="line">                        ans = (ans + f(num, i + <span class="number">1</span>, p, j, <span class="number">1</span>)) % MOD;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][pp][p][free] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数位dp2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数位dp2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WindyNumber</title>
      <link href="/2025/05/08/WindyNumber/"/>
      <url>/2025/05/08/WindyNumber/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.数位dp2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/5/8 10:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// windy数</span></span><br><span class="line"><span class="comment">// 不含前导零且相邻两个数字之差至少为2的正整数被称为windy数</span></span><br><span class="line"><span class="comment">// windy想知道[a,b]范围上总共有多少个windy数</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P2657</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下的code，提交时请把类名改成&quot;Main&quot;，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WindyNumber</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXLEN</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[MAXLEN][<span class="number">11</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> len)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= <span class="number">10</span>; j++) &#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> (<span class="type">int</span>) in.nval;</span><br><span class="line">            in.nextToken();</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> (<span class="type">int</span>) in.nval;</span><br><span class="line">            out.println(compute(a, b));</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cnt(b) - cnt(a - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求0~num范围上，windy数的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">cnt</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (num == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> num / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (tmp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            offset *= <span class="number">10</span>;</span><br><span class="line">            tmp /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        build(len);</span><br><span class="line"><span class="comment">//        return f(len, offset, num, 0, 10, 0);</span></span><br><span class="line">        <span class="keyword">return</span> f(num, offset, len, <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误代码！！！！！！！！！1</span></span><br><span class="line">    <span class="comment">//前一位是两个端点:则 此位任选 7位非端点继续递归 + 1位端点递归</span></span><br><span class="line">    <span class="comment">//否则：任选5位非端点继续递归 + 2位端点递归</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f0</span><span class="params">(<span class="type">int</span> len, <span class="type">int</span> offset, <span class="type">int</span> n, <span class="type">int</span> preD, <span class="type">int</span> pre, <span class="type">int</span> free)</span>&#123;</span><br><span class="line">        <span class="comment">//剩一位数，直接返回答案</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n / offset;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[len][pre][free] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[len][pre][free];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前位数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> (n / offset) % <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//如果是可以任选情况</span></span><br><span class="line">        <span class="keyword">if</span> (free == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//前一位是端点</span></span><br><span class="line">            <span class="keyword">if</span> (preD == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//7位非端点+1位端点递归</span></span><br><span class="line">                ans += <span class="number">7</span> * f0(len - <span class="number">1</span>, offset / <span class="number">10</span>, n, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>) + f0(len - <span class="number">1</span>, offset / <span class="number">10</span>, n, <span class="number">1</span>, Math.abs(pre - <span class="number">9</span>),  <span class="number">1</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//5位非端点+2位端点递归</span></span><br><span class="line">                ans += <span class="number">5</span> * f0(len - <span class="number">1</span>, offset / <span class="number">10</span>, n, <span class="number">0</span>, <span class="number">0</span>,<span class="number">1</span>) +  f0(len - <span class="number">1</span>, offset / <span class="number">10</span>, n, <span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">                        + f0(len - <span class="number">1</span>, offset / <span class="number">10</span>, n, <span class="number">1</span>, <span class="number">9</span>, <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//不能任选情况下</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cur; i++) &#123;</span><br><span class="line">                <span class="comment">//这里可选择的数要比前一位差距为2</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt;= pre - <span class="number">2</span> || i &gt;= pre + <span class="number">2</span>)&#123;</span><br><span class="line">                    ans += f0(len - <span class="number">1</span>, offset / <span class="number">10</span>, n,  i == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>, i, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur &lt;= pre - <span class="number">2</span> || cur &gt;= pre + <span class="number">2</span>)&#123;</span><br><span class="line">                ans += f0(len - <span class="number">1</span>, offset / <span class="number">10</span>, n,  cur == <span class="number">0</span> || cur == <span class="number">9</span> ? <span class="number">1</span> : <span class="number">0</span>, cur, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[len][pre][free] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//左神思路：主要就是遍历每个符合范围内的子树，然后筛选符合前一位相差2的数</span></span><br><span class="line">    <span class="comment">// offset完全由len决定，为了方便提取num中某一位数字（上节课内容）</span></span><br><span class="line">    <span class="comment">// 从num的高位开始，还剩下len位没有决定</span></span><br><span class="line">    <span class="comment">// 前一位的数字是pre，如果pre == 10，表示从来没有选择过数字</span></span><br><span class="line">    <span class="comment">// 如果之前的位已经确定比num小，那么free == 1，表示接下的数字可以自由选择</span></span><br><span class="line">    <span class="comment">// 如果之前的位和num一样，那么free == 0，表示接下的数字不能大于num当前位的数字</span></span><br><span class="line">    <span class="comment">// 返回&lt;=num的windy数有多少个</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> offset, <span class="type">int</span> len, <span class="type">int</span> pre, <span class="type">int</span> free)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[len][pre][free] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[len][pre][free];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> num / offset % <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (free == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="comment">// 之前的位和num一样，此时不能随意选择数字</span></span><br><span class="line">                <span class="comment">// 也从来没有选择过数字</span></span><br><span class="line">                <span class="comment">// 就表示：来到的是num的最高位</span></span><br><span class="line">                ans += f(num, offset / <span class="number">10</span>, len - <span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>); <span class="comment">// 一个数字也不要</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; cur; i++) &#123;</span><br><span class="line">                    ans += f(num, offset / <span class="number">10</span>, len - <span class="number">1</span>, i, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                ans += f(num, offset / <span class="number">10</span>, len - <span class="number">1</span>, cur, <span class="number">0</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 之前的位和num一样，此时不能随意选择数字，</span></span><br><span class="line">                <span class="comment">// 之前选择过数字pre</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &lt;= pre - <span class="number">2</span> || i &gt;= pre + <span class="number">2</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (i &lt; cur) &#123;</span><br><span class="line">                            ans += f(num, offset / <span class="number">10</span>, len - <span class="number">1</span>, i, <span class="number">1</span>);</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == cur) &#123;</span><br><span class="line">                            ans += f(num, offset / <span class="number">10</span>, len - <span class="number">1</span>, cur, <span class="number">0</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre == <span class="number">10</span>) &#123;</span><br><span class="line">                <span class="comment">// free == 1，可以自由选择数字，前面的状况 &lt; num</span></span><br><span class="line">                <span class="comment">// 从来没有选择过数字</span></span><br><span class="line">                ans += f(num, offset / <span class="number">10</span>, len - <span class="number">1</span>, <span class="number">10</span>, <span class="number">1</span>); <span class="comment">// 还是可以不选择数字</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">                    ans += f(num, offset / <span class="number">10</span>, len - <span class="number">1</span>, i, <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// free == 1，可以自由选择数字，前面的状况 &lt; num</span></span><br><span class="line">                <span class="comment">// 选择过数字pre</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (i &lt;= pre - <span class="number">2</span> || i &gt;= pre + <span class="number">2</span>) &#123;</span><br><span class="line">                        ans += f(num, offset / <span class="number">10</span>, len - <span class="number">1</span>, i, <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[len][pre][free] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数位dp2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数位dp2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NumbersWithRepeatedDigits</title>
      <link href="/2025/05/07/NumbersWithRepeatedDigits/"/>
      <url>/2025/05/07/NumbersWithRepeatedDigits/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.数位dp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>   和NumbersAtMostGivenDigitSet一样的题，取相反结果</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/5/7 22:37</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 至少有1位重复的数字个数</span></span><br><span class="line"><span class="comment">// 给定正整数n，返回在[1, n]范围内至少有1位重复数字的正整数个数</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/numbers-with-repeated-digits/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumbersWithRepeatedDigits</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//看了左神思路后自己写</span></span><br><span class="line">    <span class="comment">//直接求特殊整数</span></span><br><span class="line">    <span class="comment">//一样预处理长度为len，任选情况下可获得特殊整数个数</span></span><br><span class="line">    <span class="comment">//特殊整数的求解： len长度时， 9 * 9 * 8 * 7 * 6 * ....</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDupDigitsAtMostN</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> n / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (target &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            offset *= <span class="number">10</span>;</span><br><span class="line">            target /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="comment">//当前数</span></span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//预处理数组，剩余len长度下，任选数字能获得的特殊整数个数</span></span><br><span class="line">        <span class="comment">// 9            第一个数任选</span></span><br><span class="line">        <span class="comment">// 9 * 9        第一、二个数任选</span></span><br><span class="line">        <span class="comment">// 9 * 9 * 8    第一、二、三个数任选</span></span><br><span class="line">        <span class="comment">// 9 * 9 * 8 * 7  第一、二、三、四个数任选</span></span><br><span class="line">        <span class="comment">//所以会从10 - len + 1 开始累乘上去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, k = <span class="number">10</span> - len + <span class="number">1</span>; i &lt; len; i++, k++) &#123;</span><br><span class="line">            cnt[i] = cnt[i - <span class="number">1</span>] * k;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里把位数小于len的所有结果加上，上面只是处理数组,并不是小于位数的结果</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果n的位数是len位，先计算位数少于len的数中，每一位都互不相同的正整数个数，并累加</span></span><br><span class="line">            <span class="comment">// 所有1位数中，每一位都互不相同的正整数个数 = 9</span></span><br><span class="line">            <span class="comment">// 所有2位数中，每一位都互不相同的正整数个数 = 9 * 9</span></span><br><span class="line">            <span class="comment">// 所有3位数中，每一位都互不相同的正整数个数 = 9 * 9 * 8</span></span><br><span class="line">            <span class="comment">// 所有4位数中，每一位都互不相同的正整数个数 = 9 * 9 * 8 * 7</span></span><br><span class="line">            <span class="comment">// ...比len少的位数都累加...</span></span><br><span class="line">            ans = <span class="number">9</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, a = <span class="number">9</span>, b = <span class="number">9</span>; i &lt; len; i++, b--) &#123;</span><br><span class="line">                a *= b;</span><br><span class="line">                ans += a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求小于第一个数的所有特殊整数结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> n / offset;</span><br><span class="line">        ans += (first - <span class="number">1</span>) * cnt[len - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个数相同，其余数字递归获取结果</span></span><br><span class="line">        ans += f1(cnt, n, len - <span class="number">1</span>, offset / <span class="number">10</span>, <span class="number">1</span> &lt;&lt; first);</span><br><span class="line">        <span class="keyword">return</span> n - ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//status代表哪位已用， 0 - 9位</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span>[] cnt, <span class="type">int</span> n, <span class="type">int</span> len, <span class="type">int</span> offset, <span class="type">int</span> status)</span>&#123;</span><br><span class="line">        <span class="comment">//当前数</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span>  <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前位数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> (n / offset) % <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//遍历所有小于当前数的 且 没用过的数字，直接获取结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; first; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((status &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span>)&#123;</span><br><span class="line">                ans += cnt[len - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前位没用过，则递归当前位</span></span><br><span class="line">        <span class="keyword">if</span> ((status &amp; (<span class="number">1</span> &lt;&lt; first)) == <span class="number">0</span>)&#123;</span><br><span class="line">            ans += f1(cnt, n, len - <span class="number">1</span>, offset / <span class="number">10</span>, status | (<span class="number">1</span> &lt;&lt; first));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//然后递归当前位相同时，其他位的结果</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数位dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数位dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CountSpecialIntegers</title>
      <link href="/2025/05/07/CountSpecialIntegers/"/>
      <url>/2025/05/07/CountSpecialIntegers/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.数位dp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/5/7 22:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 完全没有重复的数字个数</span></span><br><span class="line"><span class="comment">// 给定正整数n，返回在[1, n]范围内每一位都互不相同的正整数个数</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/count-special-integers/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountSpecialIntegers</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原思路，错了！！！！！！！！！！</span></span><br><span class="line">    <span class="comment">//求非特殊整数即可，思路：</span></span><br><span class="line">    <span class="comment">//共有len个长度可选择，</span></span><br><span class="line">    <span class="comment">// 当位数小于n时，所有数任选，假设为len的长度，第一位是1-9 9种， 至少一位和之前位相同， 剩余位置(len - 2)任选 0-9， 10 ^ (len-2)  ，即总共9 * 10 ^ (len-2)</span></span><br><span class="line">    <span class="comment">//当位数相同时， 若当前位cur小于n，则后续位任选（但至少要有一位和前面cur + 1位相同，然后后续位置任选， 即(cur + 1) *  (10 ^ (len - cur)）。 若相同则继续递归</span></span><br><span class="line">    <span class="comment">//所以可先预处理位数小于n时的情况，获取剩余位数任选时的答案</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSpecialNumbers0</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> n / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (target &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            offset *= <span class="number">10</span>;</span><br><span class="line">            len++;</span><br><span class="line">            target /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        cnt[<span class="number">2</span>] = <span class="number">9</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//预处理长度为len，任选时可获得的非特殊整数个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, k = <span class="number">9</span>; i &lt; len; i++, k = k * <span class="number">10</span>) &#123;</span><br><span class="line">            cnt[i] = k;</span><br><span class="line">            ans += k;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当位数相同时，能获得的非特殊整数个数，递归处理</span></span><br><span class="line">        <span class="keyword">return</span> n - ans - f0(cnt, n, len, <span class="number">0</span>, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找非特殊整数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f0</span><span class="params">(<span class="type">int</span>[] cnt,  <span class="type">int</span> n, <span class="type">int</span> len, <span class="type">int</span> i, <span class="type">int</span> offset)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> == len)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">9</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前数字位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> (n / offset) % <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//小于当前数字位数, 后续长度数字任选下的结果</span></span><br><span class="line">        <span class="comment">//从 0 - cur - 1 * 前面已经选好的i+1个位置（后面固定位可挑选的数）  * 后续len - i - 1 个长度任选的结果</span></span><br><span class="line">        ans +=  cur * (i + <span class="number">1</span>) * cnt[len - i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等于cur时继续递归</span></span><br><span class="line">        ans += f0(cnt, n, len, i + <span class="number">1</span>, offset / <span class="number">10</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//看了左神思路后自己写</span></span><br><span class="line">    <span class="comment">//直接求特殊整数</span></span><br><span class="line">    <span class="comment">//一样预处理长度为len，任选情况下可获得特殊整数个数</span></span><br><span class="line">    <span class="comment">//特殊整数的求解： len长度时， 9 * 9 * 8 * 7 * 6 * ....</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countSpecialNumbers</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> n / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (target &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            offset *= <span class="number">10</span>;</span><br><span class="line">            target /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="comment">//当前数</span></span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//预处理数组，剩余len长度下，任选数字能获得的特殊整数个数</span></span><br><span class="line">        <span class="comment">// 9            第一个数任选</span></span><br><span class="line">        <span class="comment">// 9 * 9        第一、二个数任选</span></span><br><span class="line">        <span class="comment">// 9 * 9 * 8    第一、二、三个数任选</span></span><br><span class="line">        <span class="comment">// 9 * 9 * 8 * 7  第一、二、三、四个数任选</span></span><br><span class="line">        <span class="comment">//所以会从10 - len + 1 开始累乘上去</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, k = <span class="number">10</span> - len + <span class="number">1</span>; i &lt; len; i++, k++) &#123;</span><br><span class="line">            cnt[i] = cnt[i - <span class="number">1</span>] * k;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里把位数小于len的所有结果加上，上面只是处理数组,并不是小于位数的结果</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果n的位数是len位，先计算位数少于len的数中，每一位都互不相同的正整数个数，并累加</span></span><br><span class="line">            <span class="comment">// 所有1位数中，每一位都互不相同的正整数个数 = 9</span></span><br><span class="line">            <span class="comment">// 所有2位数中，每一位都互不相同的正整数个数 = 9 * 9</span></span><br><span class="line">            <span class="comment">// 所有3位数中，每一位都互不相同的正整数个数 = 9 * 9 * 8</span></span><br><span class="line">            <span class="comment">// 所有4位数中，每一位都互不相同的正整数个数 = 9 * 9 * 8 * 7</span></span><br><span class="line">            <span class="comment">// ...比len少的位数都累加...</span></span><br><span class="line">            ans = <span class="number">9</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, a = <span class="number">9</span>, b = <span class="number">9</span>; i &lt; len; i++, b--) &#123;</span><br><span class="line">                a *= b;</span><br><span class="line">                ans += a;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求小于第一个数的所有特殊整数结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> n / offset;</span><br><span class="line">        ans += (first - <span class="number">1</span>) * cnt[len - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个数相同，其余数字递归获取结果</span></span><br><span class="line">        ans += f1(cnt, n, len - <span class="number">1</span>, offset / <span class="number">10</span>, <span class="number">1</span> &lt;&lt; first);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//status代表哪位已用， 0 - 9位</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span>[] cnt, <span class="type">int</span> n, <span class="type">int</span> len, <span class="type">int</span> offset, <span class="type">int</span> status)</span>&#123;</span><br><span class="line">        <span class="comment">//当前数</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span>  <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前位数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">first</span> <span class="operator">=</span> (n / offset) % <span class="number">10</span>;</span><br><span class="line">        <span class="comment">//遍历所有小于当前数的 且 没用过的数字，直接获取结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; first; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((status &amp; (<span class="number">1</span> &lt;&lt; i)) == <span class="number">0</span>)&#123;</span><br><span class="line">                ans += cnt[len - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果当前位没用过，则递归当前位</span></span><br><span class="line">        <span class="keyword">if</span> ((status &amp; (<span class="number">1</span> &lt;&lt; first)) == <span class="number">0</span>)&#123;</span><br><span class="line">            ans += f1(cnt, n, len - <span class="number">1</span>, offset / <span class="number">10</span>, status | (<span class="number">1</span> &lt;&lt; first));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//然后递归当前位相同时，其他位的结果</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数位dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数位dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CountOfIntegers</title>
      <link href="/2025/05/06/CountOfIntegers/"/>
      <url>/2025/05/06/CountOfIntegers/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.数位dp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/5/6 22:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计整数数目</span></span><br><span class="line"><span class="comment">// 给你两个数字字符串 num1 和 num2 ，以及两个整数max_sum和min_sum</span></span><br><span class="line"><span class="comment">// 如果一个整数 x 满足以下条件，我们称它是一个好整数</span></span><br><span class="line"><span class="comment">// num1 &lt;= x &lt;= num2</span></span><br><span class="line"><span class="comment">// min_sum &lt;= digit_sum(x) &lt;= max_sum</span></span><br><span class="line"><span class="comment">// 请你返回好整数的数目</span></span><br><span class="line"><span class="comment">// 答案可能很大，答案对 1000000007 取模</span></span><br><span class="line"><span class="comment">// 注意，digit_sum(x)表示x各位数字之和</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/count-of-integers/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountOfIntegers</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">23</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXM</span> <span class="operator">=</span> <span class="number">401</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN][MAXM][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= max; j++) &#123;</span><br><span class="line">                dp[i][j][<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">                dp[i][j][<span class="number">1</span>] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span>[] num;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> min, max, len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//思路：</span></span><br><span class="line">    <span class="comment">//转换成0 -&gt; num2 的好整数 减去 0 -&gt; num1 - 1的好整数.问题就简化成求，0-x范围的好整数个数</span></span><br><span class="line">    <span class="comment">//求x的每一位递归，于是x所选的每一位相加最后看是否符合条件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">(String s1, String s2, <span class="type">int</span> min_sum, <span class="type">int</span> max_sum)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s2.length();</span><br><span class="line">        min = min_sum;</span><br><span class="line">        max = max_sum;</span><br><span class="line">        num = s2.toCharArray();</span><br><span class="line">        len = m;</span><br><span class="line">        build();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> f( <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        num = s1.toCharArray();</span><br><span class="line">        len = n;</span><br><span class="line">        build();</span><br><span class="line">        ans = (ans - f( <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>) + MOD) % MOD;</span><br><span class="line">        <span class="comment">//检查s1本身是不是好整数</span></span><br><span class="line">        <span class="keyword">if</span> (check())&#123;</span><br><span class="line">            ans = (ans + <span class="number">1</span>) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sum     已选择的数字和</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> free    是否任意选数字</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> sum, <span class="type">int</span> free)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum + (len - cur) * <span class="number">9</span> &lt; min || sum &gt; max)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len == cur) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[cur][sum][free] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[cur][sum][free];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">curNum</span> <span class="operator">=</span> num[cur] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="comment">//任选</span></span><br><span class="line">        <span class="keyword">if</span> (free == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//选0-9的数字</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++) &#123;</span><br><span class="line">                ans = (ans + f(cur + <span class="number">1</span>, sum + i, <span class="number">1</span>)) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//小于当前数，后续任选</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; curNum; i++) &#123;</span><br><span class="line">                ans = (ans + f(cur + <span class="number">1</span>, sum + i, <span class="number">1</span>)) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = (ans + f(cur + <span class="number">1</span>, sum + curNum, <span class="number">0</span>)) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[cur][sum][free] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> cha : num) &#123;</span><br><span class="line">            sum += cha - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum &gt;= min &amp;&amp; sum &lt;= max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数位dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数位dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NumbersAtMostGivenDigitSet</title>
      <link href="/2025/05/06/NumbersAtMostGivenDigitSet/"/>
      <url>/2025/05/06/NumbersAtMostGivenDigitSet/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.数位dp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/5/6 17:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大为N的数字组合</span></span><br><span class="line"><span class="comment">// 给定一个按 非递减顺序 排列的数字数组 digits</span></span><br><span class="line"><span class="comment">// 已知digits一定不包含&#x27;0&#x27;，可能包含&#x27;1&#x27; ~ &#x27;9&#x27;，且无重复字符</span></span><br><span class="line"><span class="comment">// 你可以用任意次数 digits[i] 来写的数字</span></span><br><span class="line"><span class="comment">// 例如，如果 digits = [&#x27;1&#x27;,&#x27;3&#x27;,&#x27;5&#x27;]</span></span><br><span class="line"><span class="comment">// 我们可以写数字，如 &#x27;13&#x27;, &#x27;551&#x27;, 和 &#x27;1351315&#x27;</span></span><br><span class="line"><span class="comment">// 返回 可以生成的小于或等于给定整数 n 的正整数的个数</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/numbers-at-most-n-given-digit-set/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumbersAtMostGivenDigitSet</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//总体流程：</span></span><br><span class="line">    <span class="comment">//len作为剩下还未解决的位数，递归len - 1</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">//特殊处理：</span></span><br><span class="line">    <span class="comment">//1.当选择的数比当前位小时，后续可选任意 len-1长度的数字，直接返回答案</span></span><br><span class="line">    <span class="comment">//2，当选择的数和当前位置相同时，继续递归</span></span><br><span class="line">    <span class="comment">//3.符合上面两个条件下，不能选择大于当前cur的数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">atMostNGivenDigitSet</span><span class="params">(String[] str, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> str.length;</span><br><span class="line">        <span class="type">int</span>[] dights = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            dights[i] = Integer.valueOf(str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (target &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            offset *= <span class="number">10</span>;</span><br><span class="line">            target /= <span class="number">10</span>;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//预处理后续数字任选时的答案</span></span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="comment">//后续没有长度了，就目前这种答案</span></span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//这里i代表后续未处理数字的长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, k = m; i &lt; len; i++, k *= m) &#123;</span><br><span class="line">            cnt[i] = k;</span><br><span class="line">            <span class="comment">//当位数小于n时</span></span><br><span class="line">            ans +=k;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当位数等于n时，递归获取答案</span></span><br><span class="line">        <span class="keyword">return</span> ans + f(dights, cnt, n, len, offset);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] dights, <span class="type">int</span>[] cnt, <span class="type">int</span> n, <span class="type">int</span> len,  <span class="type">int</span> offset)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前数字位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> (n / offset) % <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历当前可取的数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : dights) &#123;</span><br><span class="line">            <span class="comment">//后续数字任意选择</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; cur)&#123;</span><br><span class="line">                ans += cnt[len - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == cur) &#123;<span class="comment">//相同继续递归</span></span><br><span class="line">                ans += f( dights, cnt, n, len - <span class="number">1</span>, offset / <span class="number">10</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数位dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数位dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CountNumbersWithUniqueDigits</title>
      <link href="/2025/04/24/CountNumbersWithUniqueDigits/"/>
      <url>/2025/04/24/CountNumbersWithUniqueDigits/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.数位dp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/4/24 16:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计各位数字都不同的数字个数</span></span><br><span class="line"><span class="comment">// 给你一个整数n，代表十进制数字最多有n位</span></span><br><span class="line"><span class="comment">// 如果某个数字，每一位都不同，那么这个数字叫做有效数字</span></span><br><span class="line"><span class="comment">// 返回有效数字的个数，不统计负数范围</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/count-numbers-with-unique-digits/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountNumbersWithUniqueDigits</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接找规律。。打表吧</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNumbersWithUniqueDigits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//n == 1 -》 10</span></span><br><span class="line">        <span class="comment">//n == 2 -&gt; 9 * 9</span></span><br><span class="line">        <span class="comment">//n == 3 -&gt; 9 * 9 * 8</span></span><br><span class="line">        <span class="comment">//n == 4 -&gt; 9 * 9 * 8 * 7</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, sum = <span class="number">9</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sum *= <span class="number">11</span> - i;</span><br><span class="line">            ans += sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数位dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数位dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LongestSubarraySumNoMoreK</title>
      <link href="/2025/04/23/LongestSubarraySumNoMoreK/"/>
      <url>/2025/04/23/LongestSubarraySumNoMoreK/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.用观察优化枚举技巧<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/4/23 13:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 累加和不大于k的最长子数组</span></span><br><span class="line"><span class="comment">// 给定一个无序数组arr，长度为n，其中元素可能是正、负、0</span></span><br><span class="line"><span class="comment">// 给定一个整数k，求arr所有的子数组中累加和不大于k的最长子数组长度</span></span><br><span class="line"><span class="comment">// 要求时间复杂度为O(n)</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.nowcoder.com/practice/3473e545d6924077a4f7cbc850408ade</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下的code，提交时请把类名改成&quot;Main&quot;，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongestSubarraySumNoMoreK</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(bf);</span><br><span class="line">        <span class="keyword">while</span> (st.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">int</span>) st.nval;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> (<span class="type">int</span>) st.nval;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                arr[i] = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(compute(arr, k));</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        bf.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没啥思路，看了左神思路后才想起</span></span><br><span class="line">    <span class="comment">//方法一：前缀和！！像这种描述有相加和、负数等等之类的，可以优先考虑下前缀和思路。。</span></span><br><span class="line">    <span class="comment">//从0..i，计算到当前i位置的前缀和sum[i],将小于等于k 转换为 找0...p区间大于等于sum - k 的子数组</span></span><br><span class="line">    <span class="comment">// 针对每一个区间0..i，求解每一个符合条件的答案。</span></span><br><span class="line">    <span class="comment">//针对上门找符合条件的区间，先记录每一个0..i位置的最大前缀和，然后通过二分查找最左边的前罪和加速求解</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute0</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//先构建最大前缀数组</span></span><br><span class="line">        <span class="type">int</span>[] summax = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            sum += arr[i];</span><br><span class="line">            <span class="comment">//当前值和前一个值做对比</span></span><br><span class="line">            summax[i + <span class="number">1</span>] = Math.max(summax[i], sum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对比每一个区间的前缀和，找符合条件的答案</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>, pre = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            sum += arr[i];</span><br><span class="line">            <span class="comment">//找最左边的，大于等于sum - k的位置</span></span><br><span class="line">            pre = find(summax, sum - k);</span><br><span class="line">            ans = Math.max(ans, pre == -<span class="number">1</span> ? <span class="number">0</span> : i + <span class="number">1</span> - pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找最左边的，大于等于target的位置</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] summax, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = summax.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (summax[mid] &gt;= target)&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方法二：</span></span><br><span class="line">    <span class="comment">//天才的想法，属于奇思妙想，O(n)的复杂度，不懂怎么想到的</span></span><br><span class="line">    <span class="comment">//思考下：如果要达到时间复杂度O(n)，滑动窗口是个好方法，但是原数组非单调性，所以是否可以通过构建某个单调数组，而该数组又和求解相关呢？</span></span><br><span class="line">    <span class="comment">//于是有了这个结构：</span></span><br><span class="line">    <span class="comment">//sumpre[i]: 表示从i位置出发，往右扩，能获得最小的数组和是多少</span></span><br><span class="line">    <span class="comment">//sumend[i]: 表示从i位置出发，往右扩， 能获得最小的数组和的数组结束位置在哪</span></span><br><span class="line">    <span class="comment">//于是求和在sumpre单调递增，</span></span><br><span class="line">    <span class="comment">//求原数组能获得满足k情况下，最长的数组长度，即求sumpre数组中，从0出发往右滑动，右扩能达到最大长度，超过则左缩小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span>[] sumpre = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] sumend = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        sumpre[n - <span class="number">1</span>] = arr[n - <span class="number">1</span>];</span><br><span class="line">        sumend[n - <span class="number">1</span>] = n - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//求两个数组结构</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">            sumpre[i] = Math.min(arr[i], sumpre[i + <span class="number">1</span>] + arr[i]);</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &lt; sumpre[i + <span class="number">1</span>] + arr[i])&#123;</span><br><span class="line">                sumpre[i] = arr[i];</span><br><span class="line">                sumend[i] = i;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                sumpre[i] = arr[i] + sumpre[i + <span class="number">1</span>];</span><br><span class="line">                sumend[i] = sumend[i + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//滑动窗口求最长答案</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>, sum = <span class="number">0</span>; l &lt; n; l++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (r &lt; n &amp;&amp; sum + sumpre[r] &lt;= k)&#123;</span><br><span class="line">                sum += sumpre[r];</span><br><span class="line">                <span class="comment">//直接跳到下一段</span></span><br><span class="line">                r = sumend[r] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//有想右扩行为</span></span><br><span class="line">            <span class="keyword">if</span> (r &gt; l)&#123;</span><br><span class="line">                <span class="comment">//获取最大答案</span></span><br><span class="line">                ans = Math.max(ans, r - l);</span><br><span class="line">                sum -= arr[l];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//跟随l位置</span></span><br><span class="line">                r = l + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 用观察优化枚举技巧2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 用观察优化枚举技巧2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FindRotateSteps</title>
      <link href="/2025/04/23/FindRotateSteps/"/>
      <url>/2025/04/23/FindRotateSteps/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.用观察优化枚举技巧<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/4/23 0:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 自由之路</span></span><br><span class="line"><span class="comment">// 题目描述比较多，打开链接查看</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/freedom-trail/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindRotateSteps</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接copy官方的，</span></span><br><span class="line">    <span class="comment">// 主要思想是 从i 到 j ， 枚举每一个i 到 j 的上一个点k， 获取最短i -&gt;k , k -&gt; j的路</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRotateSteps0</span><span class="params">(String ring, String key)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ring.length(), m = key.length();</span><br><span class="line">        List&lt;Integer&gt;[] pos = <span class="keyword">new</span> <span class="title class_">List</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) &#123;</span><br><span class="line">            pos[i] = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Integer&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            pos[ring.charAt(i) - <span class="string">&#x27;a&#x27;</span>].add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            Arrays.fill(dp[i], <span class="number">0x3f3f3f</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : pos[key.charAt(<span class="number">0</span>) - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = Math.min(i, n - i) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j : pos[key.charAt(i) - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> k : pos[key.charAt(i - <span class="number">1</span>) - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i - <span class="number">1</span>][k] + Math.min(Math.abs(j - k), n - Math.abs(j - k)) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(dp[m - <span class="number">1</span>]).min().getAsInt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//按照官方思路再写一遍</span></span><br><span class="line">    <span class="comment">//dp[i][j]的定义是，当当前字符为key的i位置时，ring的j位置字符滑到12点方向并按下，需要几步。</span></span><br><span class="line">    <span class="comment">// 这定义单独看很奇怪吧， 但加上 key在ring上的字符位置去遍历所有j（即i字符等于j字符时），并看ring上的所有字符有没有跳板使得i - 1 -&gt; j 更短</span></span><br><span class="line">    <span class="comment">//于是得到的最终结果dp[i][j]都是 i -1 -&gt; j最短路径，于是最后取得dp[i]中的最小值即是答案。</span></span><br><span class="line">    <span class="comment">//我觉得这个dp太抽象了。。。。。。3层思考</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRotateSteps</span><span class="params">(String ring, String key)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> ring.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> key.length();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置每个k在ring中的位置</span></span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; pos = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            pos.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            pos.get(ring.charAt(i) - <span class="string">&#x27;a&#x27;</span>).add(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//填充0号字符</span></span><br><span class="line">        <span class="keyword">for</span> (Integer i : pos.get(key.charAt(<span class="number">0</span>) - <span class="string">&#x27;a&#x27;</span>)) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][i] = Math.min(i, n - i) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//枚举每个i 到 j中， i -&gt; k, k -&gt; j的最短路</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;<span class="comment">//遍历key的 要来到当前位置的字符</span></span><br><span class="line">            <span class="keyword">for</span> (Integer j : pos.get(key.charAt(i) - <span class="string">&#x27;a&#x27;</span>)) &#123;<span class="comment">//遍历key在ring位置上的当前字符i</span></span><br><span class="line">                <span class="keyword">for</span> (Integer k : pos.get(key.charAt(i - <span class="number">1</span>) - <span class="string">&#x27;a&#x27;</span>)) &#123;<span class="comment">//遍历key的上一个字符所有可能的落脚位置，看看哪个落脚位置距离j最近</span></span><br><span class="line">                    dp[i][j] = Math.min(dp[i][j], dp[i - <span class="number">1</span>][k] + Math.min(Math.abs(j - k), n - Math.abs(j - k)) + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Arrays.stream(dp[m - <span class="number">1</span>]).min().getAsInt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**                                     以下左神思路，感觉更符合自然思考                         **/</span></span><br><span class="line">    <span class="comment">// 为了让所有语言的同学都可以理解</span></span><br><span class="line">    <span class="comment">// 不会使用任何java语言自带的数据结构</span></span><br><span class="line">    <span class="comment">// 只使用最简单的数组结构</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXC</span> <span class="operator">=</span> <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] ring = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] key = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] size = <span class="keyword">new</span> <span class="title class_">int</span>[MAXC];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] where = <span class="keyword">new</span> <span class="title class_">int</span>[MAXC][MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(String r, String k)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAXC; i++) &#123;</span><br><span class="line">            size[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        n = r.length();</span><br><span class="line">        m = k.length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, v; i &lt; n; i++) &#123;</span><br><span class="line">            v = r.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            where[v][size[v]++] = i;</span><br><span class="line">            ring[i] = v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            key[i] = k.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                dp[i][j] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findRotateSteps2</span><span class="params">(String r, String k)</span> &#123;</span><br><span class="line">        build(r, k);</span><br><span class="line">        <span class="keyword">return</span> f(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指针当前指着轮盘i位置的字符，要搞定key[j....]所有字符，最小代价返回</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">            <span class="comment">// key长度是m</span></span><br><span class="line">            <span class="comment">// 都搞定</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][j] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> ans;</span><br><span class="line">        <span class="keyword">if</span> (ring[i] == key[j]) &#123;</span><br><span class="line">            <span class="comment">// ring b</span></span><br><span class="line">            <span class="comment">//      i</span></span><br><span class="line">            <span class="comment">// key  b</span></span><br><span class="line">            <span class="comment">//      j</span></span><br><span class="line">            ans = <span class="number">1</span> + f(i, j + <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 轮盘处在i位置，ring[i] != key[j]</span></span><br><span class="line">            <span class="comment">// jump1 : 顺时针找到最近的key[j]字符在轮盘的什么位置</span></span><br><span class="line">            <span class="comment">// distance1 : 从i顺时针走向jump1有多远</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">jump1</span> <span class="operator">=</span> clock(i, key[j]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">distance1</span> <span class="operator">=</span> (jump1 &gt; i ? (jump1 - i) : (n - i + jump1));</span><br><span class="line">            <span class="comment">// jump2 : 逆时针找到最近的key[j]字符在轮盘的什么位置</span></span><br><span class="line">            <span class="comment">// distance2 : 从i逆时针走向jump2有多远</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">jump2</span> <span class="operator">=</span> counterClock(i, key[j]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">distance2</span> <span class="operator">=</span> (i &gt; jump2 ? (i - jump2) : (i + n - jump2));</span><br><span class="line">            ans = Math.min(distance1 + f(jump1, j), distance2 + f(jump2, j));</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][j] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从i开始，顺时针找到最近的v在轮盘的什么位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">clock</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// size[v] : 属于v这个字符的下标有几个</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> size[v] - <span class="number">1</span>, m;</span><br><span class="line">        <span class="comment">// sorted[0...size[v]-1]收集了所有的下标，并且有序</span></span><br><span class="line">        <span class="type">int</span>[] sorted = where[v];</span><br><span class="line">        <span class="type">int</span> <span class="variable">find</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 有序数组中，找&gt;i尽量靠左的下标</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (sorted[m] &gt; i) &#123;</span><br><span class="line">                find = m;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到了就返回</span></span><br><span class="line">        <span class="comment">// 没找到，那i顺指针一定先走到最小的下标</span></span><br><span class="line">        <span class="keyword">return</span> find != -<span class="number">1</span> ? sorted[find] : sorted[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">counterClock</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> size[v] - <span class="number">1</span>, m;</span><br><span class="line">        <span class="type">int</span>[] sorted = where[v];</span><br><span class="line">        <span class="type">int</span> <span class="variable">find</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 有序数组中，找&lt;i尽量靠右的下标</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            m = (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (sorted[m] &lt; i) &#123;</span><br><span class="line">                find = m;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找到了就返回</span></span><br><span class="line">        <span class="comment">// 没找到，那i逆指针一定先走到最大的下标</span></span><br><span class="line">        <span class="keyword">return</span> find != -<span class="number">1</span> ? sorted[find] : sorted[size[v] - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 用观察优化枚举技巧2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 用观察优化枚举技巧2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KInversePairs</title>
      <link href="/2025/04/16/KInversePairs/"/>
      <url>/2025/04/16/KInversePairs/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.用观察优化枚举技巧<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/4/16 21:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// K个逆序对数组</span></span><br><span class="line"><span class="comment">// 逆序对的定义如下：</span></span><br><span class="line"><span class="comment">// 对于数组nums的第i个和第j个元素</span></span><br><span class="line"><span class="comment">// 如果满足0&lt;=i&lt;j&lt;nums.length 且 nums[i]&gt;nums[j]，则为一个逆序对</span></span><br><span class="line"><span class="comment">// 给你两个整数n和k，找出所有包含从1到n的数字</span></span><br><span class="line"><span class="comment">// 且恰好拥有k个逆序对的不同的数组的个数</span></span><br><span class="line"><span class="comment">// 由于答案可能很大，答案对 1000000007 取模</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/k-inverse-pairs-array/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KInversePairs</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//竟然不知如何去dp， 定义前i个数中，能得到的最多的逆序对是多少？  那不就是全倒序嘛，</span></span><br><span class="line">    <span class="comment">//原思路：（错误思路）</span></span><br><span class="line">    <span class="comment">// 前i个数，能组成j个逆序对的不同数组有多少个？</span></span><br><span class="line">    <span class="comment">//每增加一个数可组成的逆序，都是之前能组成的集合</span></span><br><span class="line">    <span class="comment">// dp[i][j] = dp[i-1][j] + dp[i - 2][j] + dp[i - 3][j].... = 2 * dp[i-1][j];</span></span><br><span class="line">    <span class="comment">//左神思路：</span></span><br><span class="line">    <span class="comment">//定义dp[i][j]为前i个数中，逆序对数量为j的数组，共有多少个</span></span><br><span class="line">    <span class="comment">//当新增1个数时，原有逆序的每个不同位置都能形成一个逆序对，所以</span></span><br><span class="line">    <span class="comment">//当前数i的摆放位置：  最右侧，          右2                右3                       j - 当前数自己能达到的最多逆序对数量 即i-1个数</span></span><br><span class="line">    <span class="comment">//dp[i][j] = dp[i - 1][j] + dp[i - 1][j - 1] + dp[i - 1][j - 2] + .... + dp[i - 1][j -  (i - 1)].</span></span><br><span class="line">    <span class="comment">//分情况讨论：</span></span><br><span class="line">    <span class="comment">//当i &gt; j时，i摆放位置能满足逆序对j的数量，所以增项去到dp[i - 1][0]</span></span><br><span class="line">    <span class="comment">// i &lt;= j, i自己只能达到 i - 1个逆序对，所以为达到逆序对j的数量，上一个队列至少得有 j -（i-1)个逆序对，所以增项去到dp[i - 1][j -  (i - 1)]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kInversePairs0</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][k + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">//正序排列</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; j)&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt;= j; l++) &#123;</span><br><span class="line">                        dp[i][j] = (dp[i][j] + dp[i - <span class="number">1</span>][l]) % mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> j - i + <span class="number">1</span>; l &lt;= j; l++) &#123;</span><br><span class="line">                        dp[i][j] = (dp[i][j] + dp[i - <span class="number">1</span>][l]) % mod;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上面方法超时，优化枚举行为</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kInversePairs</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][k + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">//正序排列</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>, window = <span class="number">1</span>; j &lt;= k; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i &gt; j)&#123;</span><br><span class="line">                    <span class="comment">//滚动更新窗口</span></span><br><span class="line">                    window = (window + dp[i - <span class="number">1</span>][j]) % mod;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    window = ((window + dp[i - <span class="number">1</span>][j]) % mod - dp[i - <span class="number">1</span>][j - i] + mod) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = window;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 用观察优化枚举技巧2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 用观察优化枚举技巧2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JobScheduling</title>
      <link href="/2025/04/14/JobScheduling/"/>
      <url>/2025/04/14/JobScheduling/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.用观察优化枚举技巧<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/4/14 17:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 规划兼职工作</span></span><br><span class="line"><span class="comment">// 你打算利用空闲时间来做兼职工作赚些零花钱，这里有n份兼职工作</span></span><br><span class="line"><span class="comment">// 每份工作预计从startTime[i]开始、endTime[i]结束，报酬为profit[i]</span></span><br><span class="line"><span class="comment">// 返回可以获得的最大报酬</span></span><br><span class="line"><span class="comment">// 注意，时间上出现重叠的 2 份工作不能同时进行</span></span><br><span class="line"><span class="comment">// 如果你选择的工作在时间X结束，那么你可以立刻进行在时间X开始的下一份工作</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/maximum-profit-in-job-scheduling/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JobScheduling</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误做法！！！时间范围太大了，卡dp空间了</span></span><br><span class="line">    <span class="comment">//想了下贪心，好像不行，换dp思路去做</span></span><br><span class="line">    <span class="comment">//1.选当前时间i开始工作，则下一个工作时间是 大于等于 i + end的位置，能获得的利润是多少</span></span><br><span class="line">    <span class="comment">//2. 不选当前i时间工作，继续递归i+1,工作能开始时间不变，能获得的利润</span></span><br><span class="line">    <span class="comment">//二者取最大值</span></span><br><span class="line">    <span class="comment">//base case为 i == n return 0;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jobScheduling0</span><span class="params">(<span class="type">int</span>[] startTime, <span class="type">int</span>[] endTime, <span class="type">int</span>[] profit)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> startTime.length;</span><br><span class="line">        <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">3</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[i] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;startTime[i], endTime[i], profit[i]&#125;;</span><br><span class="line">            max = Math.max(max, endTime[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先对数组按开始时间排序</span></span><br><span class="line">        Arrays.sort(arr, (a, b) -&gt; Integer.compare(a[<span class="number">0</span>], b[<span class="number">0</span>]));</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][max + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f(<span class="number">0</span>, <span class="number">0</span>, arr, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//时间范围太大了，卡dp空间了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> start, <span class="type">int</span>[][] arr, <span class="type">int</span>[][] dp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == arr.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[i][start] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[i][start];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不选当前时间工作和选当前时间工作 取最大</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Math.max(f(i + <span class="number">1</span>, start, arr, dp), arr[i][<span class="number">0</span>] &lt; start ? <span class="number">0</span> : f(i + <span class="number">1</span>, arr[i][<span class="number">1</span>], arr, dp) + arr[i][<span class="number">2</span>]);</span><br><span class="line">        dp[i][start] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//主流程还是一样，只是省去时间维度的数组</span></span><br><span class="line">    <span class="comment">//仔细思考下，其实和开始时间无关，和结束时间有关（结束时间决定下一个开始工作时间）</span></span><br><span class="line">    <span class="comment">//且如果能让结果 根据结束时间单调递增，那就不需要记录结束时间的维度了，</span></span><br><span class="line">    <span class="comment">// 只要找到满足结束时间内，最右测的dp[i]即可（因为单调递增，所以最右就是最大利润的结果）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">jobScheduling</span><span class="params">(<span class="type">int</span>[] startTime, <span class="type">int</span>[] endTime, <span class="type">int</span>[] profit)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> startTime.length;</span><br><span class="line">        <span class="type">int</span>[][] job = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">3</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            job[i] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;startTime[i], endTime[i], profit[i]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先对数组按结束时间排序</span></span><br><span class="line">        Arrays.sort(job, (a, b) -&gt; Integer.compare(a[<span class="number">1</span>], b[<span class="number">1</span>]));</span><br><span class="line">        <span class="comment">//优化一维</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">//第一个任务</span></span><br><span class="line">        dp[<span class="number">0</span>] = job[<span class="number">0</span>][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, start; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//选当前任务</span></span><br><span class="line">            start = job[i][<span class="number">0</span>];</span><br><span class="line">            dp[i] = job[i][<span class="number">2</span>];</span><br><span class="line">            <span class="comment">//至少有一个任务结束时间比当前任务开始时间小，即至少能再做一个任务，则找最右侧最大利润</span></span><br><span class="line">            <span class="keyword">if</span> (job[<span class="number">0</span>][<span class="number">1</span>] &lt;= start)&#123;</span><br><span class="line">                <span class="comment">//当前任务利润 再加上 之前结束任务小于当前任务开始时间的最右侧的利润结果</span></span><br><span class="line">                dp[i] += dp[find(job, i - <span class="number">1</span>, start)];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//两者取最大结果</span></span><br><span class="line">            dp[i] = Math.max(dp[i], dp[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找到最右侧任务结束时间小于当前时间的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[][] arr, <span class="type">int</span> index, <span class="type">int</span> start)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = index, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找右边最大值</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[mid][<span class="number">1</span>] &lt;= start)&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 用观察优化枚举技巧2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 用观察优化枚举技巧2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DiSequence</title>
      <link href="/2025/04/10/DiSequence/"/>
      <url>/2025/04/10/DiSequence/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.用观察优化枚举技巧;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/4/10 16:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// DI序列的有效排列</span></span><br><span class="line"><span class="comment">// 给定一个长度为n的字符串s，其中s[i]是:</span></span><br><span class="line"><span class="comment">// &quot;D&quot;意味着减少，&quot;I&quot;意味着增加</span></span><br><span class="line"><span class="comment">// 有效排列是对有n+1个在[0,n]范围内的整数的一个排列perm，使得对所有的i：</span></span><br><span class="line"><span class="comment">// 如果 s[i] == &#x27;D&#x27;，那么 perm[i] &gt; perm[i+1]</span></span><br><span class="line"><span class="comment">// 如果 s[i] == &#x27;I&#x27;，那么 perm[i] &lt; perm[i+1]</span></span><br><span class="line"><span class="comment">// 返回有效排列的perm的数量</span></span><br><span class="line"><span class="comment">// 因为答案可能很大，答案对 1000000007 取模</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/valid-permutations-for-di-sequence/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiSequence</span> &#123;</span><br><span class="line">    <span class="comment">//没啥思路 直接看左神了/</span></span><br><span class="line">    <span class="comment">//很抽象的递归</span></span><br><span class="line">    <span class="comment">//i-1位置之前的数都已经排序好了，现在排序i位置，</span></span><br><span class="line">    <span class="comment">//主要有这个less的概念：剩下未用的数字中，比位置i - 1小的有less个</span></span><br><span class="line">    <span class="comment">//当要降序排列时，假设less = 4， 为a b c d（小到大排序）, 即当取a时，下一个递归为i+1, 0， 取b时下一个递归为i+1, 1,....</span></span><br><span class="line">    <span class="comment">//即要排序的数字和实际大小无关，只需要知道个数即可，真tm抽象</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numPermsDISequence0</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//0位置特殊处理成D序，假设0位置之前的是+∞，所以比+∞小的有全部个数</span></span><br><span class="line">        <span class="keyword">return</span> f(s.toCharArray(), <span class="number">0</span>, s.length() + <span class="number">1</span>, s.length() + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> s 字符数组</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> i 当前位置，也代表前面用了几个数了</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> less 表示剩下未用的数字中，比位置i - 1小的有less个</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n 数字总个数</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//通过大部分测试用例，但会超时</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">char</span>[] s, <span class="type">int</span> i, <span class="type">int</span> less, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27;D&#x27;</span>)&#123;<span class="comment">//降序d</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; less; j++) &#123;</span><br><span class="line">                ans += f(s, i + <span class="number">1</span>, j, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;<span class="comment">//升序排序， 比i - 1位置大的有n - less - i个</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n - less - i; j++) &#123;</span><br><span class="line">                <span class="comment">//比当前i位置小的有less + j个</span></span><br><span class="line">                ans += f(s, i + <span class="number">1</span>, less + j, n);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//改dp,观察优化枚举行为</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numPermsDISequence</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//0位置特殊处理成D序，假设0位置之前的是+∞，所以比+∞小的有全部个数</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>][n+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[n][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从下往上更新，所以倒推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">0</span> || s[i - <span class="number">1</span>] == <span class="string">&#x27;D&#x27;</span>) &#123;<span class="comment">//降序d</span></span><br><span class="line">                <span class="comment">//原本算式，要的是下一行左边的所有格子</span></span><br><span class="line">                <span class="comment">//通过观察发现，下一行左边的所有格子 可以通过当前行左边的格子和左下角的格子得到</span></span><br><span class="line">                <span class="comment">//即dp[i][less] = dp[i][less - 1] + dp[i + 1][less - 1]</span></span><br><span class="line">                <span class="comment">//所以观察优化得到, 当前行less为0时，结果为0</span></span><br><span class="line">                dp[i][<span class="number">1</span>] = dp[i][<span class="number">0</span>] + dp[i + <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">less</span> <span class="operator">=</span> <span class="number">2</span>; less &lt;= n - i; less++) &#123;</span><br><span class="line">                    dp[i][less] = (dp[i][less - <span class="number">1</span>] + dp[i + <span class="number">1</span>][less - <span class="number">1</span>]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//升序排序， 比i - 1位置大的有n - less - i个</span></span><br><span class="line">                <span class="comment">//原本算式，要的是下一行右边的限定长度的所有格子，长度为n - less - i</span></span><br><span class="line">                <span class="comment">//通过观察发现，下一行右的长度为n - less - i的所有格子 可以通过下一行当前格子和当前行右边的格子得到</span></span><br><span class="line">                <span class="comment">//即dp[i][less] = dp[i + 1][less] + dp[i][less + 1]</span></span><br><span class="line">                <span class="comment">//而最右边的格子必然等于</span></span><br><span class="line">                <span class="comment">//所以观察优化得到</span></span><br><span class="line">                <span class="comment">//最右边的格子为没有任何一个格子小于当前数时，即less为0时</span></span><br><span class="line">                dp[i][n - i - <span class="number">1</span>] = dp[i + <span class="number">1</span>][n - i - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">less</span> <span class="operator">=</span> n - i - <span class="number">2</span>; less &gt;= <span class="number">0</span>; less--) &#123;</span><br><span class="line">                    dp[i][less] = (dp[i + <span class="number">1</span>][less] + dp[i][less + <span class="number">1</span>]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 用观察优化枚举技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 用观察优化枚举技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MaxProfit6</title>
      <link href="/2025/04/09/MaxProfit6/"/>
      <url>/2025/04/09/MaxProfit6/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.用观察优化枚举技巧;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/4/9 22:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 买卖股票的最佳时机含冷冻期</span></span><br><span class="line"><span class="comment">// 给定一个整数数组prices，其中第  prices[i] 表示第 i 天的股票价格</span></span><br><span class="line"><span class="comment">// 设计一个算法计算出最大利润</span></span><br><span class="line"><span class="comment">// 在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:</span></span><br><span class="line"><span class="comment">// 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)</span></span><br><span class="line"><span class="comment">// 注意：你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxProfit6</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//和 买卖股票的最佳时机 IV 这题类似，只是取dp的时候要跳一个</span></span><br><span class="line">    <span class="comment">//直接dp，假设dp[i][0]为当前位置不持有股票所能获得最大利润，dp[i][1]为持有股票所能获得最大利润,</span></span><br><span class="line">    <span class="comment">//dp[i][0] = Math.max( dp[i - 1][0], dp[i-1][1] + prices[i]) -&gt; i-1时刻不持有股票 或 i-1时刻持有股票，并在当前时刻卖出获得prices[i]</span></span><br><span class="line">    <span class="comment">//dp[i][1] = dp[i - 1][1], dp[i-2][0] - prices[i];  -&gt; 要么上一时刻就持有股票，要么前两次时刻不持有股票， 取最大</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit0</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>], dp[i-<span class="number">1</span>][<span class="number">1</span>] + prices[i]);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>)&#123;</span><br><span class="line">                dp[<span class="number">1</span>][<span class="number">1</span>] = Math.max(-prices[<span class="number">0</span>], -prices[<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][<span class="number">1</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i-<span class="number">2</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空间压缩, 3个变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">zero</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">one</span> <span class="operator">=</span> -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, lastlast = <span class="number">0</span>, last = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//更新数据，就只是用3个变量模拟数组的3层值</span></span><br><span class="line">            lastlast = last;</span><br><span class="line">            last = zero;</span><br><span class="line">            zero = Math.max(zero, one + prices[i]);</span><br><span class="line">            <span class="keyword">if</span> (i == <span class="number">1</span>)&#123;</span><br><span class="line">                one = Math.max(-prices[<span class="number">0</span>], -prices[<span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                one = Math.max(one, lastlast - prices[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zero;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 用观察优化枚举技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 用观察优化枚举技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MaxProfit5</title>
      <link href="/2025/04/09/MaxProfit5/"/>
      <url>/2025/04/09/MaxProfit5/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.用观察优化枚举技巧;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/4/9 14:57</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 买卖股票的最佳时机含手续费</span></span><br><span class="line"><span class="comment">// 给定一个整数数组 prices，其中 prices[i]表示第 i 天的股票价格</span></span><br><span class="line"><span class="comment">// 整数 fee 代表了交易股票的手续费用</span></span><br><span class="line"><span class="comment">// 你可以无限次地完成交易，但是你每笔交易都需要付手续费</span></span><br><span class="line"><span class="comment">// 如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了。</span></span><br><span class="line"><span class="comment">// 返回获得利润的最大值</span></span><br><span class="line"><span class="comment">// 注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxProfit5</span> &#123;</span><br><span class="line">    <span class="comment">//错误思路！！！！</span></span><br><span class="line">    <span class="comment">//如果某上升段获利大于等于手续费，则这一段就确实是获利的，否则可以考虑是否找下一段更大的数字以至于能节省手续费</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit0</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, premin = prices[<span class="number">0</span>]; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] - premin &gt; fee)&#123;</span><br><span class="line">                ans += prices[i] - premin - fee;</span><br><span class="line">                premin = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            premin = Math.min(premin, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp思路也挺巧妙的，通过设立是否持有股票来二维dp</span></span><br><span class="line">    <span class="comment">//dp思路：定义dp[i][0]为0.。i位置不持有股票得到的最大利润，dp[i][1]为持有股票得到的最大利润</span></span><br><span class="line">    <span class="comment">//所以dp[i][0] =  Math.max(dp[i - 1][0],dp[i - 1][1] + prices[i] - fee)  -&gt; 前面不持有股票 和 持有股票并在当前卖出获利 两者取最大值</span></span><br><span class="line">    <span class="comment">//dp[i][1] = Math.max( dp[i - 1][1], dp[i - 1][0] - prices[i])  -&gt; 前面持有股票 和 不持有股票并在当前花钱买入 两者取最大值</span></span><br><span class="line">    <span class="comment">//dp[0][0] = 0, dp[0][1] = -prices[0]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit1</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">2</span>];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">1</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = Math.max(dp[i - <span class="number">1</span>][<span class="number">0</span>],dp[i - <span class="number">1</span>][<span class="number">1</span>] + prices[i] - fee);</span><br><span class="line">            dp[i][<span class="number">1</span>] = Math.max( dp[i - <span class="number">1</span>][<span class="number">1</span>], dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空间压缩，只有两个值，直接用普通变量替代了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">zero</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">one</span> <span class="operator">=</span> -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//只依赖上一行的格子,设立一个临时变量保存旧值即可</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, tmp; i &lt; n; i++) &#123;</span><br><span class="line">            tmp = zero;</span><br><span class="line">            zero = Math.max(zero, one + prices[i] - fee);</span><br><span class="line">            one = Math.max(one, tmp - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> zero;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//leetcode官方解的另一个贪心思路：</span></span><br><span class="line">    <span class="comment">//将手续费放在买入时进行计算</span></span><br><span class="line">    <span class="comment">//buy表示在最大化收益的前提下，如果我们手上拥有一支股票，那么它的最低买入价格是多少</span></span><br><span class="line">    <span class="comment">//当我们卖出一支股票时，我们就立即获得了以相同价格并且免除手续费买入一支股票的权利</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit3</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">buy</span> <span class="operator">=</span> prices[<span class="number">0</span>] + fee;</span><br><span class="line">        <span class="type">int</span> <span class="variable">profit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] + fee &lt; buy) &#123;</span><br><span class="line">                buy = prices[i] + fee;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (prices[i] &gt; buy) &#123;</span><br><span class="line">                profit += prices[i] - buy;</span><br><span class="line">                buy = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左神思路</span></span><br><span class="line">    <span class="comment">//这个思路没看懂</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit4</span><span class="params">(<span class="type">int</span>[] prices, <span class="type">int</span> fee)</span> &#123;</span><br><span class="line">        <span class="comment">// prepare : 交易次数无限制情况下，获得收益的同时扣掉了一次购买和手续费之后，最好的情况</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">prepare</span> <span class="operator">=</span> -prices[<span class="number">0</span>] - fee;</span><br><span class="line">        <span class="comment">// done : 交易次数无限制情况下，能获得的最大收益</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">done</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            done = Math.max(done, prepare + prices[i]);</span><br><span class="line">            prepare = Math.max(prepare, done - prices[i] - fee);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> done;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 用观察优化枚举技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 用观察优化枚举技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MaxProfit4</title>
      <link href="/2025/04/08/MaxProfit4/"/>
      <url>/2025/04/08/MaxProfit4/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.用观察优化枚举技巧;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>  有点难度的，关键在于想到k - 1 和k关系的转换，即转移方程</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/4/8 17:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 买卖股票的最佳时机 IV</span></span><br><span class="line"><span class="comment">// 给你一个整数数组 prices 和一个整数 k ，其中 prices[i] 是某支给定的股票在第 i 天的价格</span></span><br><span class="line"><span class="comment">// 设计一个算法来计算你所能获取的最大利润。你最多可以完成 k 笔交易</span></span><br><span class="line"><span class="comment">// 也就是说，你最多可以买 k 次，卖 k 次</span></span><br><span class="line"><span class="comment">// 注意：你不能同时参与多笔交易，你必须在再次购买前出售掉之前的股票</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxProfit4</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getUp</span><span class="params">(<span class="type">int</span>[] prices)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            ans = Math.max(ans, ans + prices[i] - prices[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没啥思路。。想dp却找不到dp[k-1]和dp[k]的关系。。</span></span><br><span class="line">    <span class="comment">//看了左神代码懂了，也是假设某个点i是当此操作的卖出点</span></span><br><span class="line">    <span class="comment">// k 和 k-1的关系就是 若当前点i不卖出，则dp[k][i] = dp[k][i - 1]</span></span><br><span class="line">    <span class="comment">//若当前点i是当次操作的卖出点，则枚举0...i-1位置的上次操作的卖出点j， 再加上 当次获利，枚举结果取最大值 即dp[k][i] = Math.max( dp[k - 1][i] + prices[i] - prices[j])</span></span><br><span class="line">    <span class="comment">//有个剪枝操作：如果k &gt; n / 2的长度，即k能在每一个波段都能做操作，即只要获取所有上升波段的利润即可</span></span><br><span class="line">    <span class="comment">//虽然能通过，但耗时长</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit0</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="comment">//剪枝操作， 获取所有上升波段</span></span><br><span class="line">        <span class="keyword">if</span> (k &gt;= n / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> getUp(prices);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[k + <span class="number">1</span>][n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= k; i++) &#123;</span><br><span class="line">                <span class="comment">//j代表当前遍历位置</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="comment">//当前位置不做卖出操作</span></span><br><span class="line">                    dp[i][j] = dp[i][j - <span class="number">1</span>];</span><br><span class="line">                    <span class="comment">//l代表j之前的所有点位</span></span><br><span class="line">                    <span class="comment">//当前位置做卖出操作，枚举之前所有点位的买入操作</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; j; l++) &#123;</span><br><span class="line">                        <span class="comment">//卖出点位j - 买入点位l， 并加上上次操作卖出位置l的值， 全局取最大</span></span><br><span class="line">                        dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][l] + prices[j] - prices[l]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dp[k][n - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试优化代码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit1</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span>&#123;</span><br><span class="line">        <span class="comment">//观察发现，最后一个枚举行为，其实只是找到0.。j中最大的dp[i - 1][l] - price[l]  再加上一个固定值prices[j]而已</span></span><br><span class="line">        <span class="comment">//所以用best记录dp[i - 1][l] - price[l]，并滚动更新best值</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="comment">//剪枝操作， 获取所有上升波段</span></span><br><span class="line">        <span class="keyword">if</span> (k &gt;= n / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> getUp(prices);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[k + <span class="number">1</span>][n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, best; i &lt;= k; i++) &#123;</span><br><span class="line">                <span class="comment">//设置初始值，然后滚动更新</span></span><br><span class="line">                best = dp[i - <span class="number">1</span>][<span class="number">0</span>] - prices[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">//j代表当前遍历位置</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j - <span class="number">1</span>], best + prices[j]);</span><br><span class="line">                    <span class="comment">//滚动更新j之前的best值</span></span><br><span class="line">                    best = Math.max(best, dp[i - <span class="number">1</span>][j] - prices[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dp[k][n - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//再上面基础上进行空间压缩优化</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span>[] prices)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="comment">//剪枝操作， 获取所有上升波段</span></span><br><span class="line">        <span class="keyword">if</span> (k &gt;= n / <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> getUp(prices);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            <span class="comment">//依赖当前行左边的格子，所以从左到右更新，依赖上一行的格子，从上到下更新</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, best; i &lt;= k; i++) &#123;</span><br><span class="line">                <span class="comment">//设置初始值，然后滚动更新</span></span><br><span class="line">                best = dp[<span class="number">0</span>] - prices[<span class="number">0</span>];</span><br><span class="line">                <span class="comment">//从右到左更新</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>, tmp; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="comment">//注意best的更新依赖未更新前的dp[j]</span></span><br><span class="line">                    tmp = dp[j];</span><br><span class="line">                    dp[j] = Math.max(dp[j - <span class="number">1</span>], best + prices[j]);</span><br><span class="line">                    <span class="comment">//滚动更新j之前的best值</span></span><br><span class="line">                    best = Math.max(best, tmp - prices[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 用观察优化枚举技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 用观察优化枚举技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MaxProfit3</title>
      <link href="/2025/04/08/MaxProfit3/"/>
      <url>/2025/04/08/MaxProfit3/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.用观察优化枚举技巧;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/4/8 12:43</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 买卖股票的最佳时机 III</span></span><br><span class="line"><span class="comment">// 给定一个数组，它的第 i 个元素是一支给定的股票在第 i 天的价格。</span></span><br><span class="line"><span class="comment">// 设计一个算法来计算你所能获取的最大利润。你最多可以完成 两笔 交易</span></span><br><span class="line"><span class="comment">// 注意：你不能同时参与多笔交易，你必须在再次购买前出售掉之前的股票</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxProfit3</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误思路！！并不是找两段上升段！是找某区间内最大差值</span></span><br><span class="line">    <span class="comment">//案例：</span></span><br><span class="line">    <span class="comment">//测试用例:[1,2,4,2,5,7,2,4,9,0]</span></span><br><span class="line">    <span class="comment">//测试结果:12</span></span><br><span class="line">    <span class="comment">//期望结果:13</span></span><br><span class="line">    <span class="comment">//记录最大的两段上升段的值，  firstMaxValue 和secondMaxValue</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit0</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max1</span> <span class="operator">=</span> <span class="number">0</span>, max2 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> prices[<span class="number">0</span>], premin = prices[<span class="number">0</span>], sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找上升段</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="comment">//上升段结束</span></span><br><span class="line">            <span class="keyword">if</span> (pre &gt; prices[i])&#123;</span><br><span class="line">                <span class="comment">//计算该上升段最大利润</span></span><br><span class="line">                sum = pre - premin;</span><br><span class="line">                <span class="keyword">if</span> (sum != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (max1 == <span class="number">0</span>)&#123;</span><br><span class="line">                        max1 = sum;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (max2 == <span class="number">0</span>)&#123;</span><br><span class="line">                        max2 = sum;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//将最大值赋值给max2</span></span><br><span class="line">                        <span class="keyword">if</span> (sum &gt;= max2)&#123;</span><br><span class="line">                            max1 = max2;</span><br><span class="line">                            max2 = sum;</span><br><span class="line">                        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (sum &gt; max1)&#123;</span><br><span class="line">                            max1 = sum;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                premin = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            pre = prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后一段利润</span></span><br><span class="line">        sum = pre - premin;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max2 + max1 + sum - Math.min(Math.min(sum, max1), max2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//思路2：分成2步讨论。 必须一笔交易 和必须两笔交易</span></span><br><span class="line">    <span class="comment">//必须使用两个交易的情况下能获得的最大利润:</span></span><br><span class="line">    <span class="comment">//假设第一笔交易完成在i位置，所以讨论出0..i位置能获得的最大利润加上 i+1到 n位置能获得的最大利润</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//预处理数组</span></span><br><span class="line">        <span class="type">int</span>[] leftMax = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] rightMax = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, min = prices[<span class="number">0</span>], ans = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans = Math.max(prices[i] - min, ans);</span><br><span class="line">            min = Math.min(prices[i], min);</span><br><span class="line">            leftMax[i] = ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>, max = prices[n - <span class="number">1</span>], ans = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ans = Math.max(max - prices[i], ans);</span><br><span class="line">            max = Math.max(prices[i], max);</span><br><span class="line">            rightMax[i] = ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只使用一笔交易的情况下能获得的最大利润</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> leftMax[n - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//必须使用两个交易的情况下能获得的最大利润</span></span><br><span class="line">        <span class="comment">//假设第一笔交易在i位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            ans2 = Math.max(ans2, leftMax[i] + rightMax[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(ans1, ans2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/************************以下是左神思路和观察优化方式**********************/</span></span><br><span class="line">    <span class="comment">//主要就是通过定i位置为第二次交易卖出的位置，来枚举0...i位置上第一次交易的最大获利值，再观察优化代码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 完全不优化枚举的方法</span></span><br><span class="line">    <span class="comment">// 通过不了，会超时</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit1</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="comment">// dp1[i] : 0...i范围上发生一次交易，不要求在i的时刻卖出，最大利润是多少</span></span><br><span class="line">        <span class="type">int</span>[] dp1 = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, min = prices[<span class="number">0</span>]; i &lt; n; i++) &#123;</span><br><span class="line">            min = Math.min(min, prices[i]);</span><br><span class="line">            dp1[i] = Math.max(dp1[i - <span class="number">1</span>], prices[i] - min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp2[i] : 0...i范围上发生两次交易，并且第二次交易在i时刻卖出，最大利润是多少</span></span><br><span class="line">        <span class="type">int</span>[] dp2 = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 第二次交易一定要在i时刻卖出</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">                <span class="comment">// 枚举第二次交易的买入时机j &lt;= i</span></span><br><span class="line">                dp2[i] = Math.max(dp2[i], dp1[j] + prices[i] - prices[j]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, dp2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 观察出优化枚举的方法</span></span><br><span class="line">    <span class="comment">// 引入best数组，需要分析能力</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit2</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="comment">// dp1[i] : 0...i范围上发生一次交易，不要求在i的时刻卖出，最大利润是多少</span></span><br><span class="line">        <span class="type">int</span>[] dp1 = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, min = prices[<span class="number">0</span>]; i &lt; n; i++) &#123;</span><br><span class="line">            min = Math.min(min, prices[i]);</span><br><span class="line">            dp1[i] = Math.max(dp1[i - <span class="number">1</span>], prices[i] - min);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// best[i] : 0...i范围上，所有的dp1[i]-prices[i]，最大值是多少</span></span><br><span class="line">        <span class="comment">// 这是数组的设置完全是为了替代最后for循环的枚举行为</span></span><br><span class="line">        <span class="type">int</span>[] best = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        best[<span class="number">0</span>] = dp1[<span class="number">0</span>] - prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            best[i] = Math.max(best[i - <span class="number">1</span>], dp1[i] - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp2[i] : 0...i范围上发生两次交易，并且第二次交易在i时刻卖出，最大利润是多少</span></span><br><span class="line">        <span class="type">int</span>[] dp2 = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 不需要枚举了</span></span><br><span class="line">            <span class="comment">// 因为，best[i]已经揭示了，0...i范围上，所有的dp1[i]-prices[i]，最大值是多少</span></span><br><span class="line">            dp2[i] = best[i] + prices[i];</span><br><span class="line">            ans = Math.max(ans, dp2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发现所有更新行为都可以放在一起</span></span><br><span class="line">    <span class="comment">// 并不需要写多个并列的for循环</span></span><br><span class="line">    <span class="comment">// 就是等义改写，不需要分析能力</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit3</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> prices.length;</span><br><span class="line">        <span class="type">int</span>[] dp1 = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span>[] best = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        best[<span class="number">0</span>] = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span>[] dp2 = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, min = prices[<span class="number">0</span>]; i &lt; n; i++) &#123;</span><br><span class="line">            min = Math.min(min, prices[i]);</span><br><span class="line">            dp1[i] = Math.max(dp1[i - <span class="number">1</span>], prices[i] - min);</span><br><span class="line">            best[i] = Math.max(best[i - <span class="number">1</span>], dp1[i] - prices[i]);</span><br><span class="line">            dp2[i] = best[i] + prices[i];</span><br><span class="line">            ans = Math.max(ans, dp2[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 发现只需要有限几个变量滚动更新下去就可以了</span></span><br><span class="line">    <span class="comment">// 空间压缩的版本</span></span><br><span class="line">    <span class="comment">// 就是等义改写，不需要分析能力</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit4</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">dp1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">best</span> <span class="operator">=</span> -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, min = prices[<span class="number">0</span>]; i &lt; prices.length; i++) &#123;</span><br><span class="line">            min = Math.min(min, prices[i]);</span><br><span class="line">            dp1 = Math.max(dp1, prices[i] - min);</span><br><span class="line">            best = Math.max(best, dp1 - prices[i]);</span><br><span class="line">            ans = Math.max(ans, best + prices[i]); <span class="comment">// ans = Math.max(ans, dp2);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 用观察优化枚举技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 用观察优化枚举技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MaxProfit2</title>
      <link href="/2025/04/07/MaxProfit2/"/>
      <url>/2025/04/07/MaxProfit2/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.用观察优化枚举技巧;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/4/7 22:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 买卖股票的最佳时机 II</span></span><br><span class="line"><span class="comment">// 给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格</span></span><br><span class="line"><span class="comment">// 在每一天，你可以决定是否购买和/或出售股票</span></span><br><span class="line"><span class="comment">// 你在任何时候 最多 只能持有 一股 股票</span></span><br><span class="line"><span class="comment">// 你也可以先购买，然后在 同一天 出售</span></span><br><span class="line"><span class="comment">// 返回 你能获得的 最大 利润</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxProfit2</span> &#123;</span><br><span class="line">    <span class="comment">//思路1：获取每一个上升段</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit0</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="comment">//上升阶段的最小值， 上升阶段的最新数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">premin</span> <span class="operator">=</span> prices[<span class="number">0</span>], pre = prices[<span class="number">0</span>], ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="comment">//上升段结束，结算利润，更新数值</span></span><br><span class="line">            <span class="keyword">if</span> (pre &gt; prices[i])&#123;</span><br><span class="line">                ans += pre - premin;</span><br><span class="line">                premin = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            pre = prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记得加上最后一段上升</span></span><br><span class="line">        <span class="keyword">return</span> ans + pre - premin;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//思路2：这里就是获取每一段利润。（每天都进行买卖）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            ans += Math.max(prices[i] - prices[i - <span class="number">1</span>], <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 用观察优化枚举技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 用观察优化枚举技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MaxProfit1</title>
      <link href="/2025/04/07/MaxProfit1/"/>
      <url>/2025/04/07/MaxProfit1/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.用观察优化枚举技巧;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/4/7 22:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 买卖股票的最佳时机</span></span><br><span class="line"><span class="comment">// 给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 天的价格</span></span><br><span class="line"><span class="comment">// 你只能选择 某一天 买入这只股票，并选择在 未来的某一个不同的日子 卖出该股票</span></span><br><span class="line"><span class="comment">// 设计一个算法来计算你所能获取的最大利润</span></span><br><span class="line"><span class="comment">// 返回你可以从这笔交易中获取的最大利润</span></span><br><span class="line"><span class="comment">// 如果你不能获取任何利润，返回 0</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxProfit1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">        <span class="comment">//直接记录前面最小值，然后当前值和最小值相减 获取全局最大利润</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">premin</span> <span class="operator">=</span> prices[<span class="number">0</span>], ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            ans = Math.max(ans, prices[i] - premin);</span><br><span class="line">            premin = Math.min(premin, prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 用观察优化枚举技巧 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 用观察优化枚举技巧 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CanDistribute</title>
      <link href="/2025/04/07/CanDistribute/"/>
      <url>/2025/04/07/CanDistribute/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.状压dp2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>  这里很难，而且有个贪心思路的陷阱</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/4/7 17:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配重复整数</span></span><br><span class="line"><span class="comment">// 给你一个长度为n的整数数组nums，这个数组中至多有50个不同的值</span></span><br><span class="line"><span class="comment">// 同时你有m个顾客的订单quantity，其中整数quantity[i]是第i位顾客订单的数目</span></span><br><span class="line"><span class="comment">// 请你判断是否能将nums中的整数分配给这些顾客，且满足：</span></span><br><span class="line"><span class="comment">// 第i位顾客恰好有quantity[i]个整数、第i位顾客拿到的整数都是相同的</span></span><br><span class="line"><span class="comment">// 每位顾客都要满足上述两个要求，返回是否能都满足</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/distribute-repeating-integers/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanDistribute</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//许久之前错误的思路：</span></span><br><span class="line">    <span class="comment">//贪心思路，优先匹配大的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canDistribute0</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span>[] quantity)</span> &#123;</span><br><span class="line">        Arrays.sort(quantity);</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(Collections.reverseOrder());</span><br><span class="line">        <span class="comment">//统计词频，返回不同数字的个数</span></span><br><span class="line">        <span class="type">int</span>[] cnt = count(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : cnt) &#123;</span><br><span class="line">            queue.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> quantity.length - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="comment">//如果当前最大数量都无法满足</span></span><br><span class="line">            <span class="keyword">if</span> (num &lt; quantity[index])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; quantity[index])&#123;</span><br><span class="line">                queue.add(num - quantity[index]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] count(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>; r &lt; nums.length; ) &#123;</span><br><span class="line">            <span class="keyword">while</span> (r &lt; nums.length &amp;&amp; nums[r] == nums[l])&#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[index++] = r - l;</span><br><span class="line">            l = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[index];</span><br><span class="line">        System.arraycopy(cnt, <span class="number">0</span>, result, <span class="number">0</span>, index);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个思路和0号方法一样的错误点！！！</span></span><br><span class="line">    <span class="comment">//能不能用双指针做呢？ 两个都按小到大排序，左指针l指向词频数组，右指针r指向数量数组</span></span><br><span class="line">    <span class="comment">//l &lt; r -&gt; l++ , l == r -&gt; l++, r++, l &gt; r -&gt; r++</span></span><br><span class="line">    <span class="comment">//有个点就是当l &gt; r时候，l不++, 数值减去当前已用数量，继续遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canDistribute2</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span>[] quantity)</span>&#123;</span><br><span class="line">        Arrays.sort(quantity);</span><br><span class="line">        <span class="comment">//统计词频，返回不同数字的个数</span></span><br><span class="line">        <span class="type">int</span>[] cnt = count(nums);</span><br><span class="line">        <span class="comment">//排个序</span></span><br><span class="line">        Arrays.sort(cnt);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cnt.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> quantity.length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt; n &amp;&amp; r &lt; m)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[l] &lt; quantity[r])&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cnt[l] == quantity[r])&#123;</span><br><span class="line">                l++;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cnt[l] -= quantity[r++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//看是否处理完全部</span></span><br><span class="line">        <span class="keyword">return</span> r == m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误思路!!!!!!!!!!! （原本这个思路大体上是对的，只是因为这题不好递推，所以以后思考先用递归的思路去做，反正递归改递推很简单）</span></span><br><span class="line">    <span class="comment">//有点思路：</span></span><br><span class="line">    <span class="comment">//用status记录 已经满足的顾客状态位</span></span><br><span class="line">    <span class="comment">//1.统计完所有所有不同的数的词频，得到一个词频数组arr</span></span><br><span class="line">    <span class="comment">//2.定义dp[i][status]为 词频数组从0 .。i范围内，是否能满足status下 的所有顾客， 值为value</span></span><br><span class="line">    <span class="comment">//2.1所以 若不取当前数i，则dp[i][status] = dp[i - 1][status];</span></span><br><span class="line">    <span class="comment">//2.2 若能取当前数i， 遍历当前数i能满足的所有顾客数 next， 则dp[i][status] |= dp[i - 1][status ^ next];</span></span><br><span class="line">    <span class="comment">//base case是什么呢？i == 0 时，填充当前数能满足的所有顾客数next？</span></span><br><span class="line">    <span class="comment">// 但不同当前数得到的结果不同呀，遍历每个不同当前数获得的结果？ 好像无论取那个数作为base case 都不会影响最终结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canDistribute1</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span>[] quantity)</span>&#123;</span><br><span class="line">        Arrays.sort(quantity);</span><br><span class="line">        <span class="comment">//统计词频，返回不同数字的个数</span></span><br><span class="line">        <span class="type">int</span>[] cnt = count(nums);</span><br><span class="line">        <span class="comment">//排个序，按道理用大</span></span><br><span class="line"><span class="comment">//        Arrays.sort(cnt);</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span>  <span class="operator">=</span> cnt.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> quantity.length;</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][<span class="number">1</span> &lt;&lt; m];</span><br><span class="line">        <span class="comment">//填充base case</span></span><br><span class="line">        <span class="comment">//每个状态位</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">0</span>; status &lt; (<span class="number">1</span> &lt;&lt; m); status++) &#123;</span><br><span class="line">            <span class="comment">//判断当前数，当前状态位是否能满足</span></span><br><span class="line">            dp[<span class="number">0</span>][status] = canDo(cnt[<span class="number">0</span>], status, quantity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">0</span>; status &lt; (<span class="number">1</span> &lt;&lt; m); status++) &#123;</span><br><span class="line">                dp[i][status] = dp[i - <span class="number">1</span>][status];</span><br><span class="line">                <span class="comment">//遍历当前数能满足的所有状态 next? 咋整？</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前数，能否满足当前状态</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">canDo</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> status, <span class="type">int</span>[] quantity)</span>&#123;</span><br><span class="line">        <span class="comment">//判断cur能否满足 status的所有1</span></span><br><span class="line">        <span class="keyword">while</span> (status != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//某一次cur不满足了，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (cur &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> status &amp; -status;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Double</span>(Math.log(next)).intValue();</span><br><span class="line">            cur -= quantity[index];</span><br><span class="line">            status -= next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur &gt;= <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用递归的思路去做：</span></span><br><span class="line">    <span class="comment">//1.统计词频，用status的状态位表示要满足的顾客数</span></span><br><span class="line">    <span class="comment">//2.总流程：需要满足的状态为status，如果能取当前数，则遍历当前数能满足的所有状态位next，status ^ next, 走下一个数递归</span></span><br><span class="line">    <span class="comment">//难点在于怎么 快速得到当前数能满足的所有状态位next  -》 转化下思维，当前状态位status需要的订单数为x，只要 当前数的数量cur大于x，则必然满足status</span></span><br><span class="line">    <span class="comment">//所以先构建所有status需要的订单数x 组成数组sum[]</span></span><br><span class="line">    <span class="comment">//然后再走2的逻辑</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canDistribute</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span>[] quantity)</span>&#123;</span><br><span class="line">        <span class="comment">//先统计词频</span></span><br><span class="line">        <span class="type">int</span>[] cnt = count(nums);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> cnt.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> quantity.length;</span><br><span class="line">        <span class="comment">//统计每个状态需要多少订单</span></span><br><span class="line">        <span class="type">int</span>[] sum = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span> &lt;&lt; m];</span><br><span class="line">        <span class="comment">//i代表要满足的顾客，统计i状态之前所有可能状态所需订单数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, cur; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="comment">//j代表之前每个小于i位置的状态,</span></span><br><span class="line">            <span class="comment">// 这里代表把i位置之前的顾客能组成的所有状态 加上当前i位置的状态所需要的订单数</span></span><br><span class="line">            <span class="comment">//所以这里只是用i位置|上之前所有状态+cnt[i],即给i位置赋值</span></span><br><span class="line">            cur = <span class="number">1</span> &lt;&lt; i;<span class="comment">//i所在状态位</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; cur; j++) &#123;</span><br><span class="line">                <span class="comment">//前面状态所需的订单数+当前i位置所需订单数</span></span><br><span class="line">                sum[cur | j] = sum[j] + quantity[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f(<span class="number">0</span>, (<span class="number">1</span> &lt;&lt; m) - <span class="number">1</span>, cnt, sum, <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">1</span> &lt;&lt; m]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cur 当前位置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> status 需要满足的状态  1为未满足，0为以满足</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cnt</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sum</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dp</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> cur, <span class="type">int</span> status, <span class="type">int</span>[] cnt, <span class="type">int</span>[] sum, <span class="type">int</span>[][] dp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (status == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur &gt;= cnt.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[cur][status] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[cur][status] == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//枚举status的所有子状态</span></span><br><span class="line">        <span class="comment">//i为statu中所有子状态</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> status; i &gt; <span class="number">0</span>; i = status &amp; (i - <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">//如果当前数量能满足这个订单状态的数量，则使用这个数</span></span><br><span class="line">            <span class="keyword">if</span> (cnt[cur] &gt;= sum[i] &amp;&amp; f(cur + <span class="number">1</span>, status ^ i, cnt, sum, dp))&#123;</span><br><span class="line">                ans = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ans)&#123;</span><br><span class="line">            <span class="comment">//不用当前数数</span></span><br><span class="line">            ans = f(cur + <span class="number">1</span>, status, cnt, sum, dp);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[cur][status] = ans ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 状压dp2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压dp2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NumberOfGoodSubsets</title>
      <link href="/2025/03/14/NumberOfGoodSubsets/"/>
      <url>/2025/03/14/NumberOfGoodSubsets/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.状压dp2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>  难题 属于有想法，但细节做不对</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/3/14 21:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好子集的数目</span></span><br><span class="line"><span class="comment">// 给你一个整数数组 nums，好子集的定义如下：</span></span><br><span class="line"><span class="comment">// nums的某个子集，所有元素的乘积可以表示为一个或多个互不相同质数的乘积</span></span><br><span class="line"><span class="comment">// 比如nums = [1, 2, 3, 4]</span></span><br><span class="line"><span class="comment">// [2, 3]，[1, 2, 3]，[1, 3] 是好子集</span></span><br><span class="line"><span class="comment">// 乘积分别为6=2*3，6=2*3，3=3</span></span><br><span class="line"><span class="comment">// [1, 4]和[4]不是好子集，因为乘积分别为4=2*2和4=2*2</span></span><br><span class="line"><span class="comment">// 返回nums中不同的好子集的数目，答案对 1000000007 取模</span></span><br><span class="line"><span class="comment">// 如果两个子集删除的下标不同，那么它们被视为不同的子集</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/the-number-of-good-subsets/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberOfGoodSubsets</span> &#123;</span><br><span class="line">    <span class="comment">//思路错了！！！！ （每个数作为第一个status可能都会有不一样的结果，所以这里应该要统计每个数的不同status状态，再去做子集计算。感觉改改也能找到正确思路，但改不到··）</span></span><br><span class="line">    <span class="comment">//如果数组子集的乘积 可以表示为 互不相同的质数的乘积，那这个是好子集</span></span><br><span class="line">    <span class="comment">//思路：</span></span><br><span class="line">    <span class="comment">//因为数组的值，都在30以内，所以其实就只看30以内的质数即可</span></span><br><span class="line">    <span class="comment">//如果某个子集已经是好子集，那再加上当前数是否是好子集呢？ 判断当前数是否是好子集（即是否可以由质数相乘得来）</span></span><br><span class="line">    <span class="comment">//即假设dp[i]为 0...i - 1范围上好子集的个数，</span></span><br><span class="line">    <span class="comment">// 则dp[i] 为 i - 1位置上的数可以由质数相乘得来吗？ 是 -&gt; dp[i] = dp[i - 1] * 2; 否 -》 dp[i] = dp[i - 1];</span></span><br><span class="line">    <span class="comment">//难点在于自己内要不同的质数，若用status表示所有可用质数，</span></span><br><span class="line">    <span class="comment">//那假设dp[i][status]为为 0...i - 1范围上好子集的个数，</span></span><br><span class="line">    <span class="comment">//则dp[i][status]=</span></span><br><span class="line">    <span class="comment">// i - 1位置上的数可以由质数相乘 且 和status中已有的质数无关吗？ dp[i][status] = dp[i - 1][status ^ i位置的质数] * 2 ; 否 -》 dp[i][status] = dp[i - 1][status];</span></span><br><span class="line">    <span class="comment">//1.把所有30以内的质数列举到数组中，status的位即表示每一位质数</span></span><br><span class="line">    <span class="comment">//2.从0.。i 标记 dp[i][status]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">11</span>,<span class="number">13</span>,<span class="number">17</span>,<span class="number">19</span>,<span class="number">23</span>,<span class="number">29</span>&#125;;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfGoodSubsets0</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][<span class="number">1</span> &lt;&lt; arr.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f0(<span class="number">0</span>, <span class="number">0</span>, nums, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//记忆化搜素没做出来！！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f0</span><span class="params">(<span class="type">int</span> status, <span class="type">int</span> cur, <span class="type">int</span>[] nums, <span class="type">int</span>[][] dp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> status != <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//所有质数都被用过了</span></span><br><span class="line">        <span class="keyword">if</span> (status == ((<span class="number">1</span> &lt;&lt; arr.length) - <span class="number">1</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[cur][status] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[cur][status];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不取当前数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> f0(status, cur + <span class="number">1</span>, nums, dp);</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> getNext(nums[cur]);</span><br><span class="line">        <span class="comment">//取当前数</span></span><br><span class="line">        <span class="comment">//当前数组成的质数 是否没有出现过</span></span><br><span class="line">        <span class="comment">//这里计算次数时有问题，要的是此前所有子集的结果 * 2</span></span><br><span class="line">        <span class="keyword">if</span> (next != <span class="number">0</span> &amp;&amp; ((status &amp; next) == <span class="number">0</span>))&#123;</span><br><span class="line">            ans = (ans + (<span class="number">2</span> * f0(status | next, cur + <span class="number">1</span>, nums, dp)) % MOD) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[cur][status] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前数是否全由质数组成，并获取是哪几个质数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNext</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num == <span class="number">1</span> || num &lt; arr[i]) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num % arr[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                num /= arr[i];</span><br><span class="line">                result |=  (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> num == <span class="number">1</span> ? result : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左神思路：</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXV</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">LIMIT</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加速判断每个数占用的质数因子，这里直接统计出来</span></span><br><span class="line">    <span class="comment">//从0到30，每个数占用的质数因子</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] own = &#123; <span class="number">0b0000000000</span>, <span class="comment">// 0</span></span><br><span class="line">            <span class="number">0b0000000000</span>, <span class="comment">// 1</span></span><br><span class="line">            <span class="number">0b0000000001</span>, <span class="comment">// 2</span></span><br><span class="line">            <span class="number">0b0000000010</span>, <span class="comment">// 3</span></span><br><span class="line">            <span class="number">0b0000000000</span>, <span class="comment">// 4</span></span><br><span class="line">            <span class="number">0b0000000100</span>, <span class="comment">// 5</span></span><br><span class="line">            <span class="number">0b0000000011</span>, <span class="comment">// 6</span></span><br><span class="line">            <span class="number">0b0000001000</span>, <span class="comment">// 7</span></span><br><span class="line">            <span class="number">0b0000000000</span>, <span class="comment">// 8</span></span><br><span class="line">            <span class="number">0b0000000000</span>, <span class="comment">// 9</span></span><br><span class="line">            <span class="number">0b0000000101</span>, <span class="comment">// 10</span></span><br><span class="line">            <span class="number">0b0000010000</span>, <span class="comment">// 11</span></span><br><span class="line">            <span class="number">0b0000000000</span>, <span class="comment">// 12</span></span><br><span class="line">            <span class="number">0b0000100000</span>, <span class="comment">// 13</span></span><br><span class="line">            <span class="number">0b0000001001</span>, <span class="comment">// 14</span></span><br><span class="line">            <span class="number">0b0000000110</span>, <span class="comment">// 15</span></span><br><span class="line">            <span class="number">0b0000000000</span>, <span class="comment">// 16</span></span><br><span class="line">            <span class="number">0b0001000000</span>, <span class="comment">// 17</span></span><br><span class="line">            <span class="number">0b0000000000</span>, <span class="comment">// 18</span></span><br><span class="line">            <span class="number">0b0010000000</span>, <span class="comment">// 19</span></span><br><span class="line">            <span class="number">0b0000000000</span>, <span class="comment">// 20</span></span><br><span class="line">            <span class="number">0b0000001010</span>, <span class="comment">// 21</span></span><br><span class="line">            <span class="number">0b0000010001</span>, <span class="comment">// 22</span></span><br><span class="line">            <span class="number">0b0100000000</span>, <span class="comment">// 23</span></span><br><span class="line">            <span class="number">0b0000000000</span>, <span class="comment">// 24</span></span><br><span class="line">            <span class="number">0b0000000000</span>, <span class="comment">// 25</span></span><br><span class="line">            <span class="number">0b0000100001</span>, <span class="comment">// 26</span></span><br><span class="line">            <span class="number">0b0000000000</span>, <span class="comment">// 27</span></span><br><span class="line">            <span class="number">0b0000000000</span>, <span class="comment">// 28</span></span><br><span class="line">            <span class="number">0b1000000000</span>, <span class="comment">// 29</span></span><br><span class="line">            <span class="number">0b0000000111</span> <span class="comment">// 30</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//思路：（这里的巧妙点是对每个数先统计数量，再讨论1....i范围内的dp转移方程</span></span><br><span class="line">    <span class="comment">//因为30以内的质数只有10个，所以可用status的位表示质数是否已用。 1为已用，0为可用</span></span><br><span class="line">    <span class="comment">//1.统计每个数的数量cnt[i]，</span></span><br><span class="line">    <span class="comment">//2.定义dp[i][status]为1...i范围内，使得子集乘积的质因子为status状态下，子集的个数，所以ans为1...30范围内，所有status状态下的子集数量累加和</span></span><br><span class="line">    <span class="comment">//假设当前数为cur，当前数拥有的质数因子为 curnext,则</span></span><br><span class="line">    <span class="comment">//2.1.当子集不取当前数i时，dp[i][status] = dp[i - 1][status]</span></span><br><span class="line">    <span class="comment">//2.2当前数i可取时，dp[i][status] = dp[i - 1][status ^ curnext] * cnt[cur] （每个当前数都是一个新子集）</span></span><br><span class="line">    <span class="comment">//所以dp[i][status] = dp[i - 1][status] + dp[i - 1][status | curnext] * cnt[cur] (当前数i可取）</span></span><br><span class="line">    <span class="comment">//这里的base case也有意思： 因为1不是质数，但可加到任何子集中组成新子集，使得结果数量 * 2，</span></span><br><span class="line">    <span class="comment">//所以base case就是 cur = 1 且 status 为0 时，（因为cur = 1下，status不可能有质因子子集，他只能作为其他好子集的乘数）</span></span><br><span class="line">    <span class="comment">// 有1个1 就 * 2，有n个1 就*  2^n</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//严格位置依赖的dp</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfGoodSubsets1</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[MAXV + <span class="number">1</span>][LIMIT];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计数频</span></span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[MAXV + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            cnt[num]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//填充base case  1情况下，status 为0时的 1的乘积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cnt[<span class="number">1</span>]; i++) &#123;</span><br><span class="line">            base = (base &lt;&lt; <span class="number">1</span>) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">1</span>][<span class="number">0</span>] = base;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移</span></span><br><span class="line">        <span class="comment">//dp[i][status] = dp[i - 1][status]</span></span><br><span class="line">        <span class="comment">//dp[i][status] = dp[i - 1][status ^ curnext] * cnt[cur]</span></span><br><span class="line">        <span class="comment">//依赖上一行格子 和上一行左边的格子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">2</span>, count, next; cur &lt;= MAXV; cur++) &#123;</span><br><span class="line">            count = cnt[cur];<span class="comment">//数频</span></span><br><span class="line">            next = own[cur];<span class="comment">//当前数拥有的质因子</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> <span class="number">0</span>; status &lt; LIMIT; status++) &#123;</span><br><span class="line">                <span class="comment">//不取当前数</span></span><br><span class="line">                dp[cur][status] = dp[cur - <span class="number">1</span>][status];</span><br><span class="line">                <span class="comment">//有数 且 有质因子   取当前数</span></span><br><span class="line">                <span class="keyword">if</span> (count != <span class="number">0</span> &amp;&amp; next != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//质因子符合预期子集的质因子</span></span><br><span class="line">                    <span class="keyword">if</span> ((status &amp; next) == next) &#123;</span><br><span class="line">                        dp[cur][status] = (<span class="type">int</span>) (((<span class="type">long</span>) dp[cur - <span class="number">1</span>][status ^ next] * count + dp[cur - <span class="number">1</span>][status]) % MOD);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; LIMIT; i++) &#123;</span><br><span class="line">            ans = (ans + dp[MAXV][i]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空间压缩更好做</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfGoodSubsets</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[LIMIT];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计数频</span></span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[MAXV + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            cnt[num]++;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cnt[<span class="number">1</span>]; i++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>] = (dp[<span class="number">0</span>] &lt;&lt; <span class="number">1</span>) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//状态转移</span></span><br><span class="line">        <span class="comment">//dp[i][status] = dp[i - 1][status]</span></span><br><span class="line">        <span class="comment">//dp[i][status] = dp[i - 1][status ^ curnext] * cnt[cur]</span></span><br><span class="line">        <span class="comment">//依赖上一行格子 和上一行左边的格子</span></span><br><span class="line">        <span class="comment">//从上到下， 从右到左更新</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">2</span>, count, next; cur &lt;= MAXV; cur++) &#123;</span><br><span class="line">            count = cnt[cur];</span><br><span class="line">            next = own[cur];</span><br><span class="line">            <span class="comment">//取当前数更新</span></span><br><span class="line">            <span class="keyword">if</span> (count != <span class="number">0</span> &amp;&amp; next != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">status</span> <span class="operator">=</span> LIMIT - <span class="number">1</span>; status &gt;= <span class="number">0</span>; status--) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((status &amp; next) == next)&#123;</span><br><span class="line">                        dp[status] =  (<span class="type">int</span>) (((<span class="type">long</span>)dp[status ^ next] * count + dp[status]) % MOD);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; LIMIT; i++) &#123;</span><br><span class="line">            ans = ( ans + dp[i] ) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">NumberOfGoodSubsets</span> <span class="variable">numberOfGoodSubsets</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">NumberOfGoodSubsets</span>();</span><br><span class="line">        numberOfGoodSubsets.numberOfGoodSubsets(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 状压dp2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压dp2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OptimalAccountBalancing</title>
      <link href="/2025/03/14/OptimalAccountBalancing/"/>
      <url>/2025/03/14/OptimalAccountBalancing/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.状压dp2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 这题leetcode要钱 所以没做</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/3/14 15:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最优账单平衡</span></span><br><span class="line"><span class="comment">// 给你一个表示交易的数组 transactions</span></span><br><span class="line"><span class="comment">// 其中 transactions[i] = [fromi, toi, amounti]</span></span><br><span class="line"><span class="comment">// 表示 ID = fromi 的人给 ID = toi 的人共计 amounti</span></span><br><span class="line"><span class="comment">// 请你计算并返回还清所有债务的最小交易笔数</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/optimal-account-balancing/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptimalAccountBalancing</span> &#123;</span><br><span class="line">    <span class="comment">// 题目说了人员编号的最大范围：0 ~ 12</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">13</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minTransfers</span><span class="params">(<span class="type">int</span>[][] transactions)</span> &#123;</span><br><span class="line">        <span class="comment">// 加工出来的debt数组中一定不含有0</span></span><br><span class="line">        <span class="type">int</span>[] debt = debts(transactions);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> debt.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span> &lt;&lt; n];</span><br><span class="line">        Arrays.fill(dp, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> n - f(debt, (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>, <span class="number">0</span>, n, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] debts(<span class="type">int</span>[][] transactions) &#123;</span><br><span class="line">        <span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] tran : transactions) &#123;</span><br><span class="line">            help[tran[<span class="number">0</span>]] -= tran[<span class="number">2</span>];</span><br><span class="line">            help[tran[<span class="number">1</span>]] += tran[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : help) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">                n++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] debt = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : help) &#123;</span><br><span class="line">            <span class="keyword">if</span> (num != <span class="number">0</span>) &#123;</span><br><span class="line">                debt[index++] = num;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> debt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] debt, <span class="type">int</span> set, <span class="type">int</span> sum, <span class="type">int</span> n, <span class="type">int</span>[] dp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[set] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[set];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ((set &amp; (set - <span class="number">1</span>)) != <span class="number">0</span>) &#123; <span class="comment">// 集合中不只一个元素</span></span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((set &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// 找到任何一个元素，去除这个元素</span></span><br><span class="line">                        <span class="comment">// 剩下的集合进行尝试，返回值 + 1</span></span><br><span class="line">                        ans = f(debt, set ^ (<span class="number">1</span> &lt;&lt; i), sum - debt[i], n, dp) + <span class="number">1</span>;</span><br><span class="line">                        <span class="comment">// 然后不需要再尝试下一个元素了，因为答案一定是一样的</span></span><br><span class="line">                        <span class="comment">// 所以直接break</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((set &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>) &#123;</span><br><span class="line">                        ans = Math.max(ans, f(debt, set ^ (<span class="number">1</span> &lt;&lt; i), sum - debt[i], n, dp));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[set] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 状压dp2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压dp2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NumberWays</title>
      <link href="/2025/03/14/NumberWays/"/>
      <url>/2025/03/14/NumberWays/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.状压dp2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/3/14 11:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberWays</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误思路!!!：帽子范围太大了，会超时， 记忆化搜索也开不了status的空间</span></span><br><span class="line">    <span class="comment">//用status表示每种帽子是否被选取，遍历每个人，选每个意向中可选的帽子</span></span><br><span class="line">    <span class="comment">//直到有一种方案可行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberWays0</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; hats)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> hats.size();</span><br><span class="line">        <span class="type">long</span> <span class="variable">status</span> <span class="operator">=</span> (<span class="number">1L</span> &lt;&lt; <span class="number">40</span>) - <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//第一位不用置0</span></span><br><span class="line">        <span class="keyword">return</span> f0(status, <span class="number">0</span>, hats);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> status</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cur 当前人</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rest 还剩多少人没配</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> List</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f0</span><span class="params">(<span class="type">long</span> status, <span class="type">int</span> cur, List&lt;List&lt;Integer&gt;&gt; hats)</span>&#123;</span><br><span class="line">        <span class="comment">//人都配完了，返回这种方案</span></span><br><span class="line">        <span class="keyword">if</span> (cur == hats.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        if (dp[status][cur] != -1)&#123;</span></span><br><span class="line"><span class="comment">//            return dp[status][cur];</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前人选帽子</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(Integer i : hats.get(cur))&#123;</span><br><span class="line">            <span class="keyword">if</span> ((status &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>)&#123;</span><br><span class="line">                ans = (ans + f0(status ^ (<span class="number">1</span> &lt;&lt; i), cur + <span class="number">1</span>, hats) % MOD) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        dp[status][cur] = ans;</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//换个思路：</span></span><br><span class="line">    <span class="comment">//人数很少，用status表示每个人是否已被满足，用帽子去挑可选的人</span></span><br><span class="line">    <span class="comment">//重组数据，构建每个帽子可匹配的人集合，遍历每个帽子，选可选的人。 完成条件为帽子遍历完后， 所有人都被满足</span></span><br><span class="line">    <span class="comment">//因为要的是每个人带不同帽子的方案数，所以这里帽子不选也是一个方案</span></span><br><span class="line">    <span class="comment">//帽子选人时，有2种情况：</span></span><br><span class="line">    <span class="comment">//1.此帽子一个人也不选</span></span><br><span class="line">    <span class="comment">//2.此帽子遍历每一个可选的人</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberWays</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; person)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> person.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取帽子最大编号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; person.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Integer hat : person.get(i)) &#123;</span><br><span class="line">                m = Math.max(m, hat);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; hats = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(m);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            hats.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//组装数据，每个帽子可选的人</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; person.size(); i++) &#123;</span><br><span class="line">            <span class="comment">//每个人可选的帽子</span></span><br><span class="line">            <span class="keyword">for</span> (Integer hat : person.get(i)) &#123;</span><br><span class="line">                <span class="comment">//对应帽子可选的人</span></span><br><span class="line">                hats.get(hat).add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][<span class="number">1</span> &lt;&lt; n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>, <span class="number">1</span>, hats, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//人从0开始，帽子从1开始</span></span><br><span class="line">    <span class="comment">//因为要的是每个人带不同帽子的方案数，所以这里帽子不选也是一个方案</span></span><br><span class="line">    <span class="comment">//帽子选人时，有2种情况：</span></span><br><span class="line">    <span class="comment">//1.此帽子一个人也不选</span></span><br><span class="line">    <span class="comment">//2.此帽子遍历每一个可选的人</span></span><br><span class="line">    <span class="comment">//再优化的话可以用位来代表每一个帽子可选的人，即把双列表替换成数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> status, <span class="type">int</span> cur, List&lt;List&lt;Integer&gt;&gt; hats, <span class="type">int</span>[][] dp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (status == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur == hats.size())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[cur][status] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[cur][status];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//此帽子一个人也不选的方案</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> f(status, cur + <span class="number">1</span>, hats, dp) % MOD;</span><br><span class="line">        <span class="comment">//遍历当前帽子可选的人</span></span><br><span class="line">        <span class="keyword">for</span> (Integer i : hats.get(cur)) &#123;</span><br><span class="line">            <span class="comment">//当前人可选，尝试此种方案</span></span><br><span class="line">            <span class="keyword">if</span> ((status &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>)&#123;</span><br><span class="line">                ans = (ans + f(status ^ (<span class="number">1</span> &lt;&lt; i), cur + <span class="number">1</span>, hats, dp) % MOD) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[cur][status]= ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 状压dp2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压dp2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TSP2</title>
      <link href="/2025/03/12/TSP2/"/>
      <url>/2025/03/12/TSP2/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.状压dp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 这里是直接copy左神的</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/3/12 11:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 售货员的难题 - TSP问题</span></span><br><span class="line"><span class="comment">// 某乡有n个村庄(1&lt;=n&lt;=20)，有一个售货员，他要到各个村庄去售货</span></span><br><span class="line"><span class="comment">// 各村庄之间的路程s(1&lt;=s&lt;=1000)是已知的</span></span><br><span class="line"><span class="comment">// 且A村到B村的路程，与B到A的路大多不同(有向带权图)</span></span><br><span class="line"><span class="comment">// 为了提高效率，他从商店出发到每个村庄一次，然后返回商店所在的村，</span></span><br><span class="line"><span class="comment">// 假设商店所在的村庄为1</span></span><br><span class="line"><span class="comment">// 他不知道选择什么样的路线才能使所走的路程最短</span></span><br><span class="line"><span class="comment">// 请你帮他选择一条最短的路</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P1171</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下的code，提交时请把类名改成&quot;Main&quot;，可以直接通过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.StreamTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 卡空间是吧？绕一下！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TSP2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] start = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] back = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这个图中，其实是不算起始村的，其他村庄彼此到达的路径长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] graph = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不算起始村庄的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span> &lt;&lt; MAXN][MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); s++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                dp[s][i] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            n = (<span class="type">int</span>) in.nval - <span class="number">1</span>;</span><br><span class="line">            build();</span><br><span class="line">            in.nextToken();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                in.nextToken();</span><br><span class="line">                start[i] = (<span class="type">int</span>) in.nval;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                in.nextToken();</span><br><span class="line">                back[i] = (<span class="type">int</span>) in.nval;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    in.nextToken();</span><br><span class="line">                    graph[i][j] = (<span class="type">int</span>) in.nval;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(compute());</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">// 起始村无编号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 起始村 -&gt; i号村  +  i号村出发所有村子都走最终回到起始村</span></span><br><span class="line">            ans = Math.min(ans, start[i] + f(<span class="number">1</span> &lt;&lt; i, i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s : 不包含起始村的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> s, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s == (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> back[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[s][i] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[s][i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((s &amp; (<span class="number">1</span> &lt;&lt; j)) == <span class="number">0</span>) &#123;</span><br><span class="line">                ans = Math.min(ans, graph[i][j] + f(s | (<span class="number">1</span> &lt;&lt; j), j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[s][i] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 状压dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TSP1</title>
      <link href="/2025/03/11/TSP1/"/>
      <url>/2025/03/11/TSP1/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.状压dp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/3/11 15:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 售货员的难题 - TSP问题</span></span><br><span class="line"><span class="comment">// 某乡有n个村庄(1&lt;=n&lt;=20)，有一个售货员，他要到各个村庄去售货</span></span><br><span class="line"><span class="comment">// 各村庄之间的路程s(1&lt;=s&lt;=1000)是已知的</span></span><br><span class="line"><span class="comment">// 且A村到B村的路程，与B到A的路大多不同(有向带权图)</span></span><br><span class="line"><span class="comment">// 为了提高效率，他从商店出发到每个村庄一次，然后返回商店所在的村，</span></span><br><span class="line"><span class="comment">// 假设商店所在的村庄为1</span></span><br><span class="line"><span class="comment">// 他不知道选择什么样的路线才能使所走的路程最短</span></span><br><span class="line"><span class="comment">// 请你帮他选择一条最短的路</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P1171</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下的code，提交时请把类名改成&quot;Main&quot;，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TSP1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAXM</span> <span class="operator">=</span> <span class="number">19</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] graph = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM][MAXM];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span> &lt;&lt; MAXM][MAXM];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(in);</span><br><span class="line">        <span class="keyword">while</span> (st.nextToken() != StreamTokenizer.TT_EOF)&#123;</span><br><span class="line">            n = (<span class="type">int</span>) st.nval;</span><br><span class="line">            build();</span><br><span class="line">            <span class="comment">//构建带权有向图</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    st.nextToken();</span><br><span class="line">                    graph[i][j] = (<span class="type">int</span>) st.nval;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(compute());</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; (<span class="number">1</span> &lt;&lt; n); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[i][j] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//当前所在村为0号村，已经走过了 不再走了所以额外 - 1</span></span><br><span class="line">        <span class="keyword">return</span> f((<span class="number">1</span> &lt;&lt; n) - <span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//思路：</span></span><br><span class="line">    <span class="comment">//因为村庄数很少，而题目的目的是从0出发经历所有的村庄后再回到0（必然会回到0）,</span></span><br><span class="line">    <span class="comment">//每个村庄只会去一次，所以可用状压dp，用status记录每个村庄是否有到过，遍历所有可去的村庄，获取最小的ans</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> status, <span class="type">int</span> cur)</span>&#123;</span><br><span class="line">        <span class="comment">//所有点都走完，返回当前点到0的距离</span></span><br><span class="line">        <span class="keyword">if</span> (status == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> graph[cur][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[status][cur] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[status][cur];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从当前点出发 到 0点，返回最短路径</span></span><br><span class="line">        <span class="comment">//遍历所有可去的点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; graph[cur].length; i++) &#123;</span><br><span class="line">            <span class="comment">//没去过的点 且 有路径</span></span><br><span class="line">            <span class="keyword">if</span> ((status &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span>  &amp;&amp;  graph[cur][i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                ans = Math.min(ans, graph[cur][i] + f(status ^ (<span class="number">1</span> &lt;&lt; i), i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[status][cur] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 状压dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CanPartitionKSubsets</title>
      <link href="/2025/03/11/CanPartitionKSubsets/"/>
      <url>/2025/03/11/CanPartitionKSubsets/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.状压dp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/3/11 11:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 划分为k个相等的子集</span></span><br><span class="line"><span class="comment">// 给定一个整数数组  nums 和一个正整数 k，</span></span><br><span class="line"><span class="comment">// 找出是否有可能把这个数组分成 k 个非空子集，其总和都相等。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/partition-to-k-equal-sum-subsets/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanPartitionKSubsets</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//思路： （和火柴拼正方形一模一样）</span></span><br><span class="line">    <span class="comment">// 数组长度很小，可以用状压dp</span></span><br><span class="line">    <span class="comment">// 抓阄一样，每个子集凑齐平均数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canPartitionKSubsets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//除不尽，无法凑小数，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (sum % k != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一个状态不用</span></span><br><span class="line">        <span class="keyword">return</span> f((<span class="number">1</span> &lt;&lt; n + <span class="number">1</span>) - <span class="number">1</span>, k, <span class="number">0</span>, sum / k, nums, <span class="keyword">new</span> <span class="title class_">int</span>[ <span class="number">1</span> &lt;&lt; (n + <span class="number">1</span>)]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> status 状态 第一个状态不用</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> rest 剩余未完成的子集数量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sum 当前子集总和</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> target 子集目标总和</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dp 记忆化搜索</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> status, <span class="type">int</span> rest, <span class="type">int</span> sum, <span class="type">int</span> target, <span class="type">int</span>[] nums, <span class="type">int</span>[] dp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> status == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[status] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[status] == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历每个可用的状态，凑目标数</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, cur; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            cur = sum + nums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> ((status &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span> &amp;&amp; cur &lt;= target)&#123;</span><br><span class="line">                <span class="keyword">if</span> (cur == target) &#123;</span><br><span class="line">                    ans = f(status ^ (<span class="number">1</span> &lt;&lt; i), rest - <span class="number">1</span>, <span class="number">0</span>, target, nums, dp);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    ans = f(status ^ (<span class="number">1</span> &lt;&lt; i), rest, cur, target, nums, dp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ans) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[status] = ans ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 状压dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Makesquare</title>
      <link href="/2025/03/10/Makesquare/"/>
      <url>/2025/03/10/Makesquare/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.状压dp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/3/10 22:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 火柴拼正方形</span></span><br><span class="line"><span class="comment">// 你将得到一个整数数组 matchsticks</span></span><br><span class="line"><span class="comment">// 其中 matchsticks[i] 是第 i 个火柴棒的长度</span></span><br><span class="line"><span class="comment">// 你要用 所有的火柴棍 拼成一个正方形</span></span><br><span class="line"><span class="comment">// 你 不能折断 任何一根火柴棒，但你可以把它们连在一起，而且每根火柴棒必须 使用一次</span></span><br><span class="line"><span class="comment">// 如果你能拼出正方形，则返回 true ，否则返回 false</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/matchsticks-to-square/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Makesquare</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//思路：</span></span><br><span class="line">    <span class="comment">//因为数组长度很短，所以可用状压dp</span></span><br><span class="line">    <span class="comment">//1.有点像两数之和，把所有火柴加起来/4 求正方形长度</span></span><br><span class="line">    <span class="comment">//2.遍历每个可用的火柴，如果当前边累加和 与某个火柴能达成目标值，则完成一条边</span></span><br><span class="line">    <span class="comment">// 3.直到所有火柴都用光，若则返回true。 只要有一个不能完成边，则返回false。 对状态做记忆化搜索</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个i对应status中的位</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">makesquare</span><span class="params">(<span class="type">int</span>[] matchsticks)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matchsticks.length;</span><br><span class="line">        <span class="comment">//避免边界讨论，第一个位不用</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> matchstick : matchsticks) &#123;</span><br><span class="line">            sum += matchstick;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//搭建不了</span></span><br><span class="line">        <span class="keyword">if</span> (sum % <span class="number">4</span> != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//变成011111，但最后一位1不用</span></span><br><span class="line">        <span class="keyword">return</span> f((<span class="number">1</span> &lt;&lt; (n + <span class="number">1</span>)) - <span class="number">1</span>, sum / <span class="number">4</span>, <span class="number">0</span>, <span class="number">4</span>, matchsticks,  <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">1</span> &lt;&lt; (n + <span class="number">1</span>)]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> status, <span class="type">int</span> limit, <span class="type">int</span> sum, <span class="type">int</span> rest, <span class="type">int</span>[] nums, <span class="type">int</span>[] dp)</span> &#123;</span><br><span class="line">        <span class="comment">//火柴用光了也没返回false 即搭建成功</span></span><br><span class="line">        <span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//剩最后一位不用</span></span><br><span class="line">            <span class="keyword">return</span> status == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[status] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[status] == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//没有一个方式能搭建</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//遍历每个可用的火柴</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//只要有任何一个可行的情况 直接返回</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span>  sum + nums[i - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> ((status &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span> &amp;&amp; cur &lt;= limit) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cur == limit)&#123;</span><br><span class="line">                    ans = f(status ^ (<span class="number">1</span> &lt;&lt; i), limit, <span class="number">0</span>, rest - <span class="number">1</span>, nums, dp);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    ans = f(status ^ (<span class="number">1</span> &lt;&lt; i), limit, cur, rest, nums, dp);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ans)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        dp[status] = ans ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 状压dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CanIWin</title>
      <link href="/2025/03/10/CanIWin/"/>
      <url>/2025/03/10/CanIWin/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.状压dp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/3/10 16:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 我能赢吗</span></span><br><span class="line"><span class="comment">// 给定两个整数n和m</span></span><br><span class="line"><span class="comment">// 两个玩家可以轮流从公共整数池中抽取从1到n的整数（不放回）</span></span><br><span class="line"><span class="comment">// 抽取的整数会累加起来（两个玩家都算）</span></span><br><span class="line"><span class="comment">// 谁在自己的回合让累加和 &gt;= m，谁获胜</span></span><br><span class="line"><span class="comment">// 若先出手的玩家能稳赢则返回true，否则返回false</span></span><br><span class="line"><span class="comment">// 假设两位玩家游戏时都绝顶聪明，可以全盘为自己打算</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/can-i-win/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CanIWin</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//思路：</span></span><br><span class="line">    <span class="comment">//遍历每个可用的状态，只要有一个状态让对方失败，即可获胜</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canIWin</span><span class="params">(<span class="type">int</span> max, <span class="type">int</span> desiredTotal)</span> &#123;</span><br><span class="line">        <span class="comment">//先看累加和是否能到达</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span>  (<span class="number">1</span> + max) * max / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">//累加和不及目标数 或者目标数和最大值相差等于1</span></span><br><span class="line">        <span class="keyword">if</span> (sum &lt; desiredTotal || desiredTotal - max == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (max &gt;= desiredTotal)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[(<span class="number">1</span> &lt;&lt; max)];</span><br><span class="line">        <span class="keyword">return</span> f((<span class="number">1</span> &lt;&lt; max) - <span class="number">1</span> , desiredTotal, max, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历每个可用的状态，选让对方角色失败的状态</span></span><br><span class="line">    <span class="comment">//要挂个记忆化搜索，不然会超时</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> status, <span class="type">int</span> rest, <span class="type">int</span> max, <span class="type">int</span>[] dp)</span>&#123;</span><br><span class="line">        <span class="comment">//上一个角色选的结果已获胜，所以当前角色失败</span></span><br><span class="line">        <span class="keyword">if</span> (rest &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[status] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[status] == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历status的每个1</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; max; i++) &#123;</span><br><span class="line">            <span class="comment">// 考察所有数字，但是不能选择之前选了的数字</span></span><br><span class="line">            <span class="keyword">if</span> ((status &amp; (<span class="number">1</span> &lt;&lt; i)) != <span class="number">0</span> &amp;&amp; !f(status ^ (<span class="number">1</span> &lt;&lt; i), rest - i - <span class="number">1</span>, max, dp)) &#123;</span><br><span class="line">                ans = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//任何状态都用光了，全都赢不了</span></span><br><span class="line">        dp[status] = ans ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 状压dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CourseSelection2</title>
      <link href="/2025/02/18/CourseSelection2/"/>
      <url>/2025/02/18/CourseSelection2/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.树形dp2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/2/18 17:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.StreamTokenizer;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 选课</span></span><br><span class="line"><span class="comment">// 在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习</span></span><br><span class="line"><span class="comment">// 在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习</span></span><br><span class="line"><span class="comment">// 现在有 N 门功课，每门课有个学分，每门课有一门或没有直接先修课</span></span><br><span class="line"><span class="comment">// 若课程 a 是课程 b 的先修课即只有学完了课程 a，才能学习课程 b</span></span><br><span class="line"><span class="comment">// 一个学生要从这些课程里选择 M 门课程学习</span></span><br><span class="line"><span class="comment">// 问他能获得的最大学分是多少</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P2014</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下的code，提交时请把类名改成&quot;Main&quot;，可以直接通过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最优解，链式前向星建图 + dfn序的利用 + 巧妙定义下的尝试</span></span><br><span class="line"><span class="comment">// 时间复杂度O(n*m)，觉得难可以跳过，这个最优解是非常巧妙和精彩的！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CourseSelection2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">301</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链式前向星建图</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> edgeCnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] head = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] to = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dfn的计数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> dfnCnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下标为dfn序号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] val = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 下标为dfn序号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] size = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态规划表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN + <span class="number">2</span>][MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        edgeCnt = <span class="number">1</span>;</span><br><span class="line">        dfnCnt = <span class="number">0</span>;</span><br><span class="line">        Arrays.fill(head, <span class="number">0</span>, n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        Arrays.fill(dp[n + <span class="number">2</span>], <span class="number">0</span>, m + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        next[edgeCnt] = head[u];</span><br><span class="line">        to[edgeCnt] = v;</span><br><span class="line">        head[u] = edgeCnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            n = (<span class="type">int</span>) in.nval;</span><br><span class="line">            in.nextToken();</span><br><span class="line">            m = (<span class="type">int</span>) in.nval;</span><br><span class="line">            build(n, m);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                in.nextToken();</span><br><span class="line">                addEdge((<span class="type">int</span>) in.nval, i);</span><br><span class="line">                in.nextToken();</span><br><span class="line">                nums[i] = (<span class="type">int</span>) in.nval;</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(compute());</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        f(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 节点编号0 ~ n，dfn序号范围1 ~ n+1</span></span><br><span class="line">        <span class="comment">// 接下来的逻辑其实就是01背包！不过经历了很多转化</span></span><br><span class="line">        <span class="comment">// 整体的顺序是根据dfn序来进行的，从大的dfn序，遍历到小的dfn序</span></span><br><span class="line">        <span class="comment">// dp[i][j] : i ~ n+1 范围的节点，选择j个节点一定要形成有效结构的情况下，最大的累加和</span></span><br><span class="line">        <span class="comment">// 怎么定义有效结构？重点！重点！重点！</span></span><br><span class="line">        <span class="comment">// 假设i ~ n+1范围上，目前所有头节点的上方，有一个总的头节点</span></span><br><span class="line">        <span class="comment">// i ~ n+1范围所有节点，选出来j个节点的结构，</span></span><br><span class="line">        <span class="comment">// 挂在这个假想的总头节点之下，是一个连续的结构，没有断开的情况</span></span><br><span class="line">        <span class="comment">// 那么就说，i ~ n+1范围所有节点，选出来j个节点的结构是一个有效结构</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n + <span class="number">1</span>; i &gt;= <span class="number">2</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                dp[i][j] = Math.max(dp[i + size[i]][j], val[i] + dp[i + <span class="number">1</span>][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp[2][m] : 2 ~ n范围上，选择m个节点一定要形成有效结构的情况下，最大的累加和</span></span><br><span class="line">        <span class="comment">// 最后来到dfn序为1的节点，一定是原始的0号节点</span></span><br><span class="line">        <span class="comment">// 原始0号节点下方一定挂着有效结构</span></span><br><span class="line">        <span class="comment">// 并且和补充的0号节点一定能整体连在一起，没有任何跳跃连接</span></span><br><span class="line">        <span class="comment">// 于是整个问题解决</span></span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>] + dp[<span class="number">2</span>][m];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// u这棵子树的节点数返回</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> u)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ++dfnCnt;</span><br><span class="line">        val[i] = nums[u];</span><br><span class="line">        size[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">ei</span> <span class="operator">=</span> head[u], v; ei &gt; <span class="number">0</span>; ei = next[ei]) &#123;</span><br><span class="line">            v = to[ei];</span><br><span class="line">            size[i] += f(v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 树形dp2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形dp2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CourseSelection1</title>
      <link href="/2025/02/17/CourseSelection1/"/>
      <url>/2025/02/17/CourseSelection1/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.树形dp2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/2/17 16:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 选课</span></span><br><span class="line"><span class="comment">// 在大学里每个学生，为了达到一定的学分，必须从很多课程里选择一些课程来学习</span></span><br><span class="line"><span class="comment">// 在课程里有些课程必须在某些课程之前学习，如高等数学总是在其它课程之前学习</span></span><br><span class="line"><span class="comment">// 现在有 N 门功课，每门课有个学分，每门课有一门或没有直接先修课</span></span><br><span class="line"><span class="comment">// 若课程 a 是课程 b 的先修课即只有学完了课程 a，才能学习课程 b</span></span><br><span class="line"><span class="comment">// 一个学生要从这些课程里选择 M 门课程学习</span></span><br><span class="line"><span class="comment">// 问他能获得的最大学分是多少</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P2014</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下的code，提交时请把类名改成&quot;Main&quot;，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CourseSelection1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">301</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, m;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN][][];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//有点像分组背包，直接从0...i..n遍历，取m门课能获得的最大分组</span></span><br><span class="line">    <span class="comment">//注意！！：咋一看像是背包问题，但是却混合有依赖的背包，多重背包，分组背包。所以不能单纯用背包的思维和思路去解题</span></span><br><span class="line">    <span class="comment">//要用树形dp去看待问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            <span class="comment">// 节点编号从0~n</span></span><br><span class="line">            n = (<span class="type">int</span>) in.nval;</span><br><span class="line">            in.nextToken();</span><br><span class="line">            <span class="comment">//把虚拟头节点0加上</span></span><br><span class="line">            m = (<span class="type">int</span>) in.nval + <span class="number">1</span>;</span><br><span class="line">            build(n);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, pre; i &lt;= n; i++) &#123;</span><br><span class="line">                in.nextToken();</span><br><span class="line">                pre = (<span class="type">int</span>) in.nval;</span><br><span class="line">                <span class="comment">//单向 父 -》 子</span></span><br><span class="line">                graph.get(pre).add(i);</span><br><span class="line">                in.nextToken();</span><br><span class="line">                nums[i] = (<span class="type">int</span>) in.nval;</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(compute());</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        graph.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正确思路：（普通解法）</span></span><br><span class="line">    <span class="comment">//设定一个虚拟头节点0，连接所有主节点</span></span><br><span class="line">    <span class="comment">//定义dp[i][j][k]为，以i为头节点，前j个子节点，所有共选k个节点，能获得的最大分数</span></span><br><span class="line">    <span class="comment">//1.不选当前第j个子节点 -》 dp[i][j][k] = dp[i][j-1][k]</span></span><br><span class="line">    <span class="comment">//2.选当前第j个子节点</span></span><br><span class="line">    <span class="comment">//2.1 j节点中 的所有size个节点，选1门 ，其他前j-1个节点，选k - 1门</span></span><br><span class="line">    <span class="comment">//2.1 j节点中 的所有size个节点，选2门 ，其他前j-1个节点，选k - 2门</span></span><br><span class="line">    <span class="comment">//2.1 j节点中 的所有size个节点，选...k-1门， 其他前j-1个节点，选1门</span></span><br><span class="line">    <span class="comment">//即 j节点中 的所有size个节点，选s门， 其他前j-1个节点，选k - s门 -&gt;   dp[x][size][s] +  dp[i][j - 1][k - s] (x = 第j个节点的下标， size = x的所有子节点数）</span></span><br><span class="line">    <span class="comment">//因为i和x的不确定性（不知道谁大），所以这里用递归去做</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//初始化dp</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">//这里j可为0，所以长度是原选修课size + 1</span></span><br><span class="line">            dp[i] = <span class="keyword">new</span> <span class="title class_">int</span>[graph.get(i).size() + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; dp[i].length; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt;= m; k++) &#123;</span><br><span class="line">                    dp[i][j][k] = -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f(dp, <span class="number">0</span>, graph.get(<span class="number">0</span>).size(), m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前来到i号节点为头的子树</span></span><br><span class="line">    <span class="comment">// 只在i号节点、及其i号节点下方的前j棵子树上挑选节点</span></span><br><span class="line">    <span class="comment">// 一共挑选k个节点，并且保证挑选的节点连成一片</span></span><br><span class="line">    <span class="comment">// 返回最大的累加和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[][][] dp, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//无子节点或只可选1门课程，直接返回头节点i的值即可</span></span><br><span class="line">        <span class="keyword">if</span> (j == <span class="number">0</span> || k == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[i][j][k] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[i][j][k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不选当前第j课程的情况</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> f(dp, i, j - <span class="number">1</span>, k);</span><br><span class="line">        <span class="comment">//第j棵子树头节点v</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> graph.get(i).get(j - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//选当前j课程，选1...k - 1门</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">1</span>; s &lt; k; s++) &#123;</span><br><span class="line">            ans = Math.max(ans, f(dp, v, graph.get(v).size(), s) + f(dp, i, j - <span class="number">1</span>, k - s));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dp[i][j][k] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误的思路！！！！</span></span><br><span class="line">    <span class="comment">//分组背包，定义dp[i][j][k] 为: 前i门主课程中，有j门选修课课程，一共能能选择k门课程下，能获得的最大得分</span></span><br><span class="line">    <span class="comment">//如果要用背包，那得先分组呀（把子课程隔离)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute0</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][][];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">//这里j可为0，所以长度是原选修课size + 1</span></span><br><span class="line">            dp[i] = <span class="keyword">new</span> <span class="title class_">int</span>[graph.get(i).size() + <span class="number">1</span>][m];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//i门课程</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">//非主节点</span></span><br><span class="line">            <span class="keyword">if</span> (!graph.get(<span class="number">0</span>).contains(i))&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//选修当前i主课程下的j门课程</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= graph.get(i).size(); j++) &#123;</span><br><span class="line">                <span class="comment">//共选k门课程</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= m; k++) &#123;</span><br><span class="line">                    <span class="comment">//不选当前i课程</span></span><br><span class="line">                    dp[i][j][k] = dp[i - <span class="number">1</span>][j][k];</span><br><span class="line">                    <span class="comment">//修当前课程：之前结果i-1,k - 1 - ？ ?取决于选几门j</span></span><br><span class="line">                    dp[i][j][k] = Math.max(dp[i][j][k], dp[i - <span class="number">1</span>][j][k - j - <span class="number">1</span>]);</span><br><span class="line">                    ans = Math.max(dp[i][j][k], ans);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 树形dp2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形dp2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinimumScoreAfterRemovals</title>
      <link href="/2025/02/17/MinimumScoreAfterRemovals/"/>
      <url>/2025/02/17/MinimumScoreAfterRemovals/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.树形dp2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/2/17 15:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从树中删除边的最小分数</span></span><br><span class="line"><span class="comment">// 存在一棵无向连通树，树中有编号从0到n-1的n个节点，以及n-1条边</span></span><br><span class="line"><span class="comment">// 给你一个下标从0开始的整数数组nums长度为n，其中nums[i]表示第i个节点的值</span></span><br><span class="line"><span class="comment">// 另给你一个二维整数数组edges长度为n-1</span></span><br><span class="line"><span class="comment">// 其中 edges[i] = [ai, bi] 表示树中存在一条位于节点 ai 和 bi 之间的边</span></span><br><span class="line"><span class="comment">// 删除树中两条不同的边以形成三个连通组件，对于一种删除边方案，定义如下步骤以计算其分数：</span></span><br><span class="line"><span class="comment">// 分别获取三个组件每个组件中所有节点值的异或值</span></span><br><span class="line"><span class="comment">// 最大 异或值和 最小 异或值的 差值 就是这种删除边方案的分数</span></span><br><span class="line"><span class="comment">// 返回可能的最小分数</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/minimum-score-after-removals-on-a-tree/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinimumScoreAfterRemovals</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">1010</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] dfn = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line">    <span class="comment">//异或预处理数组, 下标为dfn序号. 从尾到头异或</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] xor = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] size = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> dfnCnt;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于删除边的行为，需要知道父亲节点和子树的关系，所以和dfn序有关</span></span><br><span class="line">    <span class="comment">//每删除一条边即可知道这条边所在节点的所有子节点，于是dnf序为0...cur1 - 1,是一组，  cur1 + size是第三组开始节点</span></span><br><span class="line">    <span class="comment">//所以结果就是两次遍历从0到dnfcnt序号，每删除边所能得到的分组，得到分组最大最小异或值的差值，所有方案中取差值最小</span></span><br><span class="line">    <span class="comment">//时间复杂度O(n*n)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumScore</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">        dfnCnt = <span class="number">0</span>;</span><br><span class="line">        graph.clear();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//建图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">            graph.get(u).add(v);</span><br><span class="line">            graph.get(v).add(u);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Arrays.fill(dfn, <span class="number">0</span>, n, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//标记dfn序</span></span><br><span class="line">        f(<span class="number">0</span>, nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历删除每条边</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> edges.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, first, second; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="comment">//删除的第一条边，获取比较大的dfn序号</span></span><br><span class="line">            first = Math.max(dfn[edges[i][<span class="number">0</span>]], dfn[edges[i][<span class="number">1</span>]]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>, pre, pos, sum1, sum2, sum3, max, min; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="comment">//删除的第二条边</span></span><br><span class="line">                second = Math.max(dfn[edges[j][<span class="number">0</span>]], dfn[edges[j][<span class="number">1</span>]]);</span><br><span class="line">                <span class="comment">//比较两条边，排序前后删除的两个节点</span></span><br><span class="line">                <span class="keyword">if</span> (first &gt; second)&#123;</span><br><span class="line">                    pre = second;</span><br><span class="line">                    pos = first;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    pre = first;</span><br><span class="line">                    pos = second;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//计算异或结果</span></span><br><span class="line">                <span class="comment">//最后断的边的节点树异或结果</span></span><br><span class="line">                sum1 = xor[pos];</span><br><span class="line">                <span class="comment">// xor[1] : 整棵树的异或和</span></span><br><span class="line">                <span class="comment">// 因为头节点是0，一定拥有最小的dfn序号1</span></span><br><span class="line">                <span class="comment">// f函数调用的时候，也是从0节点开始的</span></span><br><span class="line">                <span class="comment">//如果是在同一颗树上</span></span><br><span class="line">                <span class="keyword">if</span> (pos &lt; pre + size[pre]) &#123;</span><br><span class="line">                    sum2 = xor[pre] ^ xor[pos];</span><br><span class="line">                    sum3 = xor[<span class="number">1</span>] ^ xor[pre];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sum2 = xor[pre];</span><br><span class="line">                    sum3 = xor[<span class="number">1</span>] ^ sum1 ^ sum2;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//计算所有方案中的最小分数</span></span><br><span class="line">                max = Math.max(sum1, Math.max(sum2, sum3));</span><br><span class="line">                min = Math.min(sum1, Math.min(sum2, sum3));</span><br><span class="line">                ans = Math.min(ans, max - min);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标记dfn序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ++dfnCnt;</span><br><span class="line">        dfn[u] = i;</span><br><span class="line">        xor[i] = nums[u];</span><br><span class="line">        size[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer v : graph.get(u)) &#123;</span><br><span class="line">            <span class="comment">//未处理过</span></span><br><span class="line">            <span class="keyword">if</span> (dfn[v] == <span class="number">0</span>) &#123;</span><br><span class="line">                f(v, nums);</span><br><span class="line">                <span class="comment">//有连接的边才会异或，所以不用管dfn序前后，但没链接边的情况</span></span><br><span class="line">                xor[i] ^= xor[dfn[v]];</span><br><span class="line">                size[i] += size[dfn[v]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 树形dp2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形dp2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HeightRemovalQueries</title>
      <link href="/2025/02/13/HeightRemovalQueries/"/>
      <url>/2025/02/13/HeightRemovalQueries/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.树形dp2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> study.common.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/2/13 17:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除子树后的二叉树高度</span></span><br><span class="line"><span class="comment">// 给你一棵 二叉树 的根节点 root ，树中有 n 个节点</span></span><br><span class="line"><span class="comment">// 每个节点都可以被分配一个从 1 到 n 且互不相同的值</span></span><br><span class="line"><span class="comment">// 另给你一个长度为 m 的数组 queries</span></span><br><span class="line"><span class="comment">// 你必须在树上执行 m 个 独立 的查询，其中第 i 个查询你需要执行以下操作：</span></span><br><span class="line"><span class="comment">// 从树中 移除 以 queries[i] 的值作为根节点的子树</span></span><br><span class="line"><span class="comment">// 题目所用测试用例保证 queries[i] 不等于根节点的值</span></span><br><span class="line"><span class="comment">// 返回一个长度为 m 的数组 answer</span></span><br><span class="line"><span class="comment">// 其中 answer[i] 是执行第 i 个查询后树的高度</span></span><br><span class="line"><span class="comment">// 注意：</span></span><br><span class="line"><span class="comment">// 查询之间是独立的，所以在每个查询执行后，树会回到其初始状态</span></span><br><span class="line"><span class="comment">// 树的高度是从根到树中某个节点的 最长简单路径中的边数</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/height-of-binary-tree-after-subtree-removal-queries/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeightRemovalQueries</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAIM</span> <span class="operator">=</span> <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录每个节点对应的dfn序号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] dfn = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line">    <span class="comment">//记录每个节点所拥有的节点数(dfn序做下标）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] size = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line">    <span class="comment">//记录每个节点到头节点的高度(dfn序做下标）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] deep = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line">    <span class="comment">//dfn序号</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> dfnCnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//高度预处理数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] maxl = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] maxr = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//正解：dfn序</span></span><br><span class="line">    <span class="comment">//dfn序：给每个节点，按dfn顺序标序号，然后父子节点可通过序号判断（记录每个节点的size）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] treeQueries(TreeNode root, <span class="type">int</span>[] queries)&#123;</span><br><span class="line">        dfnCnt = <span class="number">0</span>;</span><br><span class="line">        f(root, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//节点高度预处理数组，按dfn序从左到右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= dfnCnt; i++) &#123;</span><br><span class="line">            maxl[i] = Math.max(maxl[i - <span class="number">1</span>], deep[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        maxr[dfnCnt + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//高度预处理数组，按dfn序从右到左</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> dfnCnt; i &gt;= <span class="number">1</span>; i--) &#123;</span><br><span class="line">            maxr[i] = Math.max(maxr[i + <span class="number">1</span>], deep[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> queries.length;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        <span class="comment">//针对queries[i] 查 0... i -1 到 i-1...dfnCnt,取最大</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, dex; i &lt; queries.length; i++) &#123;</span><br><span class="line">            dex = dfn[queries[i]];</span><br><span class="line">            ans[i] = Math.max(maxl[dex - <span class="number">1</span>], maxr[dex + size[dex]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//标记dfn序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> ++dfnCnt;</span><br><span class="line">        dfn[root.val] = index;</span><br><span class="line">        size[index] = <span class="number">1</span>;</span><br><span class="line">        deep[index] = k;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            f(root.left, k + <span class="number">1</span>);</span><br><span class="line">            size[index] += size[dfn[root.left.val]];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            f(root.right, k + <span class="number">1</span>);</span><br><span class="line">            size[index] += size[dfn[root.right.val]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误解法：  （正解是用dfn序去做）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] curh = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] lefth = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] righth = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line">    <span class="comment">//i节点的父节点是</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] parent = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line">    <span class="comment">//节点i的所有子节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Integer, ArrayList&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误解法：  （正解是用dfn序去做）</span></span><br><span class="line">    <span class="comment">//思路：</span></span><br><span class="line">    <span class="comment">// 1.求以每个节点为头节点情况下，该节点的高度，左节点的高度，右节点的高度。 用数组记录结果吧</span></span><br><span class="line">    <span class="comment">// 2. 怎么快速查找节点i的父节点？ 怎么快速得到节点i的所有子节点？ 每次都遍历？</span></span><br><span class="line">    <span class="comment">// 2.1 用数组记录节点i的父节点，用map记录节点i的所有子节点</span></span><br><span class="line">    <span class="comment">//3.结果的产生: 每次从q中拿出节点值，并获取该父节点， 以及父节点的所有左右节点，对比拿另一个节点值的高度。 最大高度减去父节点高度 + 另一个节点的高度  res = maxh - fathh + anthorh</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] treeQueries0(TreeNode root, <span class="type">int</span>[] queries) &#123;</span><br><span class="line">        graph.clear();</span><br><span class="line">        <span class="comment">//构建父子节点</span></span><br><span class="line">        <span class="comment">//求每个节点的高度</span></span><br><span class="line">        <span class="comment">//最大高度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxh</span> <span class="operator">=</span> f(root);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> queries.length;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> queries[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> parent[cur];</span><br><span class="line">            ArrayList&lt;Integer&gt; sons = graph.get(p);</span><br><span class="line">            <span class="comment">//另一个节点的高度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">oh</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (Integer son : sons) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!son.equals(cur))&#123;</span><br><span class="line">                    oh = son;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//有个盲点啊，你怎么知道你这个节点会不会影响整个树最大高度？（于是涉及了dfn序号）</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> maxh - curh[p] + oh;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (graph.get(root.val) == <span class="literal">null</span>)&#123;</span><br><span class="line">            graph.put(root.val, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span>  <span class="operator">=</span> f(root.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> f(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">        curh[root.val] = res - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//构建父亲关系</span></span><br><span class="line">            parent[root.left.val] = root.val;</span><br><span class="line">            <span class="comment">//构建子关系</span></span><br><span class="line">            graph.get(root.val).add(root.left.val);</span><br><span class="line">            lefth[root.left.val] = left - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.right != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//构建父亲关系</span></span><br><span class="line">            parent[root.right.val] = root.val;</span><br><span class="line">            <span class="comment">//构建子关系</span></span><br><span class="line">            graph.get(root.val).add(root.right.val);</span><br><span class="line">            righth[root.right.val] = right - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//暴力遍历，会超时</span></span><br><span class="line">    <span class="comment">//直接多次遍历，时间复杂度为O(m * n),超时</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] treeQueries1(TreeNode root, <span class="type">int</span>[] queries)&#123;</span><br><span class="line">        graph.clear();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> queries.length;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> queries[i];</span><br><span class="line">            result[i] = f1(root, cur) - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">(TreeNode root, <span class="type">int</span> cur)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span> || root.val == cur)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span>  <span class="operator">=</span> f1(root.left, cur);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> f1(root.right, cur);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 树形dp2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形dp2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LongestPath</title>
      <link href="/2025/02/12/LongestPath/"/>
      <url>/2025/02/12/LongestPath/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.树形dp2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/2/12 15:18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 相邻字符不同的最长路径</span></span><br><span class="line"><span class="comment">// 给你一棵 树（即一个连通、无向、无环图），根节点是节点 0</span></span><br><span class="line"><span class="comment">// 这棵树由编号从 0 到 n - 1 的 n 个节点组成</span></span><br><span class="line"><span class="comment">// 用下标从 0 开始、长度为 n 的数组 parent 来表示这棵树</span></span><br><span class="line"><span class="comment">// 其中 parent[i] 是节点 i 的父节点</span></span><br><span class="line"><span class="comment">// 由于节点 0 是根节点，所以 parent[0] == -1</span></span><br><span class="line"><span class="comment">// 另给你一个字符串 s ，长度也是 n ，其中 s[i] 表示分配给节点 i 的字符</span></span><br><span class="line"><span class="comment">// 请你找出路径上任意一对相邻节点都没有分配到相同字符的 最长路径</span></span><br><span class="line"><span class="comment">// 并返回该路径的长度</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/longest-path-with-different-adjacent-characters/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongestPath</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只需要判断父子节点是否相同，即能判断路径是否能加上当前父节点</span></span><br><span class="line">    <span class="comment">//所以当前节点的最长路劲为</span></span><br><span class="line">    <span class="comment">//1. 包含当前节点下的最长路径：if left != cur 左子包含节点的最长单侧路径 +  if right != cur 右子包含节点的最长单侧路径 + 1</span></span><br><span class="line">    <span class="comment">//1.1 包含当前节点下，子节点不相同 且 单侧最大路径 max + 1</span></span><br><span class="line">    <span class="comment">//2.不包含当前节点下的最长路径： Math.max(左子最长路径，右子最长路径）</span></span><br><span class="line">    <span class="comment">//结果为上面取最大</span></span><br><span class="line">    <span class="comment">//所以需要的信息有，包含当前节点下的最长路径，以当前节点为头节点下的最长路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPath</span><span class="params">(<span class="type">int</span>[] parent, String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> parent.length;</span><br><span class="line">        <span class="comment">//构建图</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//单向图，父 -》 子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            graph.get(parent[i]).add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//包含当前节点下的单侧最长路径</span></span><br><span class="line">        <span class="type">int</span>[] curSums = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">//以当前节点为头节点下的最长路径</span></span><br><span class="line">        <span class="type">int</span>[] rootSums = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        f(graph, s.toCharArray(), curSums, rootSums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> rootSums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//怎么去对比各子节点拿到最优值呢</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph, <span class="type">char</span>[] arr,<span class="type">int</span>[] curSums, <span class="type">int</span>[] rootSums, <span class="type">int</span> cur)</span>&#123;</span><br><span class="line">        <span class="comment">//各子节点为头节点情况下的最大路径</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">firstMax</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">secondMax</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer v : graph.get(cur)) &#123;</span><br><span class="line">            f(graph, arr, curSums,rootSums, v);</span><br><span class="line">            <span class="comment">//以子节点为头，最大的路径</span></span><br><span class="line">            max = Math.max(rootSums[v], max);</span><br><span class="line">            <span class="comment">//包含子节点下，子节点的单侧最大路径</span></span><br><span class="line">            <span class="keyword">if</span> (arr[v] != arr[cur])&#123;</span><br><span class="line">                <span class="keyword">if</span> (curSums[v] &gt;= firstMax)&#123;</span><br><span class="line">                    secondMax = firstMax;</span><br><span class="line">                    firstMax = curSums[v];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    secondMax = Math.max(secondMax, curSums[v]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//包含子节点下的单侧最大路径</span></span><br><span class="line">        curSums[cur] = firstMax + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//1.包含子节点下，左单侧最大路径 + 右单侧最大路径 + 当前节点1</span></span><br><span class="line">        <span class="comment">//2.各子节点中的最大路径</span></span><br><span class="line">        <span class="comment">//两种情况中的最大值</span></span><br><span class="line">        rootSums[cur] = Math.max(max, firstMax + secondMax + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;1&quot;</span>.equals(<span class="literal">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 树形dp2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形dp2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinimumFuelCost</title>
      <link href="/2025/01/22/MinimumFuelCost/"/>
      <url>/2025/01/22/MinimumFuelCost/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.树形dp2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/1/22 16:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 到达首都的最少油耗</span></span><br><span class="line"><span class="comment">// 给你一棵 n 个节点的树（一个无向、连通、无环图）</span></span><br><span class="line"><span class="comment">// 每个节点表示一个城市，编号从 0 到 n - 1 ，且恰好有 n - 1 条路</span></span><br><span class="line"><span class="comment">// 0 是首都。给你一个二维整数数组 roads</span></span><br><span class="line"><span class="comment">// 其中 roads[i] = [ai, bi] ，表示城市 ai 和 bi 之间有一条 双向路</span></span><br><span class="line"><span class="comment">// 每个城市里有一个代表，他们都要去首都参加一个会议</span></span><br><span class="line"><span class="comment">// 每座城市里有一辆车。给你一个整数 seats 表示每辆车里面座位的数目</span></span><br><span class="line"><span class="comment">// 城市里的代表可以选择乘坐所在城市的车，或者乘坐其他城市的车</span></span><br><span class="line"><span class="comment">// 相邻城市之间一辆车的油耗是一升汽油</span></span><br><span class="line"><span class="comment">// 请你返回到达首都最少需要多少升汽油</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/minimum-fuel-cost-to-report-to-the-capital/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinimumFuelCost</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没做完的错误做法！！！</span></span><br><span class="line">    <span class="comment">//拓扑排序的思路，但写得有点混乱和复杂，然后没写下去了（拓扑排序用于有向图）</span></span><br><span class="line">    <span class="comment">//看了6分钟题目才看懂。。。所以做题时不要盯着题目描述，直接看案例</span></span><br><span class="line">    <span class="comment">//想了下拓扑算法，从入度为1的开始遍历所有连接节点，但没想好seats怎么解决</span></span><br><span class="line">    <span class="comment">//遇到没visit过的，只要seats没满人，就标记visited，seat+1，否则，不标记visited</span></span><br><span class="line"><span class="comment">//    public long minimumFuelCost1(int[][] roads, int seats) &#123;</span></span><br><span class="line"><span class="comment">//        int n = roads.length;</span></span><br><span class="line"><span class="comment">//        boolean[] visited = new boolean[n];</span></span><br><span class="line"><span class="comment">//        //记录每个节点的连接点</span></span><br><span class="line"><span class="comment">//        HashMap&lt;Integer, HashSet&lt;Integer&gt;&gt; map = new HashMap&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        //记录每个节点的入度数量, 节点号，入度数量。 按入度数量排序</span></span><br><span class="line"><span class="comment">//        int[] indo = new int[n];</span></span><br><span class="line"><span class="comment">//        PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;((a, b) -&gt; a[1] - b[1]);</span></span><br><span class="line"><span class="comment">//        for (int[] road : roads) &#123;</span></span><br><span class="line"><span class="comment">//            //放入接地的连接点</span></span><br><span class="line"><span class="comment">//            HashSet&lt;Integer&gt; set = map.computeIfAbsent(road[0], k -&gt; new HashSet&lt;&gt;());</span></span><br><span class="line"><span class="comment">//            set.add(road[1]);</span></span><br><span class="line"><span class="comment">//            //入度增加</span></span><br><span class="line"><span class="comment">//            indo[road[1]]++;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        //把所有入度为1的进堆</span></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; indo.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//            if (indo[i] == 1) &#123;</span></span><br><span class="line"><span class="comment">//                queue.add(new int[]&#123;i, indo[i]&#125;);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        int ans = 0;</span></span><br><span class="line"><span class="comment">//        while (!queue.isEmpty()) &#123;</span></span><br><span class="line"><span class="comment">//            int[] cur = queue.poll();</span></span><br><span class="line"><span class="comment">//            //编号</span></span><br><span class="line"><span class="comment">//            int num = cur[0];</span></span><br><span class="line"><span class="comment">//            //入度数量</span></span><br><span class="line"><span class="comment">//            int cnt = cur[1];</span></span><br><span class="line"><span class="comment">//            int hasSeat = 1;</span></span><br><span class="line"><span class="comment">//            if (num == 0 &amp;&amp; cnt == 0) &#123;</span></span><br><span class="line"><span class="comment">//                continue;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            if (visited[num]) &#123;</span></span><br><span class="line"><span class="comment">//                continue;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            indo[num]--;</span></span><br><span class="line"><span class="comment">//            visited[num] = true;</span></span><br><span class="line"><span class="comment">//            for (Integer outdo : map.get(num)) &#123;</span></span><br><span class="line"><span class="comment">//                //如果没访问过当前节点，且还有座位。则带上当前节点</span></span><br><span class="line"><span class="comment">//                if (!visited[outdo] &amp;&amp; hasSeat &lt; seats) &#123;</span></span><br><span class="line"><span class="comment">//                    visited[outdo] = true;</span></span><br><span class="line"><span class="comment">//                    //座位+1</span></span><br><span class="line"><span class="comment">//                    hasSeat++;</span></span><br><span class="line"><span class="comment">//                    //汽油+1</span></span><br><span class="line"><span class="comment">//                    ans++;</span></span><br><span class="line"><span class="comment">//                &#125; else &#123;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                //对应节点入度数量减1</span></span><br><span class="line"><span class="comment">//                indo[outdo]--;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        return ans;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//leetcode题解大神思路：0为头节点，计算每一条边所路过的车辆数（因为每条边只花1个油，所以车辆数等于油数） -》 【节点数 / 座位数】↑ = 车辆数，把所有边的车辆数加起来就是答案</span></span><br><span class="line">    <span class="comment">//左神思路：是以X为头节点，计算x的子节点中所有节点到达x所需车辆数（因为每条边只花1个油，所以车辆数等于油数） + 子节点cost -》 【节点数 / 座位数】↑ + 子cost</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">minimumFuelCost</span><span class="params">(<span class="type">int</span>[][] roads, <span class="type">int</span> seats)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> roads.length + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//构建双向图</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] road : roads) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> road[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> road[<span class="number">1</span>];</span><br><span class="line">            graph.get(u).add(v);</span><br><span class="line">            graph.get(v).add(u);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每个节点花费的油</span></span><br><span class="line">        <span class="type">long</span>[] cost = <span class="keyword">new</span> <span class="title class_">long</span>[n];</span><br><span class="line">        <span class="comment">//路过每个节点的所有子节点数</span></span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从0节点开始递归</span></span><br><span class="line">        bst(graph, seats, <span class="number">0</span>, -<span class="number">1</span>, cost, count);</span><br><span class="line">        <span class="keyword">return</span> cost[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> map</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> seats</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cur   当前递归节点</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> f     父节点， 避免向父节点递归</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cost</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> count</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bst</span><span class="params">(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph, <span class="type">int</span> seats, <span class="type">int</span> cur, <span class="type">int</span> f, <span class="type">long</span>[] cost, <span class="type">int</span>[] count)</span> &#123;</span><br><span class="line">        <span class="comment">//数量至少为1</span></span><br><span class="line">        count[cur] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer v : graph.get(cur)) &#123;</span><br><span class="line">            <span class="keyword">if</span> (v != f) &#123;</span><br><span class="line">                <span class="comment">//递归子节点</span></span><br><span class="line">                bst(graph, seats, v, cur, cost, count);</span><br><span class="line">                <span class="comment">//当前节点数量 = 加上子节点数量</span></span><br><span class="line">                count[cur] += count[v];</span><br><span class="line">                <span class="comment">//子节点来到当前节点所需花费为 【子节点数 / 座位数】↑ + 子cost</span></span><br><span class="line">                cost[cur] += cost[v] + ((count[v] + seats - <span class="number">1</span>) / seats);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 树形dp2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形dp2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PathSumIII</title>
      <link href="/2025/01/16/PathSumIII/"/>
      <url>/2025/01/16/PathSumIII/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.树形dp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> study.common.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/1/16 15:01</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 路径总和 III</span></span><br><span class="line"><span class="comment">// 给定一个二叉树的根节点 root ，和一个整数 targetSum</span></span><br><span class="line"><span class="comment">// 求该二叉树里节点值之和等于 targetSum 的 路径 的数目</span></span><br><span class="line"><span class="comment">// 路径 不需要从根节点开始，也不需要在叶子节点结束</span></span><br><span class="line"><span class="comment">// 但是路径方向必须是向下的（只能从父节点到子节点）</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/path-sum-iii/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PathSumIII</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误的思路！！！</span></span><br><span class="line">    <span class="comment">//节点能达成 targetsum的方法数， 节点的总和sum</span></span><br><span class="line">    <span class="comment">//思路就是 取或不取当前节点值，targetSum - cur.val</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum1</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> f(root, targetSum).road;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Info <span class="title function_">f</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不取当前节点</span></span><br><span class="line">        <span class="type">Info</span> <span class="variable">left1</span> <span class="operator">=</span> f(root.left, targetSum);</span><br><span class="line">        <span class="type">Info</span> <span class="variable">right1</span> <span class="operator">=</span> f(root.right, targetSum);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取当前节点</span></span><br><span class="line">        <span class="type">Info</span> <span class="variable">left2</span> <span class="operator">=</span> f(root.left, targetSum - root.val);</span><br><span class="line">        <span class="type">Info</span> <span class="variable">right2</span> <span class="operator">=</span> f(root.right, targetSum - root.val);</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> left1.sum + right1.sum + root.val;</span><br><span class="line">        <span class="type">int</span> <span class="variable">road</span> <span class="operator">=</span> left1.road + left2.road + right2.road + right1.road + (sum == targetSum ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(road, sum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> road;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">long</span> sum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Info</span><span class="params">(<span class="type">int</span> road, <span class="type">long</span> sum)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.road = road;</span><br><span class="line">            <span class="built_in">this</span>.sum = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//子节点向父节点要信息（到当前节点已累计和sum -》 构建前缀和map, 转化为两数之和(A+B)问题，注意回退时要恢复现场）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> ans;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        HashMap&lt;Long, Integer&gt; presumMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        presumMap.put(<span class="number">0L</span>, <span class="number">1</span>);</span><br><span class="line">        f(root, target, <span class="number">0</span>, presumMap);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(TreeNode root, <span class="type">int</span> target, <span class="type">long</span> sum, HashMap&lt;Long, Integer&gt; presumMap)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sum += root.val;</span><br><span class="line">        <span class="comment">//看前面sum - target的和出现过几次</span></span><br><span class="line">        ans += presumMap.getOrDefault(sum - target, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//把当前次数加上</span></span><br><span class="line">        presumMap.put(sum, presumMap.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        f(root.left, target, sum, presumMap);</span><br><span class="line">        f(root.right, target, sum, presumMap);</span><br><span class="line">        <span class="comment">//恢复现场</span></span><br><span class="line">        presumMap.put(sum, presumMap.getOrDefault(sum, <span class="number">0</span>) - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 树形dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinCameraCover</title>
      <link href="/2025/01/10/MinCameraCover/"/>
      <url>/2025/01/10/MinCameraCover/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.树形dp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> study.common.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/1/10 17:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinCameraCover</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原有思路，一次提交就过了嘻嘻嘻</span></span><br><span class="line">    <span class="comment">//以x为头节点，监控所有节点所需最小摄像头数量sum</span></span><br><span class="line">    <span class="comment">//节点是否被监控，子节点是否放置摄像头</span></span><br><span class="line">    <span class="comment">//1、若其中某个子节点未被监控，则当前节点必须放置摄像头</span></span><br><span class="line">    <span class="comment">//2、若子节点已被监控： 如何使摄像头数量能否减少?以下是分析</span></span><br><span class="line">    <span class="comment">//2.若子节点都已被监控，则当前节点不放摄像头（给到当前节点的父节点去放， 最后判断根节点是否被监控 再加上即可）</span></span><br><span class="line">    <span class="comment">//所以需要的信息有所需最小摄像头数量sum, 节点是否被监控obz， 节点是否放置了摄像头carm</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCameraCover</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">Info</span> <span class="variable">cur</span> <span class="operator">=</span> f(root);</span><br><span class="line">        <span class="comment">//判断当前节点是否被监控</span></span><br><span class="line">        <span class="keyword">return</span> cur.sum + (cur.obz ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Info <span class="title function_">f</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(<span class="number">0</span>, <span class="literal">true</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Info</span> <span class="variable">left</span> <span class="operator">=</span> f(root.left);</span><br><span class="line">        <span class="type">Info</span> <span class="variable">right</span> <span class="operator">=</span> f(root.right);</span><br><span class="line">        <span class="comment">//其中某个节点未被监控，当前节点必须放摄像头</span></span><br><span class="line">        <span class="keyword">if</span> (!left.obz || !right.obz)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(left.sum + right.sum + <span class="number">1</span>, <span class="literal">true</span>, <span class="literal">true</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//子节点都已被监控了，判断当前节点是否被监控</span></span><br><span class="line">            <span class="comment">//即使当前节点未被监控，也不放摄像头，给到上层节点去放置摄像头</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">obz</span> <span class="operator">=</span> left.carm || right.carm;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(left.sum + right.sum, obz, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">        <span class="comment">//所需最小摄像头数量sum</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> sum;</span><br><span class="line">        <span class="comment">//节点是否被监控</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> obz;</span><br><span class="line">        <span class="comment">//节点是否放置了摄像头</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> carm;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Info</span><span class="params">(<span class="type">int</span> sum, <span class="type">boolean</span> obz, <span class="type">boolean</span> carm)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.sum = sum;</span><br><span class="line">            <span class="built_in">this</span>.obz = obz;</span><br><span class="line">            <span class="built_in">this</span>.carm = carm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是左神的做法代码，用状态表示信息，大体思路是一样的，更简化</span></span><br><span class="line">    <span class="comment">// 提交如下的方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCameraCover1</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (f1(root) == <span class="number">0</span>) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历过程中一旦需要放置相机，ans++</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> ans;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 递归含义</span></span><br><span class="line">    <span class="comment">// 假设x上方一定有父亲的情况下，这个假设很重要</span></span><br><span class="line">    <span class="comment">// x为头的整棵树，最终想都覆盖，</span></span><br><span class="line">    <span class="comment">// 并且想使用最少的摄像头，x应该是什么样的状态</span></span><br><span class="line">    <span class="comment">// 返回值含义</span></span><br><span class="line">    <span class="comment">// 0: x是无覆盖的状态，x下方的节点都已经被覆盖</span></span><br><span class="line">    <span class="comment">// 1: x是覆盖状态，x上没摄像头，x下方的节点都已经被覆盖</span></span><br><span class="line">    <span class="comment">// 2: x是覆盖状态，x上有摄像头，x下方的节点都已经被覆盖</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">(TreeNode x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> f1(x.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> f1(x.right);</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">0</span> || right == <span class="number">0</span>) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">1</span> &amp;&amp; right == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 树形dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RobIII</title>
      <link href="/2025/01/10/RobIII/"/>
      <url>/2025/01/10/RobIII/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.树形dp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> study.common.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/1/10 14:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 没有上司的舞会</span></span><br><span class="line"><span class="comment">// 某大学有n个职员，编号为1...n</span></span><br><span class="line"><span class="comment">// 他们之间有从属关系，也就是说他们的关系就像一棵以校长为根的树</span></span><br><span class="line"><span class="comment">// 父结点就是子结点的直接上司</span></span><br><span class="line"><span class="comment">// 现在有个周年庆宴会，宴会每邀请来一个职员都会增加一定的快乐指数</span></span><br><span class="line"><span class="comment">// 但是如果某个职员的直接上司来参加舞会了</span></span><br><span class="line"><span class="comment">// 那么这个职员就无论如何也不肯来参加舞会了</span></span><br><span class="line"><span class="comment">// 所以请你编程计算邀请哪些职员可以使快乐指数最大</span></span><br><span class="line"><span class="comment">// 返回最大的快乐指数。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P1352</span></span><br><span class="line"><span class="comment">// 本题和讲解037的题目7类似</span></span><br><span class="line"><span class="comment">// 链式链接 : https://leetcode.cn/problems/house-robber-iii/</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下的code，提交时请把类名改成&quot;Main&quot;，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RobIII</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前房屋能不能偷？看子节点能不能偷</span></span><br><span class="line">    <span class="comment">//当前节点偷与不偷中 取最大 -》 左子节点 偷和不偷 所得到的最高金额， 右子节点偷和不偷得到的最高金额</span></span><br><span class="line">    <span class="comment">//所以需要的信息有： 偷当前节点时能获得的最大金额，不偷当前节点时能获得的最大金额</span></span><br><span class="line">    <span class="comment">//1、偷当前节点：cur.val + left.不偷 + right.不偷</span></span><br><span class="line">    <span class="comment">//2、不偷当前节点： Math.max(left.偷, left.不偷）   + Math.max(right.偷, right.不偷)</span></span><br><span class="line">    <span class="comment">//结果取最大</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">Info</span> <span class="variable">info</span> <span class="operator">=</span> f(root);</span><br><span class="line">        <span class="keyword">return</span> Math.max(info.noRob, info.yesRob);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Info <span class="title function_">f</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Info</span> <span class="variable">left</span> <span class="operator">=</span> f(root.left);</span><br><span class="line">        <span class="type">Info</span> <span class="variable">right</span> <span class="operator">=</span> f(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">noRob</span> <span class="operator">=</span> Math.max(left.yesRob, left.noRob) + Math.max(right.yesRob, right.noRob);</span><br><span class="line">        <span class="type">int</span> <span class="variable">yesRob</span> <span class="operator">=</span> left.noRob + right.noRob + root.val;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(noRob, yesRob);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">        <span class="comment">//不偷当前节点能获得的最大金额</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> noRob;</span><br><span class="line">        <span class="comment">//偷当前节点能获得的最大金额</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> yesRob;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Info</span><span class="params">(<span class="type">int</span> noRob, <span class="type">int</span> yesRob)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.noRob = noRob;</span><br><span class="line">            <span class="built_in">this</span>.yesRob = yesRob;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 树形dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DistributeCoins</title>
      <link href="/2025/01/10/DistributeCoins/"/>
      <url>/2025/01/10/DistributeCoins/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.树形dp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> study.common.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/1/10 10:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistributeCoins</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//节点所需最少移动次数m</span></span><br><span class="line">    <span class="comment">//该节点多余/缺少金币数cnt = |金币总数 - 节点数|</span></span><br><span class="line">    <span class="comment">//当前节点所需移动次数等于 左m1 + 右m2 + 左cnt1移动到头节点 + 右cnt2移动到头节点（只需头节点把多余金币分给左右子节点）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//所以需要的信息有，移动次数m，总金币数c, 总节点数sum</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">distributeCoins</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> f(root).m;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Info <span class="title function_">f</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Info</span> <span class="variable">left</span> <span class="operator">=</span> f(root.left);</span><br><span class="line">        <span class="type">Info</span> <span class="variable">right</span> <span class="operator">=</span> f(root.right);</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> left.c + right.c + root.val;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> left.sum + right.sum + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> left.m + right.m + Math.abs(left.c - left.sum) + Math.abs(right.c - right.sum);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(m, c, sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">        <span class="comment">//移动次数</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> m;</span><br><span class="line">        <span class="comment">//总金币数</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> c;</span><br><span class="line">        <span class="comment">//总节点数</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> sum;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Info</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> c, <span class="type">int</span> sum)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.m = m;</span><br><span class="line">            <span class="built_in">this</span>.c = c;</span><br><span class="line">            <span class="built_in">this</span>.sum = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//总结： 先对当前节点分析要怎么得到当前节点的结果（子问题解），然后再根据分析看需要什么条件去满足当前节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 树形dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DiameterOfBinaryTree</title>
      <link href="/2025/01/03/DiameterOfBinaryTree/"/>
      <url>/2025/01/03/DiameterOfBinaryTree/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.树形dp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/1/3 17:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉树的直径</span></span><br><span class="line"><span class="comment">// 给你一棵二叉树的根节点，返回该树的直径</span></span><br><span class="line"><span class="comment">// 二叉树的 直径 是指树中任意两个节点之间最长路径的长度</span></span><br><span class="line"><span class="comment">// 这条路径可能经过也可能不经过根节点 root</span></span><br><span class="line"><span class="comment">// 两节点之间路径的 长度 由它们之间边数表示</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/diameter-of-binary-tree/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiameterOfBinaryTree</span> &#123;</span><br><span class="line">    <span class="comment">//当前树的最大直径：</span></span><br><span class="line">    <span class="comment">//1、经过当前节点： 左子树最大深度 + 右子树最大深度 + 1</span></span><br><span class="line">    <span class="comment">//2、不经过当前节点： Math.max(左子树最大直径, 右子树最大直径）</span></span><br><span class="line">    <span class="comment">//上面情况取最大</span></span><br><span class="line">    <span class="comment">//所以需要的信息有 子树深度，子树最大直径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="comment">//由边决定，所以这里减1</span></span><br><span class="line">        <span class="keyword">return</span> f(root).maxDia - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//得到的是节点数</span></span><br><span class="line">    <span class="keyword">public</span> Info <span class="title function_">f</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Info</span> <span class="variable">left</span> <span class="operator">=</span> f(root.left);</span><br><span class="line">        <span class="type">Info</span> <span class="variable">right</span> <span class="operator">=</span> f(root.right);</span><br><span class="line">        <span class="comment">//当前树最大深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> Math.max(left.depth, right.depth) + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//当前树最大直径</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxDia</span> <span class="operator">=</span> Math.max(left.depth + right.depth + <span class="number">1</span>, Math.max(left.maxDia, right.maxDia));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(depth, maxDia);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">        <span class="comment">//最大深度</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> depth;</span><br><span class="line">        <span class="comment">//最大直径</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> maxDia;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Info</span><span class="params">(<span class="type">int</span> depth, <span class="type">int</span> maxDia)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.depth = depth;</span><br><span class="line">            <span class="built_in">this</span>.maxDia = maxDia;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不要提交这个类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> TreeNode left;</span><br><span class="line">        <span class="keyword">public</span> TreeNode right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 树形dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MaxSumBST</title>
      <link href="/2025/01/03/MaxSumBST/"/>
      <url>/2025/01/03/MaxSumBST/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.树形dp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2025/1/3 15:41</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二叉搜索子树的最大键值和</span></span><br><span class="line"><span class="comment">// 给你一棵以 root 为根的二叉树</span></span><br><span class="line"><span class="comment">// 请你返回 任意 二叉搜索子树的最大键值和</span></span><br><span class="line"><span class="comment">// 二叉搜索树的定义如下：</span></span><br><span class="line"><span class="comment">// 任意节点的左子树中的键值都 小于 此节点的键值</span></span><br><span class="line"><span class="comment">// 任意节点的右子树中的键值都 大于 此节点的键值</span></span><br><span class="line"><span class="comment">// 任意节点的左子树和右子树都是二叉搜索树</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/maximum-sum-bst-in-binary-tree/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxSumBST</span> &#123;</span><br><span class="line">    <span class="comment">//就是说统计二叉搜索树的所有和值，取最大搜索树</span></span><br><span class="line">    <span class="comment">//思路：</span></span><br><span class="line">    <span class="comment">//1、判断二叉搜索树 -&gt; 子树是二叉搜索树，且  left.max &lt; cur.val &amp;&amp; right.min &gt; cur.val</span></span><br><span class="line">    <span class="comment">//2、该树的所有键值和 子树的最大键值和 取最大 -&gt; 即要子树的最大键值和 maxBst, 和当前树的键值和做对比</span></span><br><span class="line">    <span class="comment">//所以需要信息： 是否二叉搜索树isBst, 子树最大最小值 min,max, 子树键值和sum,  子树最大键值和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSumBST</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> f(root).maxSUm;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Info <span class="title function_">f</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(<span class="literal">true</span>, Integer.MIN_VALUE, Integer.MAX_VALUE, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接拿子树信息</span></span><br><span class="line">        <span class="type">Info</span> <span class="variable">left</span> <span class="operator">=</span> f(root.left);</span><br><span class="line">        <span class="type">Info</span> <span class="variable">right</span> <span class="operator">=</span> f(root.right);</span><br><span class="line">        <span class="comment">//和当前树比较拿最值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(root.val, Math.min(left.min, right.min));</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.max(root.val, Math.max(left.max, right.max));</span><br><span class="line">        <span class="comment">//当前树的键值和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> left.sum + right.sum + root.val;</span><br><span class="line">        <span class="comment">//子树的最大键值和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxSum</span> <span class="operator">=</span> Math.max(left.maxSUm, right.maxSUm);</span><br><span class="line">        <span class="comment">//判断是否搜索树</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isBst</span> <span class="operator">=</span> left.isBst &amp;&amp; right.isBst &amp;&amp; root.val &gt; left.max &amp;&amp; root.val &lt; right.min;</span><br><span class="line">        <span class="keyword">if</span> (isBst)&#123;</span><br><span class="line">            <span class="comment">//对比当前树的键值和 与 子树最大键值和</span></span><br><span class="line">            maxSum = Math.max(sum, maxSum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(isBst, max, min, sum, maxSum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不要提交这个类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> TreeNode left;</span><br><span class="line">        <span class="keyword">public</span> TreeNode right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> isBst;<span class="comment">//是否搜索树</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> max;<span class="comment">//树最大值</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> min;<span class="comment">//最小值</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> sum;<span class="comment">//键值和</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> maxSUm;<span class="comment">//键值和</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Info</span><span class="params">(<span class="type">boolean</span> isBst, <span class="type">int</span> max, <span class="type">int</span> min, <span class="type">int</span> sum, <span class="type">int</span> maxSUm)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.isBst = isBst;</span><br><span class="line">            <span class="built_in">this</span>.max = max;</span><br><span class="line">            <span class="built_in">this</span>.min = min;</span><br><span class="line">            <span class="built_in">this</span>.sum = sum;</span><br><span class="line">            <span class="built_in">this</span>.maxSUm = maxSUm;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 树形dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LargestBstSubtree</title>
      <link href="/2024/12/30/LargestBstSubtree/"/>
      <url>/2024/12/30/LargestBstSubtree/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.树形dp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/12/30 17:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大BST子树</span></span><br><span class="line"><span class="comment">// 给定一个二叉树，找到其中最大的二叉搜索树（BST）子树，并返回该子树的大小</span></span><br><span class="line"><span class="comment">// 其中，最大指的是子树节点数最多的</span></span><br><span class="line"><span class="comment">// 二叉搜索树（BST）中的所有节点都具备以下属性：</span></span><br><span class="line"><span class="comment">// 左子树的值小于其父（根）节点的值</span></span><br><span class="line"><span class="comment">// 右子树的值大于其父（根）节点的值</span></span><br><span class="line"><span class="comment">// 注意：子树必须包含其所有后代</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/largest-bst-subtree/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LargestBstSubtree</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不要提交这个类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> TreeNode left;</span><br><span class="line">        <span class="keyword">public</span> TreeNode right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Info</span>&#123;</span><br><span class="line">        <span class="comment">//是否二叉搜索树</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">boolean</span> isBst;</span><br><span class="line">        <span class="comment">//子树节点数量</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> sonNums;</span><br><span class="line">        <span class="comment">//子树的最大值</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> maxVal;</span><br><span class="line">        <span class="comment">//子树最小值</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">long</span> minVal;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Info</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Info</span><span class="params">(<span class="type">boolean</span> isBst, <span class="type">int</span> sonNums, <span class="type">long</span> maxVal, <span class="type">long</span> minVal)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.isBst = isBst;</span><br><span class="line">            <span class="built_in">this</span>.sonNums = sonNums;</span><br><span class="line">            <span class="built_in">this</span>.maxVal = maxVal;</span><br><span class="line">            <span class="built_in">this</span>.minVal = minVal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提交如下的方法</span></span><br><span class="line">    <span class="comment">//思路: 构建一个信息集合，由子树提供信息</span></span><br><span class="line">    <span class="comment">//1. 当前树就是二叉搜索树 -&gt;  left.isBst &amp;&amp; right.isBst &amp;&amp; cur.val &gt; left.maxVal &amp;&amp;  cur.val &lt; right.minVal</span></span><br><span class="line">    <span class="comment">//2. 当前树不是二叉树 -》 左子树或右子树最多有一个是二叉树，返回二叉子树的节点数</span></span><br><span class="line">    <span class="comment">//所以，需要的信息有， 子树是否是二叉搜索树isBst, 子树的节点树sonNums， 子树的最大值max, 子树的最小值min,</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">largestBSTSubtree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> f(root).sonNums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取最大的二叉搜索树子树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Info <span class="title function_">f</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(<span class="literal">true</span>, <span class="number">0</span>, Long.MAX_VALUE, Long.MIN_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Info</span> <span class="variable">left</span> <span class="operator">=</span> f(root.left);</span><br><span class="line">        <span class="type">Info</span> <span class="variable">right</span> <span class="operator">=</span> f(root.right);</span><br><span class="line">        <span class="comment">//和当前节点对比 取最值</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">max</span> <span class="operator">=</span> Math.max(root.val, Math.max(left.maxVal, right.maxVal));</span><br><span class="line">        <span class="type">long</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(root.val, Math.min(left.minVal, right.minVal));</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isBst</span> <span class="operator">=</span> left.isBst &amp;&amp; right.isBst &amp;&amp; left.maxVal &lt; root.val &amp;&amp; right.minVal &gt; root.val;</span><br><span class="line">        <span class="type">int</span> maxNums;</span><br><span class="line">        <span class="keyword">if</span> (isBst)&#123;</span><br><span class="line">            maxNums = left.sonNums + right.sonNums + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//表示取曾经出现过的二叉搜索树的最大子树</span></span><br><span class="line">            maxNums = Math.max(left.sonNums, right.sonNums);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Info</span>(<span class="literal">false</span>, maxNums, max,min);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 树形dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树形dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DistributeRepeatingIntegers</title>
      <link href="/2024/12/24/DistributeRepeatingIntegers/"/>
      <url>/2024/12/24/DistributeRepeatingIntegers/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.状压dp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Collections;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/12/24 10:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistributeRepeatingIntegers</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误的思路！！！</span></span><br><span class="line">    <span class="comment">//反例：测试用例:[1,1,1,1,2,2,2] [3,2,2] 测试结果:false 期望结果:true</span></span><br><span class="line">    <span class="comment">//贪心思路，优先匹配大的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canDistribute</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span>[] quantity)</span> &#123;</span><br><span class="line">        Arrays.sort(quantity);</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>(Collections.reverseOrder());</span><br><span class="line">        <span class="comment">//统计词频，返回不同数字的个数</span></span><br><span class="line">        <span class="type">int</span>[] cnt = count(nums);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : cnt) &#123;</span><br><span class="line">            queue.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> quantity.length - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.isEmpty())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="comment">//如果当前最大数量都无法满足</span></span><br><span class="line">            <span class="keyword">if</span> (num &lt; quantity[index])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; quantity[index])&#123;</span><br><span class="line">                queue.add(num - quantity[index]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] count(<span class="type">int</span>[] nums)&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, l = <span class="number">0</span>, r = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            r = l;</span><br><span class="line">            <span class="keyword">while</span> (r &lt; nums.length &amp;&amp; nums[r] == nums[l])&#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            cnt[index++] = r - l;</span><br><span class="line">            l = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] result = <span class="keyword">new</span> <span class="title class_">int</span>[index];</span><br><span class="line">        System.arraycopy(cnt, <span class="number">0</span>, result, <span class="number">0</span>, index);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 状压dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 状压dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Coloring</title>
      <link href="/2024/12/16/Coloring/"/>
      <url>/2024/12/16/Coloring/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.区间dp2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/12/16 11:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 涂色 &amp; 奇怪打印机</span></span><br><span class="line"><span class="comment">// 假设你有一条长度为5的木板，初始时没有涂过任何颜色</span></span><br><span class="line"><span class="comment">// 你希望把它的5个单位长度分别涂上红、绿、蓝、绿、红</span></span><br><span class="line"><span class="comment">// 用一个长度为5的字符串表示这个目标：RGBGR</span></span><br><span class="line"><span class="comment">// 每次你可以把一段连续的木板涂成一个给定的颜色，后涂的颜色覆盖先涂的颜色</span></span><br><span class="line"><span class="comment">// 例如第一次把木板涂成RRRRR</span></span><br><span class="line"><span class="comment">// 第二次涂成RGGGR</span></span><br><span class="line"><span class="comment">// 第三次涂成RGBGR，达到目标</span></span><br><span class="line"><span class="comment">// 返回尽量少的涂色次数</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P4170</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/strange-printer/</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下的code，提交时请把类名改成&quot;Main&quot;，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Coloring</span> &#123;</span><br><span class="line">    <span class="comment">//错误的思路！！！不需要新增t字符来对比，实际上就是s内部字符对比</span></span><br><span class="line">    <span class="comment">//l..r范围 把s变成 t的样子最少要几次印刷？</span></span><br><span class="line">    <span class="comment">//纠结点在于是否要l-r对比t字符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strangePrinter0</span><span class="params">(String tar)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> tar.length();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">char</span>[] s = <span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">        <span class="type">char</span>[] t = tar.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            s[i] = t[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>  <span class="number">1</span> + f(<span class="number">0</span>, n - <span class="number">1</span>, s, t, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误的思路</span></span><br><span class="line">    <span class="comment">//枚举每个范围区间做印刷，取最小值</span></span><br><span class="line">    <span class="comment">//每一次印刷都改变s，递归后再恢复现场</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">char</span>[] s, <span class="type">char</span>[] t, <span class="type">int</span>[][] dp)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">            <span class="keyword">return</span> s[l] == t[l] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l + <span class="number">1</span> == r)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s[l] == t[l] &amp;&amp; s[r] == t[r])&#123;</span><br><span class="line">                ans = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s[l] == t[l] || s[r] == t[r])&#123;</span><br><span class="line">                ans = <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ans = <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果两端相等，直接讨论内部</span></span><br><span class="line">            <span class="keyword">if</span> (s[l] == t[l] &amp;&amp; s[r] == t[r])&#123;</span><br><span class="line">                ans = f(l + <span class="number">1</span>, r - <span class="number">1</span>, s, t, dp);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//枚举每个范围. 怎么去硬刷呢？ 乱，卡住了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt; r; i++) &#123;</span><br><span class="line">                ans = Math.min(ans, f(l, i, s, t, dp) + f(i + <span class="number">1</span>, r, s, t, dp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//正确的做法</span></span><br><span class="line">    <span class="comment">//大方向没错们就是分析可能性：</span></span><br><span class="line">    <span class="comment">//1、两端相同，这里探讨可能性时，不能直接l+1，r-1. 可以转化为l...r - 1，或l+1..r，即略过了其中一端（因为相同，所以只需要另外一头刷对即可）</span></span><br><span class="line">    <span class="comment">//2、两端不同，枚举每个划分点</span></span><br><span class="line">    <span class="comment">//定义dp[l][r] 为， l..r范围内，刷成给定的颜色至少要几次</span></span><br><span class="line">    <span class="comment">//base case: l == r,  1; l + 1 == r, s[l] == s[r] ? 1, 2</span></span><br><span class="line">    <span class="comment">//1、s[l] == s[r], dp[l][r - 1]</span></span><br><span class="line">    <span class="comment">//2、枚举每个划分点m， dp[l][r] = dp[l][m] + dp[m + 1][r]. 取最小值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strangePrinter</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            dp[i][i + <span class="number">1</span>] = s[i] == s[i + <span class="number">1</span>] ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[n - <span class="number">1</span>][n - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//依赖左边和下面，从左到右，从下到上更新</span></span><br><span class="line">        <span class="comment">//从倒数第三行开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> n - <span class="number">3</span>; l &gt;= <span class="number">0</span>; l--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> l + <span class="number">2</span>; r &lt; n; r++) &#123;<span class="comment">//从第三个开始</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">if</span> (s[l] == s[r])&#123;</span><br><span class="line">                    ans = dp[l][r - <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l; m &lt; r; m++) &#123;</span><br><span class="line">                    ans = Math.min(ans, dp[l][m] + dp[m + <span class="number">1</span>][r]);</span><br><span class="line">                &#125;</span><br><span class="line">                dp[l][r] = ans;</span><br><span class="line"></span><br><span class="line"><span class="comment">//                if (s[l] == s[r])&#123;</span></span><br><span class="line"><span class="comment">//                    dp[l][r] = dp[l][r - 1];</span></span><br><span class="line"><span class="comment">//                &#125;else &#123;</span></span><br><span class="line"><span class="comment">//                    int ans = Integer.MAX_VALUE;</span></span><br><span class="line"><span class="comment">//                    for (int m = l; m &lt; r; m++) &#123;</span></span><br><span class="line"><span class="comment">//                        ans = Math.min(ans, dp[l][m] + dp[m + 1][r]);</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                    dp[l][r] = ans;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 区间dp2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区间dp2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinimumInsertionsToMatch</title>
      <link href="/2024/12/12/MinimumInsertionsToMatch/"/>
      <url>/2024/12/12/MinimumInsertionsToMatch/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.区间dp2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/12/12 16:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 完成配对需要的最少字符数量</span></span><br><span class="line"><span class="comment">// 给定一个由&#x27;[&#x27;、&#x27;]&#x27;、&#x27;(&#x27;，&#x27;)&#x27;组成的字符串</span></span><br><span class="line"><span class="comment">// 请问最少插入多少个括号就能使这个字符串的所有括号正确配对</span></span><br><span class="line"><span class="comment">// 例如当前串是 &quot;([[])&quot;，那么插入一个&#x27;]&#x27;即可满足</span></span><br><span class="line"><span class="comment">// 输出最少需要插入多少个字符</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.nowcoder.com/practice/e391767d80d942d29e6095a935a5b96b</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下的code，提交时请把类名改成&quot;Main&quot;，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinimumInsertionsToMatch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = in.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            out.println(compute(line.toCharArray()));</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//记忆化搜索</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">(<span class="type">char</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f(<span class="number">0</span>, n - <span class="number">1</span>, arr, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以两端讨论呢  还是范围讨论呢？ 感觉l,r都可以枚举位置，然后再讨论两端可能性。。。没啥思路</span></span><br><span class="line">    <span class="comment">//第一感觉是范围讨论的，也感觉是枚举划分点，但突然又卡在了枚举划分点，没想明白逻辑</span></span><br><span class="line">    <span class="comment">//枚举每一个位置做划分点，讨论左右范围 共最少需插入的括号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//看了答案，解惑了： 可能性分为两端  和  范围， 两种可能性取最小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">char</span>[] arr, <span class="type">int</span>[][] dp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[l][r] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[l][r];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">            ans = <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (l + <span class="number">1</span> == r)&#123;<span class="comment">//剩两个字符直接比较</span></span><br><span class="line">            ans = judge(arr[l], arr[r]) ? <span class="number">0</span> : <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//可能性1</span></span><br><span class="line">            <span class="keyword">if</span> (judge(arr[l], arr[r]))&#123;<span class="comment">//消除两端</span></span><br><span class="line">                ans =  f(l + <span class="number">1</span>, r - <span class="number">1</span>, arr, dp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//可能性2</span></span><br><span class="line">            <span class="comment">//枚举每一个划分点. 这里的i主要是划分左右范围</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt; r; i++) &#123;</span><br><span class="line">                ans = Math.min(ans, f(l, i, arr, dp) + f(i + <span class="number">1</span>, r, arr, dp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[l][r] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">judge</span><span class="params">(<span class="type">char</span> a, <span class="type">char</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (a == <span class="string">&#x27;(&#x27;</span> &amp;&amp; b == <span class="string">&#x27;)&#x27;</span>) || (a == <span class="string">&#x27;[&#x27;</span> &amp;&amp; b == <span class="string">&#x27;]&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 区间dp2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区间dp2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BooleanEvaluation</title>
      <link href="/2024/12/12/BooleanEvaluation/"/>
      <url>/2024/12/12/BooleanEvaluation/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.区间dp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>  核心思路：枚举每一个字符为 最后一个运算的字符</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/12/12 10:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 布尔运算</span></span><br><span class="line"><span class="comment">// 给定一个布尔表达式和一个期望的布尔结果 result</span></span><br><span class="line"><span class="comment">// 布尔表达式由 0 (false)、1 (true)、&amp; (AND)、 | (OR) 和 ^ (XOR) 符号组成</span></span><br><span class="line"><span class="comment">// 布尔表达式一定是正确的，不需要检查有效性</span></span><br><span class="line"><span class="comment">// 但是其中没有任何括号来表示优先级</span></span><br><span class="line"><span class="comment">// 你可以随意添加括号来改变逻辑优先级</span></span><br><span class="line"><span class="comment">// 目的是让表达式能够最终得出result的结果</span></span><br><span class="line"><span class="comment">// 返回最终得出result有多少种不同的逻辑计算顺序</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/boolean-evaluation-lcci/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BooleanEvaluation</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//记忆化搜素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countEval1</span><span class="params">(String s, <span class="type">int</span> result)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n][];</span><br><span class="line">        <span class="type">int</span>[] ans = f(<span class="number">0</span>, n - <span class="number">1</span>, s.toCharArray(), dp);</span><br><span class="line">        <span class="keyword">return</span> result == <span class="number">0</span> ? ans[<span class="number">1</span>] : ans[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//枚举每个符号为最后运算的符号， 递归得出左边 true/fase的数量，根据枚举符号 作运算结果数</span></span><br><span class="line">    <span class="comment">//l, r都是边界数字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] f(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">char</span>[] arr, <span class="type">int</span>[][][] dp)&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[l][r] != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[l][r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">f</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span> (l == r)&#123;<span class="comment">//直接返回结果</span></span><br><span class="line">            <span class="keyword">if</span> (arr[l] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                f++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                t++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//枚举每个符号为最后运算</span></span><br><span class="line">            <span class="comment">//把所有结果都加起来返回</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l + <span class="number">1</span>; i &lt; r; i += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="type">int</span>[] left = f(l, i - <span class="number">1</span>, arr, dp);</span><br><span class="line">                <span class="type">int</span>[] right = f(i + <span class="number">1</span>, r, arr, dp);</span><br><span class="line">                <span class="type">int</span> <span class="variable">tl</span> <span class="operator">=</span> left[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">fl</span> <span class="operator">=</span> left[<span class="number">1</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">tr</span> <span class="operator">=</span> right[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">fr</span> <span class="operator">=</span> right[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                <span class="comment">//这里注意 别重复计算啊</span></span><br><span class="line">                <span class="keyword">if</span> (arr[i] == <span class="string">&#x27;&amp;&#x27;</span>)&#123;</span><br><span class="line">                    t += tl * tr;</span><br><span class="line">                    f += fl * tr + fl * fr + fr * tl;</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[i] == <span class="string">&#x27;|&#x27;</span>)&#123;</span><br><span class="line">                    t += tl * tr + tl * fr + tr * fl;</span><br><span class="line">                    f += fl * fr;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    t += tl * fr + tr * fl;</span><br><span class="line">                    f += tl * tr + fl * fr;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;t, f&#125;;</span><br><span class="line">        dp[l][r] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//严格位置依赖的dp</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countEval</span><span class="params">(String s, <span class="type">int</span> result)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n][];</span><br><span class="line">        <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//填充base case</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, t, f; i &lt; n; i += <span class="number">2</span>) &#123;</span><br><span class="line">            t = arr[i] == <span class="string">&#x27;1&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            f = arr[i] == <span class="string">&#x27;0&#x27;</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">            dp[i][i] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;t,f&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左到右，下到上更新. 注意l,r的初始值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> n - <span class="number">3</span>; l &gt;= <span class="number">0</span>; l -= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> l + <span class="number">2</span>; r &lt; n; r += <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">0</span>, f = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//枚举每个符号为最后运算</span></span><br><span class="line">                <span class="comment">//把所有结果都加起来返回</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l + <span class="number">1</span>; i &lt; r; i += <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="type">int</span>[] left = f(l, i - <span class="number">1</span>, arr, dp);</span><br><span class="line">                    <span class="type">int</span>[] right = f(i + <span class="number">1</span>, r, arr, dp);</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tl</span> <span class="operator">=</span> left[<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">fl</span> <span class="operator">=</span> left[<span class="number">1</span>];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">tr</span> <span class="operator">=</span> right[<span class="number">0</span>];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">fr</span> <span class="operator">=</span> right[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//这里注意 别重复计算啊</span></span><br><span class="line">                    <span class="keyword">if</span> (arr[i] == <span class="string">&#x27;&amp;&#x27;</span>)&#123;</span><br><span class="line">                        t += tl * tr;</span><br><span class="line">                        f += fl * tr + fl * fr + fr * tl;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[i] == <span class="string">&#x27;|&#x27;</span>)&#123;</span><br><span class="line">                        t += tl * tr + tl * fr + tr * fl;</span><br><span class="line">                        f += fl * fr;</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        t += tl * fr + tr * fl;</span><br><span class="line">                        f += tl * tr + fl * fr;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[l][r] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;t, f&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] ans = dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> result == <span class="number">0</span> ? ans[<span class="number">1</span>] : ans[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 区间dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区间dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BurstBalloons</title>
      <link href="/2024/12/11/BurstBalloons/"/>
      <url>/2024/12/11/BurstBalloons/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.区间dp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 很精彩的转换： 以某个气球k是最后戳破的为突破口</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/12/11 15:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 戳气球</span></span><br><span class="line"><span class="comment">// 有 n 个气球，编号为0到n-1，每个气球上都标有一个数字，这些数字存在数组nums中</span></span><br><span class="line"><span class="comment">// 现在要求你戳破所有的气球。戳破第 i 个气球</span></span><br><span class="line"><span class="comment">// 你可以获得 nums[i - 1] * nums[i] * nums[i + 1] 枚硬币</span></span><br><span class="line"><span class="comment">// 这里的 i - 1 和 i + 1 代表和 i 相邻的两个气球的序号</span></span><br><span class="line"><span class="comment">// 如果 i - 1或 i + 1 超出了数组的边界，那么就当它是一个数字为 1 的气球</span></span><br><span class="line"><span class="comment">// 求所能获得硬币的最大数量</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/burst-balloons/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BurstBalloons</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//很精彩的转换： 以某个气球k是最后戳破的为突破口</span></span><br><span class="line">    <span class="comment">//枚举1...k...n - 1,是最后戳破的气球，递归1...k - 1, k + 1, n - 1</span></span><br><span class="line">    <span class="comment">//定义l,r为l..r范围的气球，以第k个气球为最后戳破的，则总体得分为</span></span><br><span class="line">    <span class="comment">//nums[左边最后戳破的气球] * nums[k] * nums[右边边最后戳破的气球] + f(l, k - 1) + f(k + 1, r)</span></span><br><span class="line">    <span class="comment">//当前指定k是最后戳破的气球时， 对于下一层递归来说</span></span><br><span class="line">    <span class="comment">//若是左范围递归，k就是下层递归的右边最后戳破的气球， l - 1就是 左边最后戳破的气球，而k又等于 r + 1,即下层递归的戳破气球的分数 = nums[l - 1] * nums[k下] * nums[r + 1]</span></span><br><span class="line">    <span class="comment">//右范围也如此</span></span><br><span class="line">    <span class="comment">//图解 -》 l...k...r -&gt; (l..k-1) k (k + 1....r)</span></span><br><span class="line">    <span class="comment">// -&gt; 对于(l..k-1) 范围最后一个戳破的气球来说，k就是他的右侧气球，l + 1就是他的左侧气球</span></span><br><span class="line">    <span class="comment">// -&gt; 对于(k + 1....r) 范围最后一个戳破的气球来说，k就是他的左侧气球，r + 1就是他的右侧气球</span></span><br><span class="line">    <span class="comment">//求枚举所有可能性中的最大值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxCoins1</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">//为了避免边界讨论，往数组两头加个1</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            arr[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp =<span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">return</span> f(<span class="number">1</span>, n, arr, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//暴力递归 + 记忆化搜索</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span>[] arr, <span class="type">int</span>[][] dp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[l][r] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[l][r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="comment">//剩一个气球，直接戳破</span></span><br><span class="line">        <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">            ans = arr[l - <span class="number">1</span>] * arr[l] * arr[r + <span class="number">1</span>];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//枚举每个气球为最后戳破的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt;= r; i++) &#123;</span><br><span class="line">                ans = Math.max(ans, arr[l - <span class="number">1</span>] * arr[i] * arr[r + <span class="number">1</span>] + f(l, i - <span class="number">1</span>, arr, dp) + f(i + <span class="number">1</span>, r, arr, dp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[l][r] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//严格位置依赖的dp</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxCoins2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">//为了避免边界讨论，往数组两头加个1</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        arr[n + <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            arr[i] = nums[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp =<span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>][n + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//填充base case</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][i] = arr[i - <span class="number">1</span>] * arr[i] * arr[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//依赖左边和 下面的格子，从左到右，从下到上更新</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> n; l &gt;= <span class="number">1</span>; l--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> l + <span class="number">1</span>; r &lt;= n; r++) &#123;</span><br><span class="line">                <span class="comment">//枚举每个气球为最后戳破的</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt;= r; i++) &#123;</span><br><span class="line">                    dp[l][r] = Math.max(dp[l][r], arr[l - <span class="number">1</span>] * arr[i] * arr[r + <span class="number">1</span>] + dp[l][i - <span class="number">1</span>] + dp[i + <span class="number">1</span>][r]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">1</span>][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][<span class="number">2</span>];</span><br><span class="line">        System.out.println(dp[<span class="number">0</span>].length);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 区间dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区间dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinimumCostToCutAStick</title>
      <link href="/2024/12/11/MinimumCostToCutAStick/"/>
      <url>/2024/12/11/MinimumCostToCutAStick/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.区间dp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/12/11 11:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 切棍子的最小成本</span></span><br><span class="line"><span class="comment">// 有一根长度为n个单位的木棍，棍上从0到n标记了若干位置</span></span><br><span class="line"><span class="comment">// 给你一个整数数组cuts，其中cuts[i]表示你需要将棍子切开的位置</span></span><br><span class="line"><span class="comment">// 你可以按顺序完成切割，也可以根据需要更改切割的顺序</span></span><br><span class="line"><span class="comment">// 每次切割的成本都是当前要切割的棍子的长度，切棍子的总成本是历次切割成本的总和</span></span><br><span class="line"><span class="comment">// 对棍子进行切割将会把一根木棍分成两根较小的木棍</span></span><br><span class="line"><span class="comment">// 这两根木棍的长度和就是切割前木棍的长度</span></span><br><span class="line"><span class="comment">// 返回切棍子的最小总成本</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/minimum-cost-to-cut-a-stick/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinimumCostToCutAStick</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误的解法（超出内存限制）！！！！ 入口没错，但方向错了！！</span></span><br><span class="line">    <span class="comment">//超出内存限制，看了下n范围是【2，10^6】。因为i,j的所有取值都只能是cuts的值，所以这里用cuts的长度做分析即可</span></span><br><span class="line">    <span class="comment">//直接枚举每个切割点，暴力递归？</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCost0</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] cuts)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//从小到大排序切割点，好区分是否有切割点</span></span><br><span class="line">        Arrays.sort(cuts);</span><br><span class="line">        <span class="keyword">return</span> f(<span class="number">0</span>, n, cuts, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//枚举l-r上每个切割点k，递归l-k, k-r,返回最小成本</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span>[] cuts, <span class="type">int</span>[][] dp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[l][r] != Integer.MAX_VALUE)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[l][r];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="comment">//不能再切了  || 没有切割点</span></span><br><span class="line">        <span class="keyword">if</span> (l == r || l + <span class="number">1</span> == r || r &lt;= cuts[<span class="number">0</span>] || l &gt;= cuts[cuts.length - <span class="number">1</span>])&#123;</span><br><span class="line">            ans = <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//记录是否有切割点</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">hascut</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//枚举每个切割点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cuts.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (cuts[i] &gt; l &amp;&amp; cuts[i] &lt; r)&#123;</span><br><span class="line">                    hascut = <span class="literal">true</span>;</span><br><span class="line">                    ans = Math.min(ans, r - l + f(l, cuts[i], cuts, dp) + f(cuts[i], r, cuts, dp));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!hascut)&#123;</span><br><span class="line">                ans = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[l][r] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//针对cuts做枚举 + 记忆化搜素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCost1</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] cuts)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> cuts.length;</span><br><span class="line">        <span class="comment">//从小到大排序切割点</span></span><br><span class="line">        Arrays.sort(cuts);</span><br><span class="line">        <span class="comment">//加入首尾两个枚举边界</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">2</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        arr[m + <span class="number">1</span>] = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            arr[i] = cuts[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">2</span>][m + <span class="number">2</span>];</span><br><span class="line">        <span class="comment">//m + 1的值都是0(因为是n)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//注意这里是索引范围</span></span><br><span class="line">        <span class="keyword">return</span> f1(<span class="number">0</span>, m + <span class="number">1</span>, arr, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//l,r代表cuts的索引,且arr[l],arr[r]代表上次切割后的边界</span></span><br><span class="line">    <span class="comment">//边界位置不可切割</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span>[] arr, <span class="type">int</span>[][] dp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[l][r] != Integer.MAX_VALUE)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[l][r];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//无法切割 || l,r之间没有切割点（l,r都是边界位置）</span></span><br><span class="line">        <span class="keyword">if</span> (l == r || arr[l] + <span class="number">1</span> == arr[r] || l + <span class="number">1</span> == r)&#123;</span><br><span class="line">            ans = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不一定有切割点</span></span><br><span class="line"><span class="comment">//        else if (arr[l] + 2 == arr[r])&#123;//只能切割一次</span></span><br><span class="line"><span class="comment">//            ans = 2;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//枚举每个切割点，切割当前arr[i]</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l + <span class="number">1</span>; i &lt; r; i++) &#123;</span><br><span class="line">                ans = Math.min(ans, arr[r] - arr[l] + f1(l, i, arr, dp) + f1(i, r, arr, dp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[l][r] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//严格位置依赖的dp</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCost</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] cuts)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> cuts.length;</span><br><span class="line">        <span class="comment">//从小到大排序切割点</span></span><br><span class="line">        Arrays.sort(cuts);</span><br><span class="line">        <span class="comment">//加入首尾两个枚举边界</span></span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">2</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        arr[m + <span class="number">1</span>] = n;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            arr[i] = cuts[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">2</span>][m + <span class="number">2</span>];</span><br><span class="line">        <span class="comment">//依赖左边和下面的格子，从左到右，从下到上更新</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> m; l &gt;= <span class="number">0</span>; l--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> l + <span class="number">2</span>; r &lt;= m + <span class="number">1</span>; r++) &#123;</span><br><span class="line">                dp[l][r] = Integer.MAX_VALUE;</span><br><span class="line">                <span class="comment">//枚举每个切割点，切割当前arr[i]</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l + <span class="number">1</span>; i &lt; r; i++) &#123;</span><br><span class="line">                    dp[l][r] = Math.min(dp[l][r], arr[r] - arr[l] + dp[l][i] + dp[i][r]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][m + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 区间dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区间dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinimumScoreTriangulationOfPolygon</title>
      <link href="/2024/12/10/MinimumScoreTriangulationOfPolygon/"/>
      <url>/2024/12/10/MinimumScoreTriangulationOfPolygon/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.区间dp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 题目理解起来有点混乱，转换思路有点难想</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/12/10 23:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多边形三角剖分的最低得分</span></span><br><span class="line"><span class="comment">// 你有一个凸的 n 边形，其每个顶点都有一个整数值</span></span><br><span class="line"><span class="comment">// 给定一个整数数组values，其中values[i]是第i个顶点的值(顺时针顺序)</span></span><br><span class="line"><span class="comment">// 假设将多边形 剖分 为 n - 2 个三角形</span></span><br><span class="line"><span class="comment">// 对于每个三角形，该三角形的值是顶点标记的乘积</span></span><br><span class="line"><span class="comment">// 三角剖分的分数是进行三角剖分后所有 n - 2 个三角形的值之和</span></span><br><span class="line"><span class="comment">// 返回 多边形进行三角剖分后可以得到的最低分</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/minimum-score-triangulation-of-polygon/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinimumScoreTriangulationOfPolygon</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//想不明白怎么去剖分，没思路</span></span><br><span class="line">    <span class="comment">//看了答案，思路是枚举每个划分点，分析可能性，获取最小值。 思路是固定以该边（0，n-1）为底，枚举1...k..n-1为划分点（顶点），然后做左右区间递归0..k, k..n-1</span></span><br><span class="line">    <span class="comment">//枚举划分点：例如以0，n-1坐边，以1做顶点，剩下的1..n-1继续递归。 接着以2做顶点，剩下0..2 和 2..n-1继续递归</span></span><br><span class="line">    <span class="comment">//这题目理解起来都有点混乱，所以感觉这思路很难想到呀</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//暴力递归 + 记忆化搜索</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minScoreTriangulation</span><span class="params">(<span class="type">int</span>[] values)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> values.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">return</span> f(<span class="number">0</span>, n - <span class="number">1</span>, values, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//思路是固定以该边（0，n-1）为底，枚举1...k..n-1为划分点（顶点），然后做左右区间递归0..k, k..n-1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span>[] values, <span class="type">int</span>[][] dp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[l][r] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[l][r];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span> (r - l &lt; <span class="number">2</span>)&#123;<span class="comment">//端点小于3</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l + <span class="number">1</span>; i &lt; r; i++) &#123;</span><br><span class="line">                ans = Math.min(ans, values[l] * values[i] * values[r] + f(l, i, values, dp) + f(i, r, values, dp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[l][r] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//严格位置以来的dp</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minScoreTriangulation2</span><span class="params">(<span class="type">int</span>[] values)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> values.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="comment">//填充base case   不用填充了，直接循环里搞定，默认值是0</span></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; n - 2; i++) &#123;</span></span><br><span class="line"><span class="comment">//            Arrays.fill(dp[i], Integer.MAX_VALUE);</span></span><br><span class="line"><span class="comment">//            dp[i][i] = 0;</span></span><br><span class="line"><span class="comment">//            dp[i][i + 1] = 0;</span></span><br><span class="line"><span class="comment">//            dp[i][i + 2] = values[i] * values[i + 1] * values[i + 2];</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//依赖左边和下面的格子，所以从左到右，从下到上更新</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> n - <span class="number">3</span>; l &gt;= <span class="number">0</span>; l--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> l + <span class="number">2</span>; r &lt; n; r++) &#123;</span><br><span class="line">                dp[l][r] = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l + <span class="number">1</span>; i &lt; r; i++) &#123;</span><br><span class="line">                    dp[l][r] = Math.min(dp[l][r], values[l] * values[i] * values[r] + dp[l][i] + dp[i][r]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 区间dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区间dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PredictTheWinner</title>
      <link href="/2024/12/10/PredictTheWinner/"/>
      <url>/2024/12/10/PredictTheWinner/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.区间dp;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>  核心：num[l/r] + 下一轮自己可能获得的最小得分</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/12/10 17:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 预测赢家</span></span><br><span class="line"><span class="comment">// 给你一个整数数组 nums 。玩家 1 和玩家 2 基于这个数组设计了一个游戏</span></span><br><span class="line"><span class="comment">// 玩家 1 和玩家 2 轮流进行自己的回合，玩家 1 先手</span></span><br><span class="line"><span class="comment">// 开始时，两个玩家的初始分值都是 0</span></span><br><span class="line"><span class="comment">// 每一回合，玩家从数组的任意一端取一个数字</span></span><br><span class="line"><span class="comment">// 取到的数字将会从数组中移除，数组长度减1</span></span><br><span class="line"><span class="comment">// 玩家选中的数字将会加到他的得分上</span></span><br><span class="line"><span class="comment">// 当数组中没有剩余数字可取时游戏结束</span></span><br><span class="line"><span class="comment">// 如果玩家 1 能成为赢家，返回 true</span></span><br><span class="line"><span class="comment">// 如果两个玩家得分相等，同样认为玩家 1 是游戏的赢家，也返回 true</span></span><br><span class="line"><span class="comment">// 你可以假设每个玩家的玩法都会使他的分数最大化</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/predict-the-winner/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PredictTheWinner</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暴力递归 + 记忆化搜索</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">predictTheWinner1</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> f(<span class="number">0</span>, n - <span class="number">1</span>, nums, dp);</span><br><span class="line">        <span class="keyword">return</span> ans &gt;= sum - ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//玩家1最终能获得的结果</span></span><br><span class="line">    <span class="comment">//从左 或 右拿数字，遵循让对方拿到和值最小结果的规则</span></span><br><span class="line">    <span class="comment">//核心：num[l/r] + 下一轮自己可能获得的最小得分，两种结果选最大</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span>[] nums, <span class="type">int</span>[][] dp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(dp[l][r] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[l][r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">            ans = nums[l];</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (l + <span class="number">1</span> == r)&#123;</span><br><span class="line">            ans = Math.max(nums[l], nums[r]);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//怎么让对方拿最小和值呢？</span></span><br><span class="line">            <span class="comment">//就是让f返回最小</span></span><br><span class="line">            <span class="comment">//当前玩家拿走左边的</span></span><br><span class="line">            <span class="comment">//剩l + 1....r供下一玩家选择，下一个玩家会选择让当前玩家最终得分最小的结果</span></span><br><span class="line">            <span class="comment">//核心：num[l/r] + 下一轮自己可能获得的最小得分</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> nums[l] + Math.min(f(l + <span class="number">2</span>, r, nums, dp), f(l + <span class="number">1</span>, r - <span class="number">1</span>, nums, dp));<span class="comment">//下一玩家会选择让当前玩家得分最小的结果, 下一玩家在拿走左边和右边中做选择</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> nums[r] + Math.min(f(l + <span class="number">1</span>, r - <span class="number">1</span>, nums, dp), f(l, r - <span class="number">2</span>, nums, dp));</span><br><span class="line">            <span class="comment">//当前玩家在两种可能中最大值</span></span><br><span class="line">            ans = Math.max(ans1, ans2);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[l][r] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//严格位置依赖的dp</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">predictTheWinner</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="comment">//填充base case</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = nums[i];</span><br><span class="line">            <span class="keyword">if</span> (i + <span class="number">1</span> &lt; n)&#123;</span><br><span class="line">                dp[i][i + <span class="number">1</span>] = Math.max(nums[i], nums[i + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//（所有的上下左右的都是依据 0在最上/左面，n在最下/右 的 二维表图形）</span></span><br><span class="line">        <span class="comment">//依赖下行格子 和左边的格子</span></span><br><span class="line">        <span class="comment">//所以从下到上更新，从左到右更新</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> n - <span class="number">3</span>; l &gt;= <span class="number">0</span>; l--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> l + <span class="number">2</span>; r &lt; n; r++) &#123;</span><br><span class="line">                dp[l][r] = Math.max(nums[l] + Math.min(dp[l + <span class="number">2</span>][r], dp[l + <span class="number">1</span>][r - <span class="number">1</span>]),</span><br><span class="line">                        nums[r] + Math.min(dp[l + <span class="number">1</span>][r - <span class="number">1</span>], dp[l][r - <span class="number">2</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">one</span> <span class="operator">=</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> one &gt;= sum - one;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 区间dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区间dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinimumInsertionToPalindrome</title>
      <link href="/2024/12/10/MinimumInsertionToPalindrome/"/>
      <url>/2024/12/10/MinimumInsertionToPalindrome/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.区间dp;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/12/10 17:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 让字符串成为回文串的最少插入次数</span></span><br><span class="line"><span class="comment">// 给你一个字符串 s</span></span><br><span class="line"><span class="comment">// 每一次操作你都可以在字符串的任意位置插入任意字符</span></span><br><span class="line"><span class="comment">// 请你返回让s成为回文串的最少操作次数</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/minimum-insertion-steps-to-make-a-string-palindrome/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinimumInsertionToPalindrome</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minInsertions</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length()][s.length()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f1(<span class="number">0</span>, s.length() - <span class="number">1</span>, s.toCharArray(), dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接暴力递归 + 记忆化搜索</span></span><br><span class="line">    <span class="comment">//回文字符串 核心点在于两端字符一定相等，所以从两端点入手</span></span><br><span class="line">    <span class="comment">//两端相同 ， f(l + 1, r - 1)</span></span><br><span class="line">    <span class="comment">//两端不同  则1 + Math.min( f(l + 1, r), f(l, r - 1))</span></span><br><span class="line">    <span class="comment">//base case :</span></span><br><span class="line">    <span class="comment">// 1、l == r -&gt; 0</span></span><br><span class="line">    <span class="comment">// 2、l + 1 == r -&gt; s[l] == s[r] ? 0 : 1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">char</span>[] s, <span class="type">int</span>[][] dp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[l][r] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[l][r];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">            ans = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123;</span><br><span class="line">            ans = s[l] == s[r] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[l] == s[r]) &#123;</span><br><span class="line">                ans = f1(l + <span class="number">1</span>, r - <span class="number">1</span>, s, dp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = Math.min(f1(l + <span class="number">1</span>, r, s, dp), f1(l, r - <span class="number">1</span>, s, dp)) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[l][r] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//严格位置依赖的dp</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minInsertions2</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> str.length();</span><br><span class="line">        <span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="comment">//填充base case  dp[i][i] = 0, 默认是0，所以不更了，直接到n - 1结束</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            dp[i][i + <span class="number">1</span>] = s[i] == s[i + <span class="number">1</span>] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//依赖下一行左边的格子、下一行当前格子 和当前行左边的格子</span></span><br><span class="line">        <span class="comment">//所以从底到顶（0），从左到右更新</span></span><br><span class="line">        <span class="comment">//由于最底2行已经更新，所以i从第三行开始. 由于每一行的前两个格子已更新，所以j从第三个格子开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> n - <span class="number">3</span>; l &gt;= <span class="number">0</span>; l--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> l + <span class="number">2</span>; r &lt; n; r++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[l] == s[r])&#123;</span><br><span class="line">                    dp[l][r] = dp[l + <span class="number">1</span>][r - <span class="number">1</span>];</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[l][r] = Math.min(dp[l + <span class="number">1</span>][r], dp[l][r - <span class="number">1</span>]) + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 区间dp </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 区间dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MixedKnapsack</title>
      <link href="/2024/12/09/MixedKnapsack/"/>
      <url>/2024/12/09/MixedKnapsack/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.背包.多重背包;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>  混合背包</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/12/9 10:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 混合背包 + 多重背包普通窗口优化</span></span><br><span class="line"><span class="comment">// 能成功找零的钱数种类</span></span><br><span class="line"><span class="comment">// 每一种货币都给定面值val[i]，和拥有的数量cnt[i]</span></span><br><span class="line"><span class="comment">// 想知道目前拥有的货币，在钱数为1、2、3...m时</span></span><br><span class="line"><span class="comment">// 能找零成功的钱数有多少</span></span><br><span class="line"><span class="comment">// 也就是说当钱数的范围是1~m</span></span><br><span class="line"><span class="comment">// 返回这个范围上有多少可以找零成功的钱数</span></span><br><span class="line"><span class="comment">// 比如只有3元的货币，数量是5张</span></span><br><span class="line"><span class="comment">// m = 10</span></span><br><span class="line"><span class="comment">// 那么在1~10范围上，只有钱数是3、6、9时，可以成功找零</span></span><br><span class="line"><span class="comment">// 所以返回3表示有3种钱数可以找零成功</span></span><br><span class="line"><span class="comment">// 测试链接 : http://poj.org/problem?id=1742</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下的code，提交时请把类名改成&quot;Main&quot;，可以直接通过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解释下题目意思：给你n代表钱种类，m代表需要找零的不超过的总钱数</span></span><br><span class="line">    <span class="comment">//接下来2n个数字，前n个代表每种钱币价， 后n个代表每种钱币的个数</span></span><br><span class="line">    <span class="comment">//问从1~m的钱数时，能成功找零的钱数一共有多少种</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MixedKnapsack</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXM</span> <span class="operator">=</span> <span class="number">100001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] val = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];<span class="comment">//钱币价值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];<span class="comment">//钱币个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[MAXM];<span class="comment">//是否能找零</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//01背包，完全背包、多重背包的混合题目，针对当前钱数i进行讨论</span></span><br><span class="line">    <span class="comment">//定义dp[i][j] 为 当前钱数种类为i时，针对钱数不超过j，能成功找零的钱数有多少种</span></span><br><span class="line">    <span class="comment">//这里的多重背包是用 余数分组+单调队列优化的. (余数是指m / val[i].因为dp[m]的结果只依赖m - k * val[i])</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            n = (<span class="type">int</span>) in.nval;</span><br><span class="line">            in.nextToken();</span><br><span class="line">            m = (<span class="type">int</span>) in.nval;</span><br><span class="line">            <span class="keyword">if</span> (n != <span class="number">0</span> || m != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                    in.nextToken();</span><br><span class="line">                    val[i] = (<span class="type">int</span>) in.nval;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                    in.nextToken();</span><br><span class="line">                    cnt[i] = (<span class="type">int</span>) in.nval;</span><br><span class="line">                &#125;</span><br><span class="line">                out.println(compute());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空间压缩</span></span><br><span class="line">    <span class="comment">//01背包</span></span><br><span class="line">    <span class="comment">//dp&#123;i][j] = dp&#123;i - 1][j];</span></span><br><span class="line">    <span class="comment">//dp&#123;i][j] = dp&#123;i - 1][j - val[i]];</span></span><br><span class="line">    <span class="comment">//结果取||</span></span><br><span class="line">    <span class="comment">//完全背包</span></span><br><span class="line">    <span class="comment">//dp&#123;i][j] = dp&#123;i - 1][j];</span></span><br><span class="line">    <span class="comment">//dp&#123;i][j] = dp&#123;i][j - val[i]];</span></span><br><span class="line">    <span class="comment">//结果取||</span></span><br><span class="line">    <span class="comment">//多重背包</span></span><br><span class="line">    <span class="comment">//枚举0-val[i]的所有余数</span></span><br><span class="line">    <span class="comment">//同余（余数）分组 + 单调队列，只要队列中有任意true 即可</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        Arrays.fill(dp,<span class="number">0</span>, m + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">//01背包</span></span><br><span class="line">            <span class="keyword">if</span> (cnt[i] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m; j &gt;= val[i]; j--) &#123;</span><br><span class="line">                    dp[j] |= dp[j - val[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (val[i] * cnt[i] &gt; m)&#123;<span class="comment">//完全背包</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> val[i]; j &lt;= m; j++) &#123;</span><br><span class="line">                    dp[j] |= dp[j - val[i]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//多重背包  依赖上一个格子和上一个左边的格子，所以从右往左更新</span></span><br><span class="line">                <span class="comment">//遍历所有可能的余数</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">0</span>, dpcnt; mod &lt; val[i]; mod++) &#123;</span><br><span class="line">                    <span class="comment">//记录窗口内结果是true的个数</span></span><br><span class="line">                    dpcnt = <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">//构建单调队列窗口 （因为只需要统计窗口内true的个数，所以这里单调队列退化成普通窗口即可）</span></span><br><span class="line">                    <span class="comment">//窗口内统计倒数cnt[i]个余数</span></span><br><span class="line">                    <span class="comment">//j代表当前余数的下标.  mod = m - k * val[i] -&gt; mod 就是m/val[i]的偏移量，val[i]是每个坐标的间隔 -&gt; m - mod即每个可能的余数的末尾坐标</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m - mod, size = <span class="number">0</span>; j &gt;= <span class="number">0</span> &amp;&amp; size &lt;= cnt[i]; j -= val[i], size++) &#123;</span><br><span class="line">                        dpcnt += dp[j] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//窗口向左滑动</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m - mod, l = j - val[i] * (cnt[i] + <span class="number">1</span>); j &gt;= <span class="number">1</span>; j -= val[i], l -= val[i]) &#123;</span><br><span class="line">                        <span class="comment">//最右侧为true，出窗口，并且不用更新dp[j]的值</span></span><br><span class="line">                        <span class="keyword">if</span> (dp[j])&#123;</span><br><span class="line">                            dpcnt--;</span><br><span class="line">                        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                            <span class="comment">//判断当前窗口内结果为true的个数是否大于0， 并更新当前dp[j]值</span></span><br><span class="line">                            <span class="comment">//这里这么做的原因是：</span></span><br><span class="line">                            <span class="comment">// 当dp[j] 为false时，要看窗口内的值决定它是否是false，而dp[j]为true时，就不用更新了</span></span><br><span class="line">                            <span class="keyword">if</span> (dpcnt != <span class="number">0</span>)&#123;</span><br><span class="line">                                dp[j] = <span class="literal">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//判断窗口最左边的值</span></span><br><span class="line">                        <span class="keyword">if</span> (l &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                            dpcnt += dp[l] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//统计1-m内所有true的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            ans += dp[i] ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 多重背包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多重背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BoundedKnapsackWithMonotonicQueue</title>
      <link href="/2024/12/07/BoundedKnapsackWithMonotonicQueue/"/>
      <url>/2024/12/07/BoundedKnapsackWithMonotonicQueue/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.背包.多重背包;</span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.StreamTokenizer;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>  多重背包 的单调队列优化做法，感觉很复杂，麻烦。 还是用二进制分组简单</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/12/7 15:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多重背包单调队列优化</span></span><br><span class="line"><span class="comment">// 宝物筛选</span></span><br><span class="line"><span class="comment">// 一共有n种货物, 背包容量为t</span></span><br><span class="line"><span class="comment">// 每种货物的价值(v[i])、重量(w[i])、数量(c[i])都给出</span></span><br><span class="line"><span class="comment">// 请返回选择货物不超过背包容量的情况下，能得到的最大的价值</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P1776</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下的code，提交时请把类名改成&quot;Main&quot;，可以直接通过</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoundedKnapsackWithMonotonicQueue</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXW</span> <span class="operator">=</span> <span class="number">40001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] v = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] w = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] c = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[MAXW];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] queue = <span class="keyword">new</span> <span class="title class_">int</span>[MAXW];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> l, r;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            n = (<span class="type">int</span>) in.nval;</span><br><span class="line">            in.nextToken();</span><br><span class="line">            t = (<span class="type">int</span>) in.nval;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                in.nextToken();</span><br><span class="line">                v[i] = (<span class="type">int</span>) in.nval;</span><br><span class="line">                in.nextToken();</span><br><span class="line">                w[i] = (<span class="type">int</span>) in.nval;</span><br><span class="line">                in.nextToken();</span><br><span class="line">                c[i] = (<span class="type">int</span>) in.nval;</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(compute2());</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 严格位置依赖的动态规划 + 单调队列优化枚举</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][t + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">// 同余分组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">0</span>; mod &lt;= Math.min(t, w[i] - <span class="number">1</span>); mod++) &#123;</span><br><span class="line">                l = r = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> mod; j &lt;= t; j += w[i]) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; value1(dp, i, queue[r - <span class="number">1</span>]) &lt;= value1(dp, i, j)) &#123;</span><br><span class="line">                        r--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue[r++] = j;</span><br><span class="line">                    <span class="keyword">if</span> (queue[l] == j - w[i] * (c[i] + <span class="number">1</span>)) &#123;</span><br><span class="line">                        l++;</span><br><span class="line">                    &#125;</span><br><span class="line">                    dp[i][j] = value1(dp, i, queue[l]) + j / w[i] * v[i];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][t];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前来到i号货物，需要j位置的指标，返回指标值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">value1</span><span class="params">(<span class="type">int</span>[][] dp, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[i - <span class="number">1</span>][j] - j / w[i] * v[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空间压缩的动态规划 + 单调队列优化枚举</span></span><br><span class="line">    <span class="comment">// 因为求dp[i][j]时需要上一行左侧的若干格子</span></span><br><span class="line">    <span class="comment">// 所以做空间压缩时，每一行需要从右往左求</span></span><br><span class="line">    <span class="comment">// 以此来保证左侧的格子还没有更新，还是&quot;上一行&quot;的状况</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">0</span>; mod &lt;= Math.min(t, w[i] - <span class="number">1</span>); mod++) &#123;</span><br><span class="line">                l = r = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 先把c[i]个的指标进入单调队列</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> t - mod, cnt = <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; cnt &lt;= c[i]; j -= w[i], cnt++) &#123;</span><br><span class="line">                    <span class="keyword">while</span> (l &lt; r &amp;&amp; value2(i, queue[r - <span class="number">1</span>]) &lt;= value2(i, j)) &#123;</span><br><span class="line">                        r--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue[r++] = j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> t - mod, enter = j - w[i] * c[i]; j &gt;= <span class="number">0</span>; j -= w[i], enter -= w[i]) &#123;</span><br><span class="line">                    <span class="comment">// 窗口进入enter位置的指标</span></span><br><span class="line">                    <span class="keyword">if</span> (enter &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">while</span> (l &lt; r &amp;&amp; value2(i, queue[r - <span class="number">1</span>]) &lt;= value2(i, enter)) &#123;</span><br><span class="line">                            r--;</span><br><span class="line">                        &#125;</span><br><span class="line">                        queue[r++] = enter;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 计算dp[i][j]</span></span><br><span class="line">                    dp[j] = value2(i, queue[l]) + j / w[i] * v[i];</span><br><span class="line">                    <span class="comment">// 窗口弹出j位置的指标</span></span><br><span class="line">                    <span class="keyword">if</span> (queue[l] == j) &#123;</span><br><span class="line">                        l++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[t];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前来到i号货物，需要j位置的指标，返回指标值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">value2</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dp[j] - j / w[i] * v[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 多重背包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多重背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CherryBlossomViewing</title>
      <link href="/2024/12/06/CherryBlossomViewing/"/>
      <url>/2024/12/06/CherryBlossomViewing/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.背包.多重背包;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/12/6 15:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 观赏樱花</span></span><br><span class="line"><span class="comment">// 给定一个背包的容量t，一共有n种货物，并且给定每种货物的信息</span></span><br><span class="line"><span class="comment">// 花费(cost)、价值(val)、数量(cnt)</span></span><br><span class="line"><span class="comment">// 如果cnt == 0，代表这种货物可以无限选择</span></span><br><span class="line"><span class="comment">// 如果cnt &gt; 0，那么cnt代表这种货物的数量</span></span><br><span class="line"><span class="comment">// 挑选货物的总容量在不超过t的情况下，返回能得到的最大价值</span></span><br><span class="line"><span class="comment">// 背包容量不超过1000，每一种货物的花费都&gt;0</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P1833</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下的code，提交时请把类名改成&quot;Main&quot;，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CherryBlossomViewing</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">ENOUGH</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIX</span> <span class="operator">=</span> <span class="number">100001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] cost = <span class="keyword">new</span> <span class="title class_">int</span>[MAIX];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] val = <span class="keyword">new</span> <span class="title class_">int</span>[MAIX];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[MAIX];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, t,cnt;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> hour1, minute1, hour2, minute2;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(in);</span><br><span class="line">        <span class="keyword">while</span> (st.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line"></span><br><span class="line">            hour1 = (<span class="type">int</span>) st.nval;</span><br><span class="line">            <span class="comment">// 跳过冒号</span></span><br><span class="line">            st.nextToken();</span><br><span class="line">            st.nextToken();</span><br><span class="line">            minute1 = (<span class="type">int</span>) st.nval;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            hour2 = (<span class="type">int</span>) st.nval;</span><br><span class="line">            <span class="comment">// 跳过冒号</span></span><br><span class="line">            st.nextToken();</span><br><span class="line">            st.nextToken();</span><br><span class="line">            minute2 = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">            <span class="keyword">if</span> (minute1 &gt; minute2) &#123;</span><br><span class="line">                hour2--;</span><br><span class="line">                minute2 += <span class="number">60</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 计算背包容量</span></span><br><span class="line">            t = (hour2 - hour1) * <span class="number">60</span> + minute2 - minute1;</span><br><span class="line"></span><br><span class="line">            n = (<span class="type">int</span>) st.nval;st.nextToken();<span class="comment">//种类</span></span><br><span class="line">            cnt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, c, v, num; i &lt;= n; i++) &#123;</span><br><span class="line">                c = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">                v = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">                num = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">                <span class="comment">//将完全背包转为多重背包</span></span><br><span class="line">                <span class="keyword">if</span> (num == <span class="number">0</span>)&#123;</span><br><span class="line">                    num = ENOUGH;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//二进制分组，将多重背包转为01背包</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= num; k &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    val[++cnt] = k * v;</span><br><span class="line">                    cost[cnt] = k * c;</span><br><span class="line">                    num -= k;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    val[++cnt] = num * v;</span><br><span class="line">                    cost[cnt] = num * c;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(compute());</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//01背包</span></span><br><span class="line">    <span class="comment">//dp[i][j] 为 当前i个商品， 花费不超过j下，能获得的最大价值</span></span><br><span class="line">    <span class="comment">//dp[i][j] = dp[i - 1][j];</span></span><br><span class="line">    <span class="comment">//dp[i][j] = dp[i - 1][j - cost[i]] + val[i];</span></span><br><span class="line">    <span class="comment">//空间压缩</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[t + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> t; j &gt;= cost[i]; j--) &#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - cost[i]] + val[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[t];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 多重背包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多重背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BoundedKnapsackWithBinarySplitting</title>
      <link href="/2024/12/05/BoundedKnapsackWithBinarySplitting/"/>
      <url>/2024/12/05/BoundedKnapsackWithBinarySplitting/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.背包.多重背包;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>  将多重背包通过二进制分组优化枚举行为，转变为01背包</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/12/5 16:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多重背包通过二进制分组转化成01背包(模版)</span></span><br><span class="line"><span class="comment">// 宝物筛选</span></span><br><span class="line"><span class="comment">// 一共有n种货物, 背包容量为t</span></span><br><span class="line"><span class="comment">// 每种货物的价值(v[i])、重量(w[i])、数量(c[i])都给出</span></span><br><span class="line"><span class="comment">// 请返回选择货物不超过背包容量的情况下，能得到的最大的价值</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P1776</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下的code，提交时请把类名改成&quot;Main&quot;，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoundedKnapsackWithBinarySplitting</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXW</span> <span class="operator">=</span> <span class="number">40001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把每一种货物根据个数做二进制分组，去生成衍生商品</span></span><br><span class="line">    <span class="comment">// 衍生出来的每一种商品，价值放入v、重量放入w</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] v = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] w = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[MAXW];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, t, m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 时间复杂度O(t * (log(第1种商品的个数) + log(第2种商品的个数) + ... + log(第n种商品的个数)))</span></span><br><span class="line">    <span class="comment">// 对每一种商品的个数取log，所以时间复杂度虽然大于O(n * t)，但也不会大多少</span></span><br><span class="line">    <span class="comment">// 多重背包最常用的方式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            n = (<span class="type">int</span>) in.nval;</span><br><span class="line">            in.nextToken();</span><br><span class="line">            t = (<span class="type">int</span>) in.nval;</span><br><span class="line">            m = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, value, weight, cnt; i &lt;= n; i++) &#123;</span><br><span class="line">                in.nextToken(); value = (<span class="type">int</span>) in.nval;</span><br><span class="line">                in.nextToken(); weight = (<span class="type">int</span>) in.nval;</span><br><span class="line">                in.nextToken(); cnt = (<span class="type">int</span>) in.nval;</span><br><span class="line">                <span class="comment">// 整个文件最重要的逻辑 : 二进制分组</span></span><br><span class="line">                <span class="comment">// 一般都使用这种技巧，这段代码非常重要</span></span><br><span class="line">                <span class="comment">// 虽然时间复杂度不如单调队列优化的版本</span></span><br><span class="line">                <span class="comment">// 但是好写，而且即便是比赛，时间复杂度也达标</span></span><br><span class="line">                <span class="comment">// 二进制分组的时间复杂度为O(log cnt)</span></span><br><span class="line">                <span class="comment">//这里核心是二进制分组，将当前类别商品的个数按二进制分成多份，每份只有1个，将原本的枚举行为转为01背包行为，且不会错过每一个商品分数的可能性（01背包的可能性组合）</span></span><br><span class="line">                <span class="comment">//核心就一句话：将枚举行为转为 01背包的可能性组合</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= cnt; k &lt;&lt;= <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">//二进制分组</span></span><br><span class="line">                    v[++m] = k * value;</span><br><span class="line">                    w[m] = k * weight;</span><br><span class="line">                    cnt -= k;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//这里是将不及下一个2的倍数的，单独成份</span></span><br><span class="line">                <span class="keyword">if</span> (cnt &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    v[++m] = cnt * value;</span><br><span class="line">                    w[m] = cnt * weight;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(compute());</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 01背包的空间压缩代码(模版)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        Arrays.fill(dp, <span class="number">0</span>, t + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> t; j &gt;= w[i]; j--) &#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - w[i]] + v[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[t];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 多重背包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多重背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BoundedKnapsack</title>
      <link href="/2024/12/05/BoundedKnapsack/"/>
      <url>/2024/12/05/BoundedKnapsack/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.背包.多重背包;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/12/5 15:29</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 多重背包不进行枚举优化</span></span><br><span class="line"><span class="comment">// 宝物筛选</span></span><br><span class="line"><span class="comment">// 一共有n种货物, 背包容量为t</span></span><br><span class="line"><span class="comment">// 每种货物的价值(v[i])、重量(w[i])、数量(c[i])都给出</span></span><br><span class="line"><span class="comment">// 请返回选择货物不超过背包容量的情况下，能得到的最大的价值</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P1776</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下的code，提交时请把类名改成&quot;Main&quot;，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoundedKnapsack</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, cnt, t;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXW</span> <span class="operator">=</span> <span class="number">40001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] v = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] w = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] c = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[MAXW];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这种是不分组，dp时直接枚举组内物品</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            n = (<span class="type">int</span>) in.nval;</span><br><span class="line">            in.nextToken();</span><br><span class="line">            t = (<span class="type">int</span>) in.nval;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                in.nextToken(); v[i] = (<span class="type">int</span>) in.nval;</span><br><span class="line">                in.nextToken(); w[i] = (<span class="type">int</span>) in.nval;</span><br><span class="line">                in.nextToken(); c[i] = (<span class="type">int</span>) in.nval;</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(compute2());</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 空间压缩</span></span><br><span class="line">    <span class="comment">//依赖上一行格子 和上一行左边格子，从右到左更新</span></span><br><span class="line">    <span class="comment">// 部分测试用例超时</span></span><br><span class="line">    <span class="comment">// 因为没有优化枚举</span></span><br><span class="line">    <span class="comment">// 时间复杂度O(n * t * 每种商品的平均个数)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute2</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[t + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> t; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= c[i] &amp;&amp; w[i] * k &lt;= j; k++) &#123;</span><br><span class="line">                    dp[j] = Math.max(dp[j], dp[j - k * w[i]] + k * v[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 多重背包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多重背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BuyingHayMinimumCost</title>
      <link href="/2024/12/05/BuyingHayMinimumCost/"/>
      <url>/2024/12/05/BuyingHayMinimumCost/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.背包.完全背包;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/12/5 10:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 购买足量干草的最小花费</span></span><br><span class="line"><span class="comment">// 有n个提供干草的公司，每个公司都有两个信息</span></span><br><span class="line"><span class="comment">// cost[i]代表购买1次产品需要花的钱</span></span><br><span class="line"><span class="comment">// val[i]代表购买1次产品所获得的干草数量</span></span><br><span class="line"><span class="comment">// 每个公司的产品都可以购买任意次</span></span><br><span class="line"><span class="comment">// 你一定要至少购买h数量的干草，返回最少要花多少钱</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P2918</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下的所有代码，并把主类名改成&quot;Main&quot;，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuyingHayMinimumCost</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIM</span> <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] cost = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] val = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, m, h;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//题目表示为至少满足H榜干草，所以是可以超过的，那就放大H的范围</span></span><br><span class="line">    <span class="comment">//定义dp[i][j] 为 当前i个公司，满足 严格等于j磅 干草  的最小开销</span></span><br><span class="line">    <span class="comment">//dp[i][j] = dp[i - 1][j];</span></span><br><span class="line">    <span class="comment">//dp[i][j] = dp[i][j - cost[i]] + val[i];</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(in);</span><br><span class="line">        <span class="keyword">while</span> (st.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            n = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">            m = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">            h = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, v,c; i &lt;= n; i++) &#123;</span><br><span class="line">                c = (<span class="type">int</span>) st.nval;st.nextToken();<span class="comment">//干草重量</span></span><br><span class="line">                v = (<span class="type">int</span>) st.nval;st.nextToken();<span class="comment">//开销</span></span><br><span class="line">                <span class="comment">//记录最大磅干草，用于放大范围</span></span><br><span class="line">                h = Math.max(h, c);</span><br><span class="line">                cost[i] = c;</span><br><span class="line">                val[i] = v;</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(compute());</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp[i][j] = dp[i - 1][j];</span></span><br><span class="line">    <span class="comment">//dp[i][j] = dp[i][j - cost[i]] + val[i];</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + h];</span><br><span class="line">        Arrays.fill(dp, Integer.MAX_VALUE);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从左到右更新</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> cost[i]; j &lt; dp.length; j++) &#123;</span><br><span class="line">                <span class="comment">//注意这里，要判断不能是初始值</span></span><br><span class="line">                <span class="keyword">if</span> (dp[j - cost[i]] != Integer.MAX_VALUE)&#123;</span><br><span class="line">                    dp[j] = Math.min(dp[j], dp[j - cost[i]]+ val[i]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//从最后一层的n的m列开始找符合条件的最小开销</span></span><br><span class="line">                <span class="keyword">if</span> (i == n &amp;&amp; j &gt;= m)&#123;</span><br><span class="line">                    ans = Math.min(dp[j], ans);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 完全背包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 完全背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WildcardMatching</title>
      <link href="/2024/12/05/WildcardMatching/"/>
      <url>/2024/12/05/WildcardMatching/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.背包.完全背包;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>  当遇到*时，就讨论完全背包了</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/12/5 10:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 通配符匹配（和题目4高度相似，只是边界条件不同而已，而且更简单）</span></span><br><span class="line"><span class="comment">// 给你字符串s、字符串p</span></span><br><span class="line"><span class="comment">// s中一定不含有&#x27;?&#x27;、&#x27;*&#x27;字符，p中可能含有&#x27;?&#x27;、&#x27;*&#x27;字符</span></span><br><span class="line"><span class="comment">// &#x27;?&#x27; 表示可以变成任意字符，数量1个</span></span><br><span class="line"><span class="comment">// &#x27;*&#x27; 表示可以匹配任何字符串</span></span><br><span class="line"><span class="comment">// 请实现一个支持 &#x27;?&#x27; 和 &#x27;*&#x27; 的通配符匹配</span></span><br><span class="line"><span class="comment">// 返回p的整个字符串能不能匹配出s的整个字符串</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/wildcard-matching/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WildcardMatching</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//匹配规则：</span></span><br><span class="line">    <span class="comment">//当p[j]不是 *， 匹配s[i] == p[j] || p[j] == &#x27;?&#x27;, i++, j++</span></span><br><span class="line">    <span class="comment">//当p[j]是 *, 匹配i++, j || i, j++</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//边界条件讨论：</span></span><br><span class="line">    <span class="comment">//p == len &amp;&amp; s == len, true</span></span><br><span class="line">    <span class="comment">//p == len &amp;&amp; s != len, false</span></span><br><span class="line">    <span class="comment">//s == len &amp;&amp; p != len, p[j] == * &amp;&amp; j++</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[s.length() + <span class="number">1</span>][p.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> f(<span class="number">0</span>, <span class="number">0</span>, s.toCharArray(), p.toCharArray(), dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span>[] s, <span class="type">char</span>[] p, <span class="type">int</span>[][] dp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[i][j] == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> ans;</span><br><span class="line">        <span class="keyword">if</span> (j == p.length)&#123;</span><br><span class="line">            ans = i == s.length;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//p结束 但 s没结束， 必须保证p后面都能自己消除</span></span><br><span class="line">            <span class="keyword">if</span> (i == s.length)&#123;</span><br><span class="line">                ans = p[j] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; f(i, j + <span class="number">1</span>, s, p, dp);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//匹配单个字符</span></span><br><span class="line">                <span class="keyword">if</span> (p[j] != <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                    ans = (s[i] == p[j] || p[j] == <span class="string">&#x27;?&#x27;</span>) &amp;&amp; f(i + <span class="number">1</span>, j + <span class="number">1</span>, s, p, dp);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//匹配当前*， 或者不匹配当前* （完全背包）</span></span><br><span class="line">                    ans = f(i + <span class="number">1</span>, j, s, p, dp) || f(i, j + <span class="number">1</span>, s, p, dp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][j] = ans ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 严格位置依赖的动态规划</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMatch3</span><span class="params">(String str, String pat)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] p = pat.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> p.length;</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        dp[n][m] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; p[j] == <span class="string">&#x27;*&#x27;</span>; j--) &#123;</span><br><span class="line">            dp[n][j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (p[j] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = (s[i] == p[j] || p[j] == <span class="string">&#x27;?&#x27;</span>) &amp;&amp; dp[i + <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i + <span class="number">1</span>][j] || dp[i][j + <span class="number">1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        isMatch(<span class="string">&quot;aa&quot;</span>, <span class="string">&quot;*&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 完全背包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 完全背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RegularExpressionMatching</title>
      <link href="/2024/12/04/RegularExpressionMatching/"/>
      <url>/2024/12/04/RegularExpressionMatching/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.背包.完全背包;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/12/4 22:28</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RegularExpressionMatching</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自己写的思路，有点点乱</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[p.length() + <span class="number">1</span>][s.length() + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> f(<span class="number">0</span>, <span class="number">0</span>, s.toCharArray(), p.toCharArray(), dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//情况的讨论：</span></span><br><span class="line">    <span class="comment">//1. 当前s2[i + 1] 不等于 * 时，正常对比当前字符， j++, i++</span></span><br><span class="line">    <span class="comment">//2、当s2[i]后面字符是*时</span></span><br><span class="line">    <span class="comment">//2.1 不取当前字符，直接跳过 i + 2， j 不变</span></span><br><span class="line">    <span class="comment">//2.2 取当前字符，做对比， 可重复取 即i不变， j + 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//先来个记忆化搜索递归</span></span><br><span class="line">    <span class="comment">//i 是p的索引，j是s的索引</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span>[] s, <span class="type">char</span>[] p,  <span class="type">int</span>[][] dp)</span>&#123;</span><br><span class="line">        <span class="comment">//如果都结束，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (i == p.length &amp;&amp; j == s.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果p结束，但s没结束</span></span><br><span class="line">        <span class="keyword">if</span> (i == p.length &amp;&amp; j != s.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[i][j] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[i][j] == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//s结束，但p没结束，p必须保证能消除后续字符</span></span><br><span class="line">        <span class="keyword">if</span> (j == s.length)&#123;</span><br><span class="line">            ans = i + <span class="number">1</span> &lt; p.length &amp;&amp; p[i + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; f(i + <span class="number">2</span>, j, s, p, dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i + <span class="number">1</span> &lt; p.length &amp;&amp; p[i + <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span> || i + <span class="number">1</span> == p.length)&#123;</span><br><span class="line">            ans = (p[i] == <span class="string">&#x27;.&#x27;</span> || p[i] == s[j]) &amp;&amp; f(i + <span class="number">1</span>, j + <span class="number">1</span>, s, p, dp);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i + <span class="number">1</span> &lt; p.length &amp;&amp; p[i + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">            ans = f(i + <span class="number">2</span>, j, s, p, dp) || ((p[i] == <span class="string">&#x27;.&#x27;</span> || p[i] == s[j]) &amp;&amp; f(i, j + <span class="number">1</span>, s, p, dp));</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][j] = ans ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下是左神的代码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMatch1</span><span class="params">(String str, String pat)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] p = pat.toCharArray();</span><br><span class="line">        <span class="keyword">return</span> f1(s, p, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s[i....]能不能被p[j....]完全匹配出来</span></span><br><span class="line">    <span class="comment">// p[j]这个字符，一定不是&#x27;*&#x27;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">f1</span><span class="params">(<span class="type">char</span>[] s, <span class="type">char</span>[] p, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == s.length) &#123;</span><br><span class="line">            <span class="comment">// s没了</span></span><br><span class="line">            <span class="keyword">if</span> (j == p.length) &#123;</span><br><span class="line">                <span class="comment">// 如果p也没了，返回true</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// p还剩下一些后缀</span></span><br><span class="line">                <span class="comment">// 如果p[j+1]是*，那么p[j..j+1]可以消掉，然后看看p[j+2....]是不是都能消掉</span></span><br><span class="line">                <span class="keyword">return</span> j + <span class="number">1</span> &lt; p.length &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; f1(s, p, i, j + <span class="number">2</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == p.length) &#123;</span><br><span class="line">            <span class="comment">// s有后缀</span></span><br><span class="line">            <span class="comment">// p没后缀了</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// s有后缀</span></span><br><span class="line">            <span class="comment">// p有后缀</span></span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> == p.length || p[j + <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                <span class="comment">// s[i....]</span></span><br><span class="line">                <span class="comment">// p[j....]</span></span><br><span class="line">                <span class="comment">// 如果p[j+1]不是*，那么当前的字符必须能匹配：(s[i] == p[j] || p[j] == &#x27;?&#x27;)</span></span><br><span class="line">                <span class="comment">// 同时，后续也必须匹配上：process1(s, p, i + 1, j + 1);</span></span><br><span class="line">                <span class="keyword">return</span> (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; f1(s, p, i + <span class="number">1</span>, j + <span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果p[j+1]是*</span></span><br><span class="line">                <span class="comment">// 完全背包！</span></span><br><span class="line">                <span class="comment">// s[i....]</span></span><br><span class="line">                <span class="comment">// p[j....]</span></span><br><span class="line">                <span class="comment">// 选择1: 当前p[j..j+1]是x*，就是不让它搞定s[i]，那么继续 : process1(s, p, i, j + 2)</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">p1</span> <span class="operator">=</span> f1(s, p, i, j + <span class="number">2</span>);</span><br><span class="line">                <span class="comment">// 选择2: 当前p[j..j+1]是x*，如果可以搞定s[i]，那么继续 : process1(s, p, i + 1, j)</span></span><br><span class="line">                <span class="comment">// 如果可以搞定s[i] : (s[i] == p[j] || p[j] == &#x27;.&#x27;)</span></span><br><span class="line">                <span class="comment">// 继续匹配 : process1(s, p, i + 1, j)</span></span><br><span class="line">                <span class="type">boolean</span> <span class="variable">p2</span> <span class="operator">=</span> (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; f1(s, p, i + <span class="number">1</span>, j);</span><br><span class="line">                <span class="comment">// 两个选择，有一个可以搞定就返回true，都无法搞定返回false</span></span><br><span class="line">                <span class="keyword">return</span> p1 || p2;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记忆化搜索</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMatch2</span><span class="params">(String str, String pat)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] p = pat.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> p.length;</span><br><span class="line">        <span class="comment">// dp[i][j] == 0，表示没算过</span></span><br><span class="line">        <span class="comment">// dp[i][j] == 1，表示算过，答案是true</span></span><br><span class="line">        <span class="comment">// dp[i][j] == 2，表示算过，答案是false</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> f2(s, p, <span class="number">0</span>, <span class="number">0</span>, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">f2</span><span class="params">(<span class="type">char</span>[] s, <span class="type">char</span>[] p, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[][] dp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][j] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[i][j] == <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">boolean</span> ans;</span><br><span class="line">        <span class="keyword">if</span> (i == s.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j == p.length) &#123;</span><br><span class="line">                ans = <span class="literal">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = j + <span class="number">1</span> &lt; p.length &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; f2(s, p, i, j + <span class="number">2</span>, dp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == p.length) &#123;</span><br><span class="line">            ans = <span class="literal">false</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (j + <span class="number">1</span> == p.length || p[j + <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                ans = (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; f2(s, p, i + <span class="number">1</span>, j + <span class="number">1</span>, dp);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ans = f2(s, p, i, j + <span class="number">2</span>, dp) || ((s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; f2(s, p, i + <span class="number">1</span>, j, dp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][j] = ans ? <span class="number">1</span> : <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 严格位置依赖的动态规划</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isMatch3</span><span class="params">(String str, String pat)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] p = pat.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> p.length;</span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        dp[n][m] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            dp[n][j] = j + <span class="number">1</span> &lt; m &amp;&amp; p[j + <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span> &amp;&amp; dp[n][j + <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> == m || p[j + <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                    dp[i][j] = (s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; dp[i + <span class="number">1</span>][j + <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i][j + <span class="number">2</span>] || ((s[i] == p[j] || p[j] == <span class="string">&#x27;.&#x27;</span>) &amp;&amp; dp[i + <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RegularExpressionMatching</span> <span class="variable">regularExpressionMatching</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RegularExpressionMatching</span>();</span><br><span class="line">        regularExpressionMatching.isMatch(<span class="string">&quot;aab&quot;</span>, <span class="string">&quot;c*a*b&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 完全背包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 完全背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UnboundedKnapsack</title>
      <link href="/2024/12/04/UnboundedKnapsack/"/>
      <url>/2024/12/04/UnboundedKnapsack/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.背包.完全背包;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 完全背包</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/12/4 16:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 完全背包(模版)</span></span><br><span class="line"><span class="comment">// 给定一个正数t，表示背包的容量</span></span><br><span class="line"><span class="comment">// 有m种货物，每种货物可以选择任意个</span></span><br><span class="line"><span class="comment">// 每种货物都有体积costs[i]和价值values[i]</span></span><br><span class="line"><span class="comment">// 返回在不超过总容量的情况下，怎么挑选货物能达到价值最大</span></span><br><span class="line"><span class="comment">// 返回最大的价值</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P1616</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下的所有代码，并把主类名改成&quot;Main&quot;，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnboundedKnapsack</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> t,m;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIM</span> <span class="operator">=</span> <span class="number">10001</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] cost = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] val = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(in);</span><br><span class="line">        <span class="keyword">while</span> (st.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            t = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">            m = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">                cost[i] = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">                val[i] = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(compute());</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义dp[i][j] 为 i种草药，采摘时间不超过j下，能获得的最大价值</span></span><br><span class="line">    <span class="comment">//每次采摘可以选择：</span></span><br><span class="line">    <span class="comment">//dp[i][j] = dp[i - 1][j];//不摘当前草药</span></span><br><span class="line">    <span class="comment">//dp[i][j] = dp[i][j - cost[i]] + val[i];//继续摘当前草药，直接减去草药价值（注意！！这里是dp[i] 而不是dp[i - 1],这个含义是可以继续选择当前的i号草药，而不必选之前的i-1种草药，这也是和分组背包不同的地方）</span></span><br><span class="line">    <span class="comment">//取最大值</span></span><br><span class="line">    <span class="comment">//空间压缩</span></span><br><span class="line">    <span class="comment">//依赖上一个格子和当前左边的格子，所以从左到右更新</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span>[] dp = <span class="keyword">new</span> <span class="title class_">long</span>[t + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> cost[i]; j &lt;= t; j++) &#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - cost[i]] + val[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 完全背包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 完全背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MaximumValueOfKcoinsFromPiles</title>
      <link href="/2024/12/04/MaximumValueOfKcoinsFromPiles/"/>
      <url>/2024/12/04/MaximumValueOfKcoinsFromPiles/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.背包.分组背包;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/12/4 14:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 从栈中取出K个硬币的最大面值和</span></span><br><span class="line"><span class="comment">// 一张桌子上总共有 n 个硬币 栈 。每个栈有 正整数 个带面值的硬币</span></span><br><span class="line"><span class="comment">// 每一次操作中，你可以从任意一个栈的 顶部 取出 1 个硬币，从栈中移除它，并放入你的钱包里</span></span><br><span class="line"><span class="comment">// 给你一个列表 piles ，其中 piles[i] 是一个整数数组</span></span><br><span class="line"><span class="comment">// 分别表示第 i 个栈里 从顶到底 的硬币面值。同时给你一个正整数 k</span></span><br><span class="line"><span class="comment">// 请你返回在 恰好 进行 k 次操作的前提下，你钱包里硬币面值之和 最大为多少</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/maximum-value-of-k-coins-from-piles/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaximumValueOfKcoinsFromPiles</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//思路是自己想的，但代码细节有误，看了答案修正的</span></span><br><span class="line">    <span class="comment">//怎么想到的思路呢？ 栈的每次取值很像分组背包，以及题目提示前缀和，然后从前缀和入手，想到把每k次操作转化为一个分组商品，得到的dp</span></span><br><span class="line">    <span class="comment">//重点在于怎么题目条件怎么转化为分组“商品”</span></span><br><span class="line">    <span class="comment">//定义dp[i][j] 为 i个栈中 操作j次，能获得的最大和为多少</span></span><br><span class="line">    <span class="comment">//dp[i][j] = dp[i - 1][j] //当前栈不做任何操作</span></span><br><span class="line">    <span class="comment">//当前栈循环操作k次.</span></span><br><span class="line">    <span class="comment">//dp[i][j] = dp[i - 1][j - 1] + sum[i][1]</span></span><br><span class="line">    <span class="comment">//dp[i][j] = dp[i - 1][j - 2] + sum[i][2]</span></span><br><span class="line">    <span class="comment">//dp[i][j] = dp[i - 1][j - 3] + sum[i][3]</span></span><br><span class="line">    <span class="comment">//dp[i][j] = dp[i - 1][j - k] + sum[i][k]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//空间压缩</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValueOfCoins</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; piles, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>  piles.size();</span><br><span class="line">        <span class="comment">//统计各个栈的前缀和</span></span><br><span class="line">        <span class="comment">//sum只和当前栈有关系</span></span><br><span class="line">        <span class="type">int</span>[] sum = <span class="keyword">new</span> <span class="title class_">int</span>[k + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//依赖上一个格子和上一个格子的左边格子， 从右往左更新</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, t; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">//统计当前栈前缀和</span></span><br><span class="line">            List&lt;Integer&gt; list = piles.get(i - <span class="number">1</span>);</span><br><span class="line">            t = Math.min(k, list.size());</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= t ; j++) &#123;</span><br><span class="line">                sum[j] = sum[j - <span class="number">1</span>] + list.get(j - <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> k; j &gt;= <span class="number">1</span>; j--) &#123;</span><br><span class="line">                <span class="comment">//遍历所有操作</span></span><br><span class="line">                <span class="comment">//注意这里l的取值限制</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>; l &lt;= Math.min(t, j); l++) &#123;</span><br><span class="line">                    dp[j] = Math.max(dp[j], dp[j - l] + sum[l]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 分组背包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分组背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PartitionedKnapsack</title>
      <link href="/2024/12/03/PartitionedKnapsack/"/>
      <url>/2024/12/03/PartitionedKnapsack/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.背包.分组背包;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/12/3 22:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分组背包(模版)</span></span><br><span class="line"><span class="comment">// 给定一个正数m表示背包的容量，有n个货物可供挑选</span></span><br><span class="line"><span class="comment">// 每个货物有自己的体积(容量消耗)、价值(获得收益)、组号(分组)</span></span><br><span class="line"><span class="comment">// 同一个组的物品只能挑选1件，所有挑选物品的体积总和不能超过背包容量</span></span><br><span class="line"><span class="comment">// 怎么挑选货物能达到价值最大，返回最大的价值</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P1757</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下的所有代码，并把主类名改成&quot;Main&quot;，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PartitionedKnapsack</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIM</span> <span class="operator">=</span> <span class="number">1001</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, m, t;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] val = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] weight = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Integer, ArrayList&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, ArrayList&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将物品分组，按组dp</span></span><br><span class="line">    <span class="comment">//dp[i][j],当前i组物品，重量为j情况下，能获得的最大利用价值</span></span><br><span class="line">    <span class="comment">//1、dp[i][j] = dp[i - 1][j];</span></span><br><span class="line">    <span class="comment">//2、遍历组内所有物品</span></span><br><span class="line">    <span class="comment">//dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - weiht[k]] + val[k]);</span></span><br><span class="line">    <span class="comment">//获取最大价值</span></span><br><span class="line">    <span class="comment">//核心在于将物品分组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(in);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (st.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            t = <span class="number">0</span>;</span><br><span class="line">            m = (<span class="type">int</span>) st.nval;st.nextToken();<span class="comment">//重量</span></span><br><span class="line">            n = (<span class="type">int</span>) st.nval;st.nextToken();<span class="comment">//物品数量</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, w,v,c; i &lt;= n; i++) &#123;</span><br><span class="line">                w = (<span class="type">int</span>) st.nval;st.nextToken();<span class="comment">//重量</span></span><br><span class="line">                v = (<span class="type">int</span>) st.nval;st.nextToken();<span class="comment">//价值</span></span><br><span class="line">                c = (<span class="type">int</span>) st.nval;st.nextToken();<span class="comment">//组数</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//记录最大组数</span></span><br><span class="line">                t = Math.max(t, c);</span><br><span class="line">                <span class="comment">//放入组内所有物品</span></span><br><span class="line">                ArrayList&lt;Integer&gt; list = map.computeIfAbsent(c, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">                list.add(i);</span><br><span class="line">                val[i] = v;</span><br><span class="line">                weight[i] = w;</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(compute());</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空间压缩</span></span><br><span class="line">    <span class="comment">//依赖上一行格子和上一行左边的格子，所以从右往左更新</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//按组遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= t; i++) &#123;</span><br><span class="line">            ArrayList&lt;Integer&gt; list = map.get(i);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="comment">//遍历组内所有物品</span></span><br><span class="line">                <span class="keyword">for</span> (Integer k : list) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (j - weight[k] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                        dp[j] = Math.max(dp[j], dp[j - weight[k]] + val[k]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 分组背包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分组背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TopKMinimumSubsequenceSum</title>
      <link href="/2024/12/02/TopKMinimumSubsequenceSum/"/>
      <url>/2024/12/02/TopKMinimumSubsequenceSum/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.背包.零一背包;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>  因数据量问题，符合01背包，但不能用01背包解题。</span></span><br><span class="line"><span class="comment"> * 解题思路巧妙难想，思路可当模板记下</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/12/2 16:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 非负数组前k个最小的子序列累加和</span></span><br><span class="line"><span class="comment">// 给定一个数组nums，含有n个数字，都是非负数</span></span><br><span class="line"><span class="comment">// 给定一个正数k，返回所有子序列中累加和最小的前k个累加和</span></span><br><span class="line"><span class="comment">// 子序列是包含空集的</span></span><br><span class="line"><span class="comment">// 1 &lt;= n &lt;= 10^5</span></span><br><span class="line"><span class="comment">// 1 &lt;= nums[i] &lt;= 10^6</span></span><br><span class="line"><span class="comment">// 1 &lt;= k &lt;= 10^5</span></span><br><span class="line"><span class="comment">// 注意这个数据量，用01背包的解法是不行的，时间复杂度太高了</span></span><br><span class="line"><span class="comment">// 对数器验证</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopKMinimumSubsequenceSum</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 01背包思路：定义dp[i][j]为 当前i个数，和值严格为j下，有几个。 j &lt; sums. 枚举所有的j。 然后拿第n层，遍历每列，取j值，有几个j就填冲数组几个</span></span><br><span class="line">    <span class="comment">//dp[i][j] = dp[i - 1][j]</span></span><br><span class="line">    <span class="comment">//dp[i][j] = dp[i - 1][j - nums[i]]</span></span><br><span class="line">    <span class="comment">//结果数相加</span></span><br><span class="line">    <span class="comment">//01背包的话由于n很大，所以直接pass了.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接看左神答案</span></span><br><span class="line">    <span class="comment">// 01背包来实现</span></span><br><span class="line">    <span class="comment">// 这种方法此时不是最优解</span></span><br><span class="line">    <span class="comment">// 因为n很大，数值也很大，那么可能的累加和就更大</span></span><br><span class="line">    <span class="comment">// 时间复杂度太差</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] topKSum2(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// dp[i][j]</span></span><br><span class="line">        <span class="comment">// 1) dp[i-1][j]</span></span><br><span class="line">        <span class="comment">// 2) dp[i-1][j-nums[i]</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[sum + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> sum; j &gt;= num; j--) &#123;</span><br><span class="line">                dp[j] += dp[j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= sum &amp;&amp; index &lt; k; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; dp[j] &amp;&amp; index &lt; k; i++) &#123;</span><br><span class="line">                ans[index++] = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正式方法 （ 左神答案）</span></span><br><span class="line">    <span class="comment">// 用堆来做是最优解，时间复杂度O(n * log n) + O(k * log k)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] topKSum3(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="comment">// (子序列的最右下标，子序列的累加和)</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">        heap.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">0</span>, nums[<span class="number">0</span>] &#125;);</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="type">int</span>[] cur = heap.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> cur[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> cur[<span class="number">1</span>];</span><br><span class="line">            ans[i] = sum;</span><br><span class="line">            <span class="keyword">if</span> (right + <span class="number">1</span> &lt; nums.length) &#123;</span><br><span class="line">                heap.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; right + <span class="number">1</span>, sum - nums[right] + nums[right + <span class="number">1</span>] &#125;);</span><br><span class="line">                heap.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; right + <span class="number">1</span>, sum + nums[right + <span class="number">1</span>] &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有点点思路，先小到大排序。</span></span><br><span class="line">    <span class="comment">//前两位都是自己，第3位是sums[2] pk nums[i].第4位呢？找不到联系，直接看答案了！！</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//（根据左神答案思路写的）</span></span><br><span class="line">    <span class="comment">//答案思路是用堆做的。其实一开始也直观的想到将数据排序，然后将每个数放入堆中排序。 但是在处理每个数之间组合的和值时，却往dp方向去想。这里思路错了</span></span><br><span class="line">    <span class="comment">//目的是将每个数组合的和值放入堆中排序，怎么加速这个过程呢？</span></span><br><span class="line">    <span class="comment">//答案在堆中巧妙的处理了： 核心思路，堆中记录 子序列最右下标和 和值</span></span><br><span class="line">    <span class="comment">//1、直接加入当前数，记录下标和和值，入堆</span></span><br><span class="line">    <span class="comment">//2、减去上次最右下标数字，再加上当前数，记录下标和和值，入堆</span></span><br><span class="line">    <span class="comment">//经过上面两个步骤，堆中即可得到1...i所有组合和值。  就是这么巧妙，不懂到底咋想到的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] topKSum0(<span class="type">int</span>[] nums, <span class="type">int</span> k)&#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按和值排序 小到大</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">        <span class="comment">//默认第一个数是空序列，和值0</span></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//放入第一个数字</span></span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, nums[<span class="number">0</span>]&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; index &lt; k)&#123;</span><br><span class="line">            <span class="type">int</span>[] cur = queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> cur[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> cur[<span class="number">1</span>];</span><br><span class="line">            ans[index++] = sum;</span><br><span class="line">            <span class="keyword">if</span> (right  + <span class="number">1</span> &lt; nums.length)&#123;</span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;right + <span class="number">1</span>, sum - nums[right] + nums[right + <span class="number">1</span>]&#125;);<span class="comment">//减去上一个最右坐标数字，再加上当前数</span></span><br><span class="line">                queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;right + <span class="number">1</span>, sum + nums[right + <span class="number">1</span>]&#125;);<span class="comment">//直接加上当前数</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴力方法</span></span><br><span class="line">    <span class="comment">// 为了验证</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] topKSum1(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        ArrayList&lt;Integer&gt; allSubsequences = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        f1(nums, <span class="number">0</span>, <span class="number">0</span>, allSubsequences);</span><br><span class="line">        allSubsequences.sort((a, b) -&gt; a.compareTo(b));</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            ans[i] = allSubsequences.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴力方法</span></span><br><span class="line">    <span class="comment">// 得到所有子序列的和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index, <span class="type">int</span> sum, ArrayList&lt;Integer&gt; ans)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line">            ans.add(sum);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f1(nums, index + <span class="number">1</span>, sum, ans);</span><br><span class="line">            f1(nums, index + <span class="number">1</span>, sum + nums[index], ans);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] randomArray(<span class="type">int</span> len, <span class="type">int</span> value) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            ans[i] = (<span class="type">int</span>) (Math.random() * value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(<span class="type">int</span>[] ans1, <span class="type">int</span>[] ans2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ans1.length != ans2.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ans1.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans1[i] != ans2[i]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了测试</span></span><br><span class="line">    <span class="comment">// 对数器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">testTime</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试开始&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * n) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span>[] nums = randomArray(len, v);</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * ((<span class="number">1</span> &lt;&lt; len) - <span class="number">1</span>)) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span>[] ans1 = topKSum1(nums, k);</span><br><span class="line">            <span class="type">int</span>[] ans2 = topKSum2(nums, k);</span><br><span class="line">            <span class="type">int</span>[] ans3 = topKSum3(nums, k);</span><br><span class="line">            <span class="type">int</span>[] ans0 = topKSum0(nums, k);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!equals(ans1, ans0)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;出错了！&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//            if (!equals(ans1, ans2) || !equals(ans1, ans3)) &#123;</span></span><br><span class="line"><span class="comment">//                System.out.println(&quot;出错了！&quot;);</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 零一背包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 零一背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DependentKnapsack</title>
      <link href="/2024/11/28/DependentKnapsack/"/>
      <url>/2024/11/28/DependentKnapsack/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.背包.零一背包;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/11/28 17:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有依赖的背包(模版)</span></span><br><span class="line"><span class="comment">// 物品分为两大类：主件和附件</span></span><br><span class="line"><span class="comment">// 主件的购买没有限制，钱够就可以；附件的购买有限制，该附件所归属的主件先购买，才能购买这个附件</span></span><br><span class="line"><span class="comment">// 例如，若想买打印机或扫描仪这样的附件，必须先购买电脑这个主件</span></span><br><span class="line"><span class="comment">// 以下是一些主件及其附件的展示：</span></span><br><span class="line"><span class="comment">// 电脑：打印机，扫描仪 | 书柜：图书 | 书桌：台灯，文具 | 工作椅：无附件</span></span><br><span class="line"><span class="comment">// 每个主件最多有2个附件，并且附件不会再有附件，主件购买后，怎么去选择归属附件完全随意，钱够就可以</span></span><br><span class="line"><span class="comment">// 所有的物品编号都在1~m之间，每个物品有三个信息：价格v、重要度p、归属q</span></span><br><span class="line"><span class="comment">// 价格就是花费，价格 * 重要度 就是收益，归属就是该商品是依附于哪个编号的主件</span></span><br><span class="line"><span class="comment">// 比如一件商品信息为[300,2,6]，花费300，收益600，该商品是6号主件商品的附件</span></span><br><span class="line"><span class="comment">// 再比如一件商品信息[100,4,0]，花费100，收益400，该商品自身是主件(q==0)</span></span><br><span class="line"><span class="comment">// 给定m件商品的信息，给定总钱数n，返回在不违反购买规则的情况下最大的收益</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P1064</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.nowcoder.com/practice/f9c6f980eeec43ef85be20755ddbeaf4</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下的所有代码，并把主类名改成&quot;Main&quot;，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DependentKnapsack</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIM</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, m;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;Integer, List&lt;Integer&gt;&gt; masterMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] val = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] weight = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span>[] master = <span class="keyword">new</span> <span class="title class_">boolean</span>[MAIM];<span class="comment">//主物品</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(in);</span><br><span class="line">        <span class="keyword">while</span> (st.nextToken() != StreamTokenizer.TT_EOF)&#123;</span><br><span class="line">            n = (<span class="type">int</span>) st.nval;st.nextToken();<span class="comment">//钱数</span></span><br><span class="line">            m = (<span class="type">int</span>) st.nval;st.nextToken();<span class="comment">//物品个数</span></span><br><span class="line">            masterMap.clear();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, v, w, p; i &lt;= m; i++) &#123;</span><br><span class="line">                v = (<span class="type">int</span>) st.nval;st.nextToken();<span class="comment">//价格</span></span><br><span class="line">                w = (<span class="type">int</span>) st.nval;st.nextToken();<span class="comment">//重要度</span></span><br><span class="line">                p = (<span class="type">int</span>) st.nval;st.nextToken();<span class="comment">//对应主见</span></span><br><span class="line"></span><br><span class="line">                val[i] = v;</span><br><span class="line">                weight[i] = v * w;</span><br><span class="line">                <span class="keyword">if</span> (p != <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//拿目标主键的附属件数组</span></span><br><span class="line">                    List&lt;Integer&gt; list = masterMap.computeIfAbsent(p, k -&gt; <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">                    <span class="comment">//加进当前件</span></span><br><span class="line">                    list.add(i);</span><br><span class="line">                    master[i] = <span class="literal">false</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    master[i] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(compute());</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义dp[i][j] 为 i个主件物品 不超过j钱数情况下，能获得的最大乘积</span></span><br><span class="line">    <span class="comment">//只讨论主商品</span></span><br><span class="line">    <span class="comment">//因为附件最多只有两个，所以直接讨论所有可能性</span></span><br><span class="line">    <span class="comment">//1、dp[i][j] = dp[p][j] //不取当前商品   p为上一个主件</span></span><br><span class="line">    <span class="comment">//2、dp[i][j] = dp[p][j - val[i]] + val[i];  //只要当前主件</span></span><br><span class="line">    <span class="comment">//2、1 dp[i][j] = dp[p][j - val[i] - val[k1] ] + val[i] + val[k1];//取当前主件以及 只拿附件1</span></span><br><span class="line">    <span class="comment">//2、2 dp[i][j] = dp[p][j - val[i] - val[k2] ] + val[i] + val[k2];//取当前主件以及 只拿附件2</span></span><br><span class="line">    <span class="comment">//2、2 dp[i][j] = dp[p][j - val[i] - val[k1] - val[k2] ] + val[i] + val[k1] + val[k2];//取当前主件以及 拿所有附件</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>][n + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只讨论主物品</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (master[i])&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>, k1 = <span class="number">0</span>, k2 = <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                    dp[i][j] = dp[p][j];</span><br><span class="line">                    <span class="keyword">if</span> (j - val[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                        dp[i][j] = Math.max(dp[i][j], dp[p][j - val[i]] + weight[i]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//讨论附件</span></span><br><span class="line">                    List&lt;Integer&gt; list = masterMap.get(i);</span><br><span class="line">                    <span class="keyword">if</span> (list == <span class="literal">null</span>)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> list.size();</span><br><span class="line">                    <span class="keyword">if</span> (size &gt;= <span class="number">1</span>)&#123;</span><br><span class="line">                        k1 = list.get(<span class="number">0</span>);</span><br><span class="line">                        <span class="keyword">if</span> (j - val[i] - val[k1] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                            dp[i][j] = Math.max(dp[i][j], dp[p][j - val[i] - val[k1]] + weight[i] + weight[k1]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (size == <span class="number">2</span>)&#123;</span><br><span class="line">                        k2 = list.get(<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">if</span> (j - val[i] - val[k2] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                            dp[i][j] = Math.max(dp[i][j], dp[p][j - val[i] - val[k2]] + weight[i] + weight[k2]);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (j - val[i] - val[k1] - val[k2] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                            dp[i][j] = Math.max(dp[i][j], dp[p][j - val[i] - val[k1] - val[k2]] + weight[i] + weight[k1] + weight[k2]);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                p = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[p][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 零一背包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 零一背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LastStoneWeightII</title>
      <link href="/2024/11/28/LastStoneWeightII/"/>
      <url>/2024/11/28/LastStoneWeightII/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.背包.零一背包;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * 01背包本身不难，相当于套模板，难得是怎么把问题转换为01背包</span></span><br><span class="line"><span class="comment"> * 这题虽然是中等题，但是确实没想到这个转换</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/11/28 17:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最后一块石头的重量 II</span></span><br><span class="line"><span class="comment">// 有一堆石头，用整数数组 stones 表示</span></span><br><span class="line"><span class="comment">// 其中 stones[i] 表示第 i 块石头的重量。</span></span><br><span class="line"><span class="comment">// 每一回合，从中选出任意两块石头，然后将它们一起粉碎</span></span><br><span class="line"><span class="comment">// 假设石头的重量分别为 x 和 y，且 x &lt;= y</span></span><br><span class="line"><span class="comment">// 那么粉碎的可能结果如下：</span></span><br><span class="line"><span class="comment">// 如果 x == y，那么两块石头都会被完全粉碎；</span></span><br><span class="line"><span class="comment">// 如果 x != y，那么重量为 x 的石头将会完全粉碎，而重量为 y 的石头新重量为 y-x</span></span><br><span class="line"><span class="comment">// 最后，最多只会剩下一块 石头，返回此石头 最小的可能重量</span></span><br><span class="line"><span class="comment">// 如果没有石头剩下，就返回 0</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/last-stone-weight-ii/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LastStoneWeightII</span> &#123;</span><br><span class="line">    <span class="comment">//错误的思路！！！！！！！</span></span><br><span class="line">    <span class="comment">//贪心思路？让每次碰撞后的石头尽可能小 -》 每次让最大的两块去碰撞？ 优先队列?</span></span><br><span class="line">    <span class="comment">//gg，例2就过不了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII0</span><span class="params">(<span class="type">int</span>[] stones)</span> &#123;</span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; b - a);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> stone : stones) &#123;</span><br><span class="line">            queue.add(stone);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (queue.size() &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            queue.add(Math.abs(a - b));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//完全没dp思路呀····</span></span><br><span class="line">    <span class="comment">//突然看到题目是 “最后一块石头“。 想了下还是没思路</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//看了答案，这转换到01背包是真没想到</span></span><br><span class="line">    <span class="comment">//转换：其实就是把数字分为两组，为了得到最小重量，那就两组 数字和 尽可能接近</span></span><br><span class="line">    <span class="comment">//例如1（8 - 7） - （4 - 2） - （1 - 1） -》 （8 + 2 + 1） - （7 + 4 + 1）</span></span><br><span class="line">    <span class="comment">//即只要一组数字，接近整个数组和的一半，那两组相减就最小</span></span><br><span class="line">    <span class="comment">//所以转为：找数组子序列和 小于等于t （t = sum / 2) .  即01背包问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastStoneWeightII</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> stone : nums) &#123;</span><br><span class="line">            sum += stone;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> sum &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//找数组子序列和 &lt;= t的 子序列和</span></span><br><span class="line">        <span class="comment">//定义dp[i][j]为 i个数中，数组子序列和小于等于j的最大值</span></span><br><span class="line">        <span class="comment">//1、dp[i][j] = dp[i - 1][j];  //不取当前数</span></span><br><span class="line">        <span class="comment">//2、dp[i][j] = dp[i - 1][j - nums[i]] + nums[i];// 取当前数，当前数值加上 上一个小于等于 j - nums[i] 的序列和</span></span><br><span class="line">        <span class="comment">//2种取最大值</span></span><br><span class="line">        <span class="comment">//空间压缩  依赖上一行格子 和上一行左边的格子，所以 从右到左更新</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[t + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> t; j &gt;= nums[i]; j--) &#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//较小的那个分组的数组和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">near</span> <span class="operator">=</span> dp[t];</span><br><span class="line">        <span class="comment">//两个分组和相减</span></span><br><span class="line">        <span class="keyword">return</span> sum - near - near;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 零一背包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 零一背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TargetSum</title>
      <link href="/2024/11/28/TargetSum/"/>
      <url>/2024/11/28/TargetSum/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.背包.零一背包;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/11/28 15:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 目标和</span></span><br><span class="line"><span class="comment">// 给你一个非负整数数组 nums 和一个整数 target 。</span></span><br><span class="line"><span class="comment">// 向数组中的每个整数前添加 &#x27;+&#x27; 或 &#x27;-&#x27; ，然后串联起所有整数</span></span><br><span class="line"><span class="comment">// 可以构造一个表达式</span></span><br><span class="line"><span class="comment">// 例如nums=[2, 1]，可以在2之前添加&#x27;+&#x27; ，在1之前添加&#x27;-&#x27;</span></span><br><span class="line"><span class="comment">// 然后串联起来得到表达式 &quot;+2-1&quot; 。</span></span><br><span class="line"><span class="comment">// 返回可以通过上述方法构造的，运算结果等于 target 的不同表达式的数目</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/target-sum/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TargetSum</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//思路过程：一开始直接想01dp，直接卡住了。 一个是负数问题，一个是怎么转换成01dp问题</span></span><br><span class="line">    <span class="comment">//然后就先写暴力递归了</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ps:一开始直接想dp很难想到的话，那就先写出暴力递归</span></span><br><span class="line">    <span class="comment">//暴力递归巨简单，2分钟就出来了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTargetSumWays</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> f(nums, <span class="number">0</span>, <span class="number">0</span>, target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接暴力递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> sum, <span class="type">int</span> target)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> sum == target ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f(nums, i + <span class="number">1</span>, sum + nums[i], target) + f(nums, i + <span class="number">1</span>, sum - nums[i], target);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 普通尝试，记忆化搜索版</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findTargetSumWays2</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="comment">// i, sum -&gt; value（返回值 ）</span></span><br><span class="line">        HashMap&lt;Integer, HashMap&lt;Integer, Integer&gt;&gt; dp = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">return</span> f2(nums, target, <span class="number">0</span>, <span class="number">0</span>, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为累加和可以为负数</span></span><br><span class="line">    <span class="comment">// 所以缓存动态规划表用哈希表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target, <span class="type">int</span> i, <span class="type">int</span> j, HashMap&lt;Integer, HashMap&lt;Integer, Integer&gt;&gt; dp)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> j == target ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp.containsKey(i) &amp;&amp; dp.get(i).containsKey(j)) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp.get(i).get(j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> f2(nums, target, i + <span class="number">1</span>, j + nums[i], dp) + f2(nums, target, i + <span class="number">1</span>, j - nums[i], dp);</span><br><span class="line">        dp.putIfAbsent(i, <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;());</span><br><span class="line">        dp.get(i).put(j, ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp难在和是负数的处理，平移？  平移就是平移，往y轴上移s</span></span><br><span class="line">    <span class="comment">// 普通尝试</span></span><br><span class="line">    <span class="comment">// 严格位置依赖的动态规划</span></span><br><span class="line">    <span class="comment">// 平移技巧</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findTargetSumWays3</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            s += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; -s || target &gt; s) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// -s ~ +s -&gt; 2 * s + 1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">2</span> * s + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 原本的dp[i][j]含义:</span></span><br><span class="line">        <span class="comment">// nums[0...i-1]范围上，已经形成的累加和是sum</span></span><br><span class="line">        <span class="comment">// nums[i...]范围上，每个数字可以标记+或者-</span></span><br><span class="line">        <span class="comment">// 最终形成累加和为target的不同表达式数目</span></span><br><span class="line">        <span class="comment">// 因为sum可能为负数，为了下标不出现负数，</span></span><br><span class="line">        <span class="comment">// &quot;原本的dp[i][j]&quot;由dp表中的dp[i][j + s]来表示</span></span><br><span class="line">        <span class="comment">// 也就是平移操作！</span></span><br><span class="line">        <span class="comment">// 一切&quot;原本的dp[i][j]&quot;一律平移到dp表中的dp[i][j + s]</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m];</span><br><span class="line">        <span class="comment">// 原本的dp[n][target] = 1，平移！</span></span><br><span class="line">        dp[n][target + s] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> -s; j &lt;= s; j++) &#123;<span class="comment">//遍历每个和值范围</span></span><br><span class="line">                <span class="keyword">if</span> (j + nums[i] + s &lt; m) &#123;<span class="comment">//当前数取正数</span></span><br><span class="line">                    <span class="comment">// 原本是 : dp[i][j] = dp[i + 1][j + nums[i]]</span></span><br><span class="line">                    <span class="comment">// 平移！</span></span><br><span class="line">                    dp[i][j + s] = dp[i + <span class="number">1</span>][j + nums[i] + s];<span class="comment">//每一个值和当前值相加</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j - nums[i] + s &gt;= <span class="number">0</span>) &#123;<span class="comment">//当前数取负数</span></span><br><span class="line">                    <span class="comment">// 原本是 : dp[i][j] += dp[i + 1][j - nums[i]]</span></span><br><span class="line">                    <span class="comment">// 平移！</span></span><br><span class="line">                    dp[i][j + s] += dp[i + <span class="number">1</span>][j - nums[i] + s];<span class="comment">//每一个值和当前值相减</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 原本应该返回dp[0][0]</span></span><br><span class="line">        <span class="comment">// 平移！</span></span><br><span class="line">        <span class="comment">// 返回dp[0][0 + s]</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][s];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新思路，转化为01背包问题</span></span><br><span class="line">    <span class="comment">// 思考1:</span></span><br><span class="line">    <span class="comment">// 虽然题目说nums是非负数组，但即使nums中有负数比如[3,-4,2]</span></span><br><span class="line">    <span class="comment">// 因为能在每个数前面用+或者-号</span></span><br><span class="line">    <span class="comment">// 所以[3,-4,2]其实和[3,4,2]会达成一样的结果</span></span><br><span class="line">    <span class="comment">// 所以即使nums中有负数，也可以把负数直接变成正数，也不会影响结果</span></span><br><span class="line">    <span class="comment">// 思考2:</span></span><br><span class="line">    <span class="comment">// 如果nums都是非负数，并且所有数的累加和是sum</span></span><br><span class="line">    <span class="comment">// 那么如果target&gt;sum，很明显没有任何方法可以达到target，可以直接返回0</span></span><br><span class="line">    <span class="comment">// 思考3:</span></span><br><span class="line">    <span class="comment">// nums内部的数组，不管怎么+和-，最终的结果都一定不会改变奇偶性</span></span><br><span class="line">    <span class="comment">// 所以，如果所有数的累加和是sum，并且与target的奇偶性不一样</span></span><br><span class="line">    <span class="comment">// 那么没有任何方法可以达到target，可以直接返回0</span></span><br><span class="line">    <span class="comment">// 思考4(最重要):</span></span><br><span class="line">    <span class="comment">// 比如说给定一个数组, nums = [1, 2, 3, 4, 5] 并且 target = 3</span></span><br><span class="line">    <span class="comment">// 其中一个方案是 : +1 -2 +3 -4 +5 = 3</span></span><br><span class="line">    <span class="comment">// 该方案中取了正的集合为A = &#123;1，3，5&#125;</span></span><br><span class="line">    <span class="comment">// 该方案中取了负的集合为B = &#123;2，4&#125;</span></span><br><span class="line">    <span class="comment">// 所以任何一种方案，都一定有 sum(A) - sum(B) = target</span></span><br><span class="line">    <span class="comment">// 现在我们来处理一下这个等式，把左右两边都加上sum(A) + sum(B)，那么就会变成如下：</span></span><br><span class="line">    <span class="comment">// sum(A) - sum(B) + sum(A) + sum(B) = target + sum(A) + sum(B)</span></span><br><span class="line">    <span class="comment">// 2 * sum(A) = target + 数组所有数的累加和</span></span><br><span class="line">    <span class="comment">// sum(A) = (target + 数组所有数的累加和) / 2</span></span><br><span class="line">    <span class="comment">// 也就是说，任何一个集合，只要累加和是(target + 数组所有数的累加和) / 2</span></span><br><span class="line">    <span class="comment">// 那么就一定对应一种target的方式</span></span><br><span class="line">    <span class="comment">// 比如非负数组nums，target = 1, nums所有数累加和是11</span></span><br><span class="line">    <span class="comment">// 求有多少方法组成1，其实就是求，有多少种子集累加和达到6的方法，(1+11)/2=6</span></span><br><span class="line">    <span class="comment">// 因为，子集累加和6 - 另一半的子集累加和5 = 1(target)</span></span><br><span class="line">    <span class="comment">// 所以有多少个累加和为6的不同集合，就代表有多少个target==1的表达式数量</span></span><br><span class="line">    <span class="comment">// 至此已经转化为01背包问题了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findTargetSumWays4</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : nums) &#123;</span><br><span class="line">            sum += n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target || ((target &amp; <span class="number">1</span>) ^ (sum &amp; <span class="number">1</span>)) == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> subsets(nums, (target + sum) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 求非负数组nums有多少个子序列累加和是t</span></span><br><span class="line">    <span class="comment">// 01背包问题(子集累加和严格是t) + 空间压缩</span></span><br><span class="line">    <span class="comment">// dp[i][j] = dp[i-1][j] + dp[i-1][j-nums[i]]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">subsets</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[t + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123; <span class="comment">// i省略了</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> t; j &gt;= num; j--) &#123;</span><br><span class="line">                dp[j] += dp[j - num];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[t];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 零一背包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 零一背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BuyGoodsHaveDiscount</title>
      <link href="/2024/11/27/BuyGoodsHaveDiscount/"/>
      <url>/2024/11/27/BuyGoodsHaveDiscount/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.背包.零一背包;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/11/27 15:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 夏季特惠</span></span><br><span class="line"><span class="comment">// 某公司游戏平台的夏季特惠开始了，你决定入手一些游戏</span></span><br><span class="line"><span class="comment">// 现在你一共有X元的预算，平台上所有的 n 个游戏均有折扣</span></span><br><span class="line"><span class="comment">// 标号为 i 的游戏的原价a_i元，现价只要b_i元</span></span><br><span class="line"><span class="comment">// 也就是说该游戏可以优惠 a_i - b_i，并且你购买该游戏能获得快乐值为w_i</span></span><br><span class="line"><span class="comment">// 由于优惠的存在，你可能做出一些冲动消费导致最终买游戏的总费用超过预算</span></span><br><span class="line"><span class="comment">// 只要满足 : 获得的总优惠金额不低于超过预算的总金额  -&gt; (a-b) &gt;= b 则满足条件 （）</span></span><br><span class="line"><span class="comment">// 那在心理上就不会觉得吃亏。</span></span><br><span class="line"><span class="comment">// 现在你希望在心理上不觉得吃亏的前提下，获得尽可能多的快乐值。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/tJau2o/</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下的所有代码，并把主类名改成&quot;Main&quot;，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuyGoodsHaveDiscount</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIX</span> <span class="operator">=</span> <span class="number">501</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n,x, m;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] cost = <span class="keyword">new</span> <span class="title class_">int</span>[MAIX];<span class="comment">//购买当前商品会消耗的预算值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span>[] happy = <span class="keyword">new</span> <span class="title class_">long</span>[MAIX];<span class="comment">//商品快乐值</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//简单理解条件：</span></span><br><span class="line">    <span class="comment">//语文不好是真难解析条件的含义</span></span><br><span class="line">    <span class="comment">//一件商品为什么要买呢？ 可以简单理解为 商品优惠 为 增加的预算 -》 所以依据条件 (a-b) &gt;= b 则满足条件</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据给出的条件进行推理：</span></span><br><span class="line">    <span class="comment">//获得的总优惠金额不低于超过预算的总金额 推理 -》 总优惠金额 &gt;= 总超预算金额</span></span><br><span class="line">    <span class="comment">// (a1-b1) + (a2-b2) +... + (ai-bi) &gt;= b1 + b2 + ... + bi - x</span></span><br><span class="line">    <span class="comment">//(a1 - b1 - b1) + (a2-b2 - b2) +... + (ai-bi - bi) + x &gt;= 0</span></span><br><span class="line">    <span class="comment">//令 ai - bi - bi 为zi</span></span><br><span class="line">    <span class="comment">//z1 + z2 + .. + zi + x &gt;= 0</span></span><br><span class="line">    <span class="comment">//若要使得式子成立 -&gt;  如果某个zi 》= 0， 对于不等式是有贡献值的， 即 如果ai - bi - bi &gt;= 0, 则这个商品是对条件有利的，必须买</span></span><br><span class="line">    <span class="comment">//对于zi小于0 对不等式是拖累的， 但总结果上看，不一定不能买</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">sz</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(in);</span><br><span class="line">        <span class="keyword">while</span> (sz.nextToken() != StreamTokenizer.TT_EOF)&#123;</span><br><span class="line">            n = (<span class="type">int</span>) sz.nval;</span><br><span class="line">            sz.nextToken();</span><br><span class="line">            x = (<span class="type">int</span>) sz.nval;</span><br><span class="line">            m = <span class="number">1</span>;<span class="comment">//dp 的 j容量.</span></span><br><span class="line">            sz.nextToken();</span><br><span class="line">            <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">long</span> h;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>,a,b, well; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="comment">//原价</span></span><br><span class="line">                a = (<span class="type">int</span>) sz.nval;sz.nextToken();</span><br><span class="line">                <span class="comment">//现价</span></span><br><span class="line">                b = (<span class="type">int</span>) sz.nval;sz.nextToken();</span><br><span class="line">                <span class="comment">//快乐值</span></span><br><span class="line">                h = (<span class="type">long</span>) sz.nval;sz.nextToken();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//购买当前商品的贡献值</span></span><br><span class="line">                well = a - b - b;</span><br><span class="line">                <span class="keyword">if</span> (well &gt;= <span class="number">0</span>)&#123;<span class="comment">//必买商品,且能增加总预算</span></span><br><span class="line">                    x += well;</span><br><span class="line">                    ans += h;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;<span class="comment">//负贡献值商品，放入数组。 后续计算要不要买</span></span><br><span class="line">                    cost[m] = -well;</span><br><span class="line">                    happy[m++] = h;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += compute();</span><br><span class="line">            out.println(ans);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.flush();</span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义dp[i][j]为 当前i种商品，消耗预算严格为j的情况下，能获取到的最大快乐值</span></span><br><span class="line">    <span class="comment">//1、dp[i][j] =  dp[i - 1][j]; //不拿当前商品</span></span><br><span class="line">    <span class="comment">//2、dp[i][j] = j - cost[i] &gt;= 0 &amp;&amp; dp[i - 1][j - cost[i]] + happy[i]; //拿当前商品，减去当前商品的消耗值，加上快乐值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span>[][] dp = <span class="keyword">new</span> <span class="title class_">long</span>[m + <span class="number">1</span>][x + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= x; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">if</span> (j - cost[i] &gt;= <span class="number">0</span>)&#123;<span class="comment">//前面的结果看有没有符合预算的</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - cost[i]] + happy[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m][x];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空间压缩</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">compute1</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">long</span>[] dp = <span class="keyword">new</span> <span class="title class_">long</span>[x + <span class="number">1</span>];</span><br><span class="line">        Arrays.fill(dp, <span class="number">0</span>, x + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> x; j &gt;= cost[i]; j--) &#123;</span><br><span class="line">                dp[j] = Math.max(dp[j], dp[j - cost[i]] + happy[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[x];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 零一背包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 零一背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Class_01Knapsack</title>
      <link href="/2024/11/27/Class_01Knapsack/"/>
      <url>/2024/11/27/Class_01Knapsack/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.背包.零一背包;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/11/27 11:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 01背包(模版)</span></span><br><span class="line"><span class="comment">// 给定一个正数t，表示背包的容量</span></span><br><span class="line"><span class="comment">// 有m个货物，每个货物可以选择一次</span></span><br><span class="line"><span class="comment">// 每个货物有自己的体积costs[i]和价值values[i]</span></span><br><span class="line"><span class="comment">// 返回在不超过总容量的情况下，怎么挑选货物能达到价值最大</span></span><br><span class="line"><span class="comment">// 返回最大的价值</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P1048</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下的所有代码，并把主类名改成&quot;Main&quot;，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Class_01Knapsack</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> t, n;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIM</span> <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] time = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];<span class="comment">//每种草药化费的时间</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] val = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];<span class="comment">//每种草药价值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">rd</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(rd);</span><br><span class="line">        <span class="keyword">while</span> (st.nextToken() != StreamTokenizer.TT_EOF)&#123;</span><br><span class="line">            t = (<span class="type">int</span>) st.nval;<span class="comment">//总时间</span></span><br><span class="line">            st.nextToken();</span><br><span class="line">            n = (<span class="type">int</span>) st.nval;<span class="comment">//总草药数量</span></span><br><span class="line">            st.nextToken();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;<span class="comment">//注意下标，从1开始</span></span><br><span class="line">                time[i] = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">                val[i] = (<span class="type">int</span>) st.nval;st.nextToken();</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(compute());</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        rd.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义dp[i][j] 为在当前有i种草药下，采摘时间为j的情况下，能获得的最大价值</span></span><br><span class="line">    <span class="comment">//1、dp[i][j] = dp[i - 1][j];//不摘当前第i棵草药</span></span><br><span class="line">    <span class="comment">//2、dp[i][j] = dp[i - 1][j - time[i] ] + val[i];//摘当前草药，为上一个价值 + 当前价值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][t + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= t; j++) &#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];<span class="comment">//不摘当前第i棵草药</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt;= time[i])&#123;<span class="comment">//当前时间大于等于采摘时间时</span></span><br><span class="line">                    dp[i][j] = Math.max(dp[i][j], dp[i - <span class="number">1</span>][j - time[i]] + val[i]) ;<span class="comment">//摘当前草药，为上一个价值 + 当前价值</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][t];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 零一背包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 零一背包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DeleteOneNumberLengthKMaxSum</title>
      <link href="/2024/11/11/DeleteOneNumberLengthKMaxSum/"/>
      <url>/2024/11/11/DeleteOneNumberLengthKMaxSum/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.子数组最大累加和问题扩展;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 子数组最大累加和 + 单调队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/11/11 17:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删掉1个数字后长度为k的子数组最大累加和</span></span><br><span class="line"><span class="comment">// 给定一个数组nums，求必须删除一个数字后的新数组中</span></span><br><span class="line"><span class="comment">// 长度为k的子数组最大累加和，删除哪个数字随意</span></span><br><span class="line"><span class="comment">// 对数器验证</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DeleteOneNumberLengthKMaxSum</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原思路分析</span></span><br><span class="line">    <span class="comment">//定义dp[i]为 长度为0..i - 1的数组 删除1个数子后的子数组最大累加和</span></span><br><span class="line">    <span class="comment">//dp[i] = dp[i - 1] //当前数和当前最大累加和结果没关系，不要当前数</span></span><br><span class="line">    <span class="comment">//dp[i] = nums[i - 1] + (i - k）... i - 1 范围的任意删掉1个数字后的最大子数组累加和</span></span><br><span class="line">    <span class="comment">//怎么得到k-1长度范围的任意删掉1个数字后的最大子数组累加和呢？</span></span><br><span class="line">    <span class="comment">//如果先提前计算每个i为位置结尾的，长度为k的某个数字变为0后的数组的最大和呢？</span></span><br><span class="line">    <span class="comment">//-》 长度为k的子数组，其中有个变成0后的数组和 -》 长度为k - 1个， k-2个，k-3.....3,2,1</span></span><br><span class="line">    <span class="comment">//dp[j] = dp[j-1] + nums[j - 1]; //要当前位，当前位不变0. 前面位置变零</span></span><br><span class="line">    <span class="comment">//dp[j] = sum[j - 1];//不要当前位，当前位变零</span></span><br><span class="line">    <span class="comment">//dp[j] = 两者取最大</span></span><br><span class="line">    <span class="comment">//再用dp[i] 保存当前结果</span></span><br><span class="line">    <span class="comment">// -》 得到每个位置下， 长度为k的子数组，其中有个变成0后的数组和</span></span><br><span class="line">    <span class="comment">//怎么感觉就是二维dp啊···但是如果是二维，还不是直接暴力求，也是O(n2)</span></span><br><span class="line">    <span class="comment">//其实就是卡在了 “怎么得到k-1长度范围的任意删掉1个数字后的最大子数组累加和呢？”</span></span><br><span class="line">    <span class="comment">//感觉就很像用单调队列存储答案。   直接看左神吧</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//左神思路 -》 用单调队列求解dp[j],即保持窗口内的最小值，dp[i]的值为sum[i] - min</span></span><br><span class="line">    <span class="comment">//总体流程，保持原数组k + 1长度的数组和，减去区间内的最小值，即为该区间的子数组最大累加和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSum0</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保持k + 1范围内的最小值</span></span><br><span class="line">        <span class="type">int</span>[] window = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">//遍历求解每个区间的子数组最大累加和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//单调队列，保持区间内的最小值</span></span><br><span class="line">            <span class="comment">//比当前窗口最右边值小，当前队列右边出去</span></span><br><span class="line">            <span class="keyword">while</span> (r &gt; l &amp;&amp; nums[window[r - <span class="number">1</span>]] &gt;= nums[i])&#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;</span><br><span class="line">            window[r++] = i;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="comment">//如果长度够了，统计当前区间的子数组最大累加和</span></span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k)&#123;</span><br><span class="line">                ans = Math.max(ans, (<span class="type">int</span>) (sum - nums[window[l]]));</span><br><span class="line">                <span class="comment">//队列左边的位置过期了，要更新</span></span><br><span class="line">                <span class="keyword">if</span> (i - k == window[l])&#123;</span><br><span class="line">                    l++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//删除数组最左边的值</span></span><br><span class="line">                sum -= nums[i - k];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴力方法</span></span><br><span class="line">    <span class="comment">// 为了测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSum1</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= k) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span>[] rest = delete(nums, i);</span><br><span class="line">            ans = Math.max(ans, lenKmaxSum(rest, k));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴力方法</span></span><br><span class="line">    <span class="comment">// 为了测试</span></span><br><span class="line">    <span class="comment">// 删掉index位置的元素，然后返回新数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] delete(<span class="type">int</span>[] nums, <span class="type">int</span> index) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (j != index) &#123;</span><br><span class="line">                ans[i++] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴力方法</span></span><br><span class="line">    <span class="comment">// 为了测试</span></span><br><span class="line">    <span class="comment">// 枚举每一个子数组找到最大累加和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">lenKmaxSum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n - k; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i, cnt = <span class="number">0</span>; cnt &lt; k; j++, cnt++) &#123;</span><br><span class="line">                cur += nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了测试</span></span><br><span class="line">    <span class="comment">// 生成长度为n，值在[-v, +v]之间的随机数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] randomArray(<span class="type">int</span> n, <span class="type">int</span> v) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans[i] = (<span class="type">int</span>) (Math.random() * (<span class="number">2</span> * v + <span class="number">1</span>)) - v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了测试</span></span><br><span class="line">    <span class="comment">// 对数器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">testTimes</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试开始&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTimes; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * n) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span>[] nums = randomArray(len, v);</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * n) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> maxSum1(nums, k);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> maxSum0(nums, k);</span><br><span class="line">            <span class="keyword">if</span> (ans1 != ans2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;出错了!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 子数组最大累加和问题扩展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 子数组最大累加和问题扩展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReverseArraySubarrayMaxSum</title>
      <link href="/2024/11/05/ReverseArraySubarrayMaxSum/"/>
      <url>/2024/11/05/ReverseArraySubarrayMaxSum/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.子数组最大累加和问题扩展;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/11/5 14:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可以翻转1次的情况下子数组最大累加和</span></span><br><span class="line"><span class="comment">// 给定一个数组nums，</span></span><br><span class="line"><span class="comment">// 现在允许你随意选择数组连续一段进行翻转，也就是子数组逆序的调整</span></span><br><span class="line"><span class="comment">// 比如翻转[1,2,3,4,5,6]的[2~4]范围，得到的是[1,2,5,4,3,6]</span></span><br><span class="line"><span class="comment">// 返回必须随意翻转1次之后，子数组的最大累加和</span></span><br><span class="line"><span class="comment">// 对数器验证</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReverseArraySubarrayMaxSum</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原想法逻辑</span></span><br><span class="line">    <span class="comment">//直接定义dp[i][j]为长度为i范围内，翻转j次能得到的最大子数组和，j &lt;= 1;</span></span><br><span class="line">    <span class="comment">//枚举dp[i][j]</span></span><br><span class="line">    <span class="comment">//j == 0:</span></span><br><span class="line">    <span class="comment">//dp[i][j] = Math.max(dp[i - 1][j] + nums[i - 1], dp[i - 1][j]);//保持长度为i的最大子数组和</span></span><br><span class="line">    <span class="comment">//j == 1：</span></span><br><span class="line">    <span class="comment">//dp[i][j] = dp[i - 1][j] + nums[i - 1];  //当次不翻转（前面翻转了），直接加上当前数</span></span><br><span class="line">    <span class="comment">//dp[i][j] = dp[i - 1][j - 1]; //当次翻转不要当前数值，加上前面不翻转的值. j&gt;0</span></span><br><span class="line">    <span class="comment">//dp[i][j] = 两情况取最大</span></span><br><span class="line">    <span class="comment">//ans = 全局最大</span></span><br><span class="line">    <span class="comment">//主要思路就是，（分析怎么拿到最大数组和得到）</span></span><br><span class="line">    <span class="comment">//1、要么不取当前数，直接翻转拿前i-1位的最大子数组和</span></span><br><span class="line">    <span class="comment">//2、 要么取当前数，当次不翻转，直接加上前面的结果</span></span><br><span class="line">    <span class="comment">//2种情况取最大</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSumReverse0</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="comment">//因为子数组和不能是空数组</span></span><br><span class="line">        <span class="comment">//所以如果没有正数，直接返回最大的数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">hasZ</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max &lt; num)&#123;</span><br><span class="line">                max = num;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                hasZ = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!hasZ) &#123;</span><br><span class="line">            <span class="keyword">return</span> max;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里其实就是求子数组最大和</span></span><br><span class="line">        <span class="comment">//简化代码 一维dp</span></span><br><span class="line">        <span class="comment">//主要思路就是，（分析怎么拿到最大数组和得到）</span></span><br><span class="line">        <span class="comment">//1、要么不取当前数，直接翻转拿前i-1位的最大子数组和</span></span><br><span class="line">        <span class="comment">//2、 要么取当前数，当次不翻转，直接加上前面的结果</span></span><br><span class="line">        <span class="comment">//2种情况取最大</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, premax = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] maxsum = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//取前i个最大子数组和</span></span><br><span class="line">            premax = Math.max(premax + nums[i - <span class="number">1</span>], nums[i - <span class="number">1</span>]);</span><br><span class="line">            maxsum[i] = Math.max(premax, maxsum[i - <span class="number">1</span>]);</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];<span class="comment">//要当前数，当次不翻转(前面可能翻转或者不翻转）</span></span><br><span class="line">            dp[i] = Math.max(dp[i], maxsum[i - <span class="number">1</span>]);<span class="comment">//不要当前数，当次翻转，取前i-1个最大子数组和。 并和上一种情况取最大</span></span><br><span class="line">            <span class="keyword">if</span> (ans &lt; dp[i]) &#123;</span><br><span class="line">                ans = dp[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//原代码逻辑 二维dp</span></span><br><span class="line"><span class="comment">//        int[][] dp = new int[nums.length + 1][2];</span></span><br><span class="line">        <span class="comment">//当j == 0时，dp[i][j]为数组前缀和</span></span><br><span class="line"><span class="comment">//        for (int i = 1; i &lt;= nums.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//            for (int j = 0; j &lt; 2; j++) &#123;</span></span><br><span class="line"><span class="comment">//                //取前i个最大子数组和</span></span><br><span class="line"><span class="comment">//                if (j == 0) &#123;</span></span><br><span class="line"><span class="comment">//                    premax =  Math.max(premax + nums[i - 1], nums[i - 1]);</span></span><br><span class="line"><span class="comment">//                    dp[i][j] = Math.max(premax, dp[i - 1][j]);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                if (j == 1) &#123;</span></span><br><span class="line"><span class="comment">//                    dp[i][j] = dp[i - 1][j] + nums[i - 1];//要当前数，当次不翻转(前面可能翻转或者不翻转）</span></span><br><span class="line"><span class="comment">//                    dp[i][j] = Math.max(dp[i][j], dp[i - 1][j - 1]);//不要当前数，当次翻转，取前i-1个最大子数组和。 并和上一种情况取最大</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                if (ans &lt; dp[i][j])&#123;</span></span><br><span class="line"><span class="comment">//                    ans = dp[i][j];</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左神思路原代码</span></span><br><span class="line">    <span class="comment">// 正式方法</span></span><br><span class="line">    <span class="comment">// 时间复杂度O(n)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSumReverse2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// start[i] : 所有必须以i开头的子数组中，最大累加和是多少</span></span><br><span class="line">        <span class="type">int</span>[] start = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        start[n - <span class="number">1</span>] = nums[n - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// nums[i]</span></span><br><span class="line">            <span class="comment">// nums[i] + start[i+1]</span></span><br><span class="line">            start[i] = Math.max(nums[i], nums[i] + start[i + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> start[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// end : 子数组必须以i-1结尾，其中的最大累加和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// maxEnd :</span></span><br><span class="line">        <span class="comment">// 0~i-1范围上，</span></span><br><span class="line">        <span class="comment">// 子数组必须以0结尾，其中的最大累加和</span></span><br><span class="line">        <span class="comment">// 子数组必须以1结尾，其中的最大累加和</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 子数组必须以i-1结尾，其中的最大累加和</span></span><br><span class="line">        <span class="comment">// 所有情况中，最大的那个累加和就是maxEnd</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxEnd</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// maxend   i....</span></span><br><span class="line">            <span class="comment">// 枚举划分点 i...</span></span><br><span class="line">            ans = Math.max(ans, maxEnd + start[i]);</span><br><span class="line">            <span class="comment">// 子数组必须以i结尾，其中的最大累加和</span></span><br><span class="line">            end = Math.max(nums[i], end + nums[i]);</span><br><span class="line">            maxEnd = Math.max(maxEnd, end);</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(ans, maxEnd);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴力方法</span></span><br><span class="line">    <span class="comment">// 为了验证</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSumReverse1</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; nums.length; l++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> l; r &lt; nums.length; r++) &#123;</span><br><span class="line">                reverse(nums, l, r);</span><br><span class="line">                ans = Math.max(ans, maxSum(nums));</span><br><span class="line">                reverse(nums, l, r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nums[l...r]范围上的数字进行逆序调整</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> nums[l];</span><br><span class="line">            nums[l++] = nums[r];</span><br><span class="line">            nums[r--] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回子数组最大累加和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSum</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, pre = nums[<span class="number">0</span>]; i &lt; n; i++) &#123;</span><br><span class="line">            pre = Math.max(nums[i], pre + nums[i]);</span><br><span class="line">            ans = Math.max(ans, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了测试</span></span><br><span class="line">    <span class="comment">// 生成随机数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] randomArray(<span class="type">int</span> n, <span class="type">int</span> v) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans[i] = (<span class="type">int</span>) (Math.random() * (v * <span class="number">2</span> + <span class="number">1</span>)) - v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了测试</span></span><br><span class="line">    <span class="comment">// 对数器 file</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">200</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">testTime</span> <span class="operator">=</span> <span class="number">20000</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试开始&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * n) + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//            int len = 10;</span></span><br><span class="line">            <span class="type">int</span>[] arr = randomArray(len, v);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> maxSumReverse2(arr);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> maxSumReverse0(arr);</span><br><span class="line">            <span class="keyword">if</span> (ans1 != ans2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;出错了!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main1</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">        maxSumReverse0(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 子数组最大累加和问题扩展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 子数组最大累加和问题扩展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MaxSumOfThreeSubarrays</title>
      <link href="/2024/11/04/MaxSumOfThreeSubarrays/"/>
      <url>/2024/11/04/MaxSumOfThreeSubarrays/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.子数组最大累加和问题扩展;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/11/4 16:58</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 三个无重叠子数组的最大和</span></span><br><span class="line"><span class="comment">// 给你一个整数数组 nums 和一个整数 k</span></span><br><span class="line"><span class="comment">// 找出三个长度为 k 、互不重叠、且全部数字和（3 * k 项）最大的子数组</span></span><br><span class="line"><span class="comment">// 并返回这三个子数组</span></span><br><span class="line"><span class="comment">// 以下标的数组形式返回结果，数组中的每一项分别指示每个子数组的起始位置</span></span><br><span class="line"><span class="comment">// 如果有多个结果，返回字典序最小的一个</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/maximum-sum-of-3-non-overlapping-subarrays/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxSumOfThreeSubarrays</span> &#123;</span><br><span class="line">    <span class="comment">//ps:原思路， 二维dp，比较复杂！！！！！！</span></span><br><span class="line">    <span class="comment">//有点思路噢</span></span><br><span class="line">    <span class="comment">//一开始最先想到暴力遍历，直接3边for循环</span></span><br><span class="line">    <span class="comment">//然后想着该怎么优化这个遍历，-》 很多重复遍历 -》 优化重复遍历 -》 记忆化搜索 -》 从后往前dp</span></span><br><span class="line">    <span class="comment">//定义dp[i][j]为 i..len位置上，至少为j个长度为k数组的最大子数组</span></span><br><span class="line">    <span class="comment">//关键在于取不取当前位置i</span></span><br><span class="line">    <span class="comment">//dp[i][j] = dp[i - 1][j]   不取当前位置</span></span><br><span class="line">    <span class="comment">//i + k &lt;= len:</span></span><br><span class="line">    <span class="comment">//dp[i][j] = sum(nums[i..k]) + dp[i + k][j - 1] // 因为取了当前位置开头的一个子数组，所以后面要取j - 1个子数组</span></span><br><span class="line">    <span class="comment">//两种情况取最大，并记录位置到位置数组中</span></span><br><span class="line">    <span class="comment">//怎么记录结果位置呢？用额外的数组记录每一个dp[i][j]所关联的位置？</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] maxSumOfThreeSubarrays0(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">//先弄前缀和数组</span></span><br><span class="line">        <span class="comment">//i 为从后往前的长度</span></span><br><span class="line">        <span class="type">int</span>[] presum = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            presum[i] = presum[i - <span class="number">1</span>] + nums[n - i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//记录dp关联的位置</span></span><br><span class="line">        Map&lt;String, List&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//i 为长度， j为至少组成的子数组个数</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][<span class="number">4</span>];</span><br><span class="line">        <span class="comment">//先初始化dp</span></span><br><span class="line">        <span class="comment">//i &lt; k 的都为0， j = 0都为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; k)&#123;</span><br><span class="line">                Arrays.fill(dp[i], <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>, l = <span class="number">0</span>, m = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//直接从长度为k开始遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k, sum; i &lt;= n; i++) &#123;</span><br><span class="line">            sum = presum[i] - presum[i - k];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>, ni,nj; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                <span class="comment">//前缀和为i长度 和 前缀和为i - k长度差值，即当前子数组和</span></span><br><span class="line">                <span class="comment">//不取当前位置开头的子数组</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                List&lt;Integer&gt; list = map.getOrDefault(i + <span class="string">&quot;_&quot;</span> + j, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">                <span class="comment">//取当前位置开头子数组</span></span><br><span class="line">                ni = i - k;</span><br><span class="line">                nj = j - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//这里相等时也要更新（题目要求字典序最小）</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i][j] &lt;= sum + dp[ni][nj])&#123;</span><br><span class="line">                    dp[i][j] = sum + dp[ni][nj];</span><br><span class="line">                    <span class="comment">//新增当前位置</span></span><br><span class="line">                    list.add(n - i);</span><br><span class="line">                    <span class="comment">//新增之前的位置</span></span><br><span class="line">                    list.addAll(map.getOrDefault(ni + <span class="string">&quot;_&quot;</span> + nj, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()));</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//不取当前位置时，位置结果取上一个结果</span></span><br><span class="line">                    ni = i - <span class="number">1</span>;</span><br><span class="line">                    nj = j;</span><br><span class="line">                    list.addAll(map.getOrDefault(ni + <span class="string">&quot;_&quot;</span> + nj, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;()));</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(i + <span class="string">&quot;_&quot;</span> + j, list);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//更新答案</span></span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">3</span> &amp;&amp; list.size() == <span class="number">3</span> &amp;&amp; max &lt;= dp[i][j])&#123;</span><br><span class="line">                    l = list.get(<span class="number">0</span>);</span><br><span class="line">                    m = list.get(<span class="number">1</span>);</span><br><span class="line">                    r = list.get(<span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;l,m,r&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左神思路。 代码是根据思路自己写的</span></span><br><span class="line">    <span class="comment">//针对 3个子数组 去分解为 左）中 )右 中找一个最大和的子数组即可</span></span><br><span class="line">    <span class="comment">//即枚举长度为k的子数组中，左max + 当前中间枚举子数组（长度为k） + 右max</span></span><br><span class="line">    <span class="comment">//全局取最大答案</span></span><br><span class="line">    <span class="comment">//所以问题简化为0..i范围找长度为k的最大和子数组</span></span><br><span class="line">    <span class="comment">//定义dp[i]为0..i - 1范围内长度为k的最大和子数组</span></span><br><span class="line">    <span class="comment">//dp[i] = Math.max(dp[i-1], sum(i-k,i)), 即用之前的最大和子数组 与 当前i-k..i范围的子数组和做对比，取最大。</span></span><br><span class="line">    <span class="comment">//那怎么记录每个最大和子数组的开始位置呢？</span></span><br><span class="line">    <span class="comment">//另外用一个数组记录每个最大和子数组的开始位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] maxSumOfThreeSubarrays1(<span class="type">int</span>[] nums, <span class="type">int</span> k)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">//求长度为k的数组前缀和，这里的索引表示长度</span></span><br><span class="line">        <span class="type">int</span>[] sums = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>, l = <span class="number">0</span>, sum = <span class="number">0</span>; r &lt; n; l++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (r - l + <span class="number">1</span> &lt;= k)&#123;</span><br><span class="line">                sum += nums[r++];</span><br><span class="line">            &#125;</span><br><span class="line">            sums[r] = sum;</span><br><span class="line">            sum -= nums[l];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求0....i - 1范围长度为k的最大和子数组</span></span><br><span class="line">        <span class="comment">//记录数组开始位置</span></span><br><span class="line">        <span class="type">int</span>[] preIndex = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] prefix = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//这里i代表长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> k; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prefix[i - <span class="number">1</span>] &gt;= sums[i])&#123;</span><br><span class="line">                prefix[i] = prefix[i - <span class="number">1</span>];</span><br><span class="line">                preIndex[i] = preIndex[i - <span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                prefix[i] = sums[i];</span><br><span class="line">                preIndex[i] = i - k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求n....i范围长度为k的最大和子数组 (从后往前数）</span></span><br><span class="line">        <span class="comment">//记录数组开始位置</span></span><br><span class="line">        <span class="type">int</span>[] sufIndex = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span>[] suffix = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];<span class="comment">//包含0长度，即n位置时，一个不取</span></span><br><span class="line">        <span class="comment">//这里的i代表索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - k; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (suffix[i + <span class="number">1</span>] &gt; sums[i + k])&#123;</span><br><span class="line">                suffix[i] = suffix[i + <span class="number">1</span>];</span><br><span class="line">                sufIndex[i] = sufIndex[i + <span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                suffix[i] = sums[i + k];</span><br><span class="line">                sufIndex[i] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>, a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//枚举i..j 长度为k</span></span><br><span class="line">        <span class="comment">//这里的l,r代表索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> k, r = <span class="number">2</span> * k - <span class="number">1</span>, sum; r &lt; n - k; r++, l++) &#123;</span><br><span class="line">            <span class="comment">//左边最大 + 当前k长度子数组和 + 右边最大</span></span><br><span class="line">            sum = prefix[l] + sums[r + <span class="number">1</span>] + suffix[r + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (max &lt; sum)&#123;</span><br><span class="line">                max = sum;</span><br><span class="line">                a = preIndex[l];</span><br><span class="line">                b = l;</span><br><span class="line">                c = sufIndex[r + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;a,b,c&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是左神原代码，dp只记录开始位置，更简洁</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] maxSumOfThreeSubarrays(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="comment">// sums[i] : 以i开头并且长度为k的子数组的累加和</span></span><br><span class="line">        <span class="type">int</span>[] sums = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>, sum = <span class="number">0</span>; r &lt; n; r++) &#123;</span><br><span class="line">            <span class="comment">// l....r</span></span><br><span class="line">            sum += nums[r];</span><br><span class="line">            <span class="keyword">if</span> (r - l + <span class="number">1</span> == k) &#123;</span><br><span class="line">                sums[l] = sum;</span><br><span class="line">                sum -= nums[l];</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// prefix[i] :</span></span><br><span class="line">        <span class="comment">// 0~i范围上所有长度为k的子数组中，拥有最大累加和的子数组，是以什么位置开头的</span></span><br><span class="line">        <span class="type">int</span>[] prefix = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>, r = k; r &lt; n; l++, r++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sums[l] &gt; sums[prefix[r - <span class="number">1</span>]]) &#123;</span><br><span class="line">                <span class="comment">// 注意&gt;，为了同样最大累加和的情况下，最小的字典序</span></span><br><span class="line">                prefix[r] = l;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                prefix[r] = prefix[r - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// suffix[i] :</span></span><br><span class="line">        <span class="comment">// i~n-1范围上所有长度为k的子数组中，拥有最大累加和的子数组，是以什么位置开头的</span></span><br><span class="line">        <span class="type">int</span>[] suffix = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        suffix[n - k] = n - k;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> n - k - <span class="number">1</span>; l &gt;= <span class="number">0</span>; l--) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sums[l] &gt;= sums[suffix[l + <span class="number">1</span>]]) &#123;</span><br><span class="line">                <span class="comment">// 注意&gt;=，为了同样最大累加和的情况下，最小的字典序</span></span><br><span class="line">                suffix[l] = l;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                suffix[l] = suffix[l + <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>, max = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 0...i-1    i...j    j+1...n-1</span></span><br><span class="line">        <span class="comment">//   左     中(长度为k)     右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> p, s, i = k, j = <span class="number">2</span> * k - <span class="number">1</span>, sum; j &lt; n - k; i++, j++) &#123;</span><br><span class="line">            <span class="comment">// 0.....i-1   i.....j  j+1.....n-1</span></span><br><span class="line">            <span class="comment">// 最好开头p      i开头     最好开头s</span></span><br><span class="line">            p = prefix[i - <span class="number">1</span>];</span><br><span class="line">            s = suffix[j + <span class="number">1</span>];</span><br><span class="line">            sum = sums[p] + sums[i] + sums[s];</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; max) &#123;</span><br><span class="line">                <span class="comment">// 注意&gt;，为了同样最大累加和的情况下，最小的字典序</span></span><br><span class="line">                max = sum;</span><br><span class="line">                a = p;</span><br><span class="line">                b = i;</span><br><span class="line">                c = s;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; a, b, c &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> <span class="string">&quot;2.0&quot;</span>.split(<span class="string">&quot;\\.&quot;</span>)[<span class="number">0</span>];</span><br><span class="line">        System.out.println(Integer.parseInt(s));</span><br><span class="line"><span class="comment">//        maxSumOfThreeSubarrays(new int[]&#123;4,3,2,1&#125;, 1);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 子数组最大累加和问题扩展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 子数组最大累加和问题扩展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MagicScrollProbelm</title>
      <link href="/2024/10/29/MagicScrollProbelm/"/>
      <url>/2024/10/29/MagicScrollProbelm/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.子数组最大累加和问题扩展;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/10/29 15:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 魔法卷轴</span></span><br><span class="line"><span class="comment">// 给定一个数组nums，其中可能有正、负、0</span></span><br><span class="line"><span class="comment">// 每个魔法卷轴可以把nums中连续的一段全变成0</span></span><br><span class="line"><span class="comment">// 你希望数组整体的累加和尽可能大</span></span><br><span class="line"><span class="comment">// 卷轴使不使用、使用多少随意，但一共只有2个魔法卷轴</span></span><br><span class="line"><span class="comment">// 请返回数组尽可能大的累加和</span></span><br><span class="line"><span class="comment">// 对数器验证</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MagicScrollProbelm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误的分析！！！！！！！！！</span></span><br><span class="line">    <span class="comment">//求某一段数组和的极大值</span></span><br><span class="line">    <span class="comment">//其中有个变量是魔法卷轴。 当使用卷轴和不使用时的极大值不一样，所以要把魔法卷轴考虑进dp里</span></span><br><span class="line">    <span class="comment">//定义dp[i][j]为 长度为i的数组中（0...i-1)，包含当前i-1位置的连续的，最大累加和</span></span><br><span class="line">    <span class="comment">//所以讨论为：1、当前位置必取的，但取不取前面的结果？ 2、用不用魔法卷轴</span></span><br><span class="line">    <span class="comment">//1、dp[i][j] = dp[i - 1][j] + nums[i - 1]  //不用魔法卷轴，正常相加</span></span><br><span class="line">    <span class="comment">//2、用魔法卷轴，消除0..i - 1位置的极小和值</span></span><br><span class="line">    <span class="comment">//dp[i][j + 1] = dp[i - 1][j] + min(i); （ j &lt; 2)</span></span><br><span class="line">    <span class="comment">//分析有误，不全。不知道怎么继续下去了，直接看答案</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//看了答案后的分析</span></span><br><span class="line">    <span class="comment">//很直接，直接将卷轴的使用次数分情况讨论。 0次，1次，2次</span></span><br><span class="line">    <span class="comment">//0次： 直接统计数组和</span></span><br><span class="line">    <span class="comment">//1次：</span></span><br><span class="line">    <span class="comment">//定义dp[i] 为长度为i时，使用一次卷轴情况下的最大累加和</span></span><br><span class="line">    <span class="comment">//1、dp[i - 1] + nums[i - 1];//当前不使用卷轴</span></span><br><span class="line">    <span class="comment">//2、  presummax; //当前位置使用一次卷轴，往前压缩到数组前缀和最大值</span></span><br><span class="line">    <span class="comment">//dp[i] = Math.max(dp[i - 1] + nums[i - 1], presummax);</span></span><br><span class="line">    <span class="comment">//2次：</span></span><br><span class="line">    <span class="comment">//定义在[0..i - 1]位置使用了一次卷轴，在[i, len]位置使用了另一次卷轴</span></span><br><span class="line">    <span class="comment">//结果就是区间的左右两边各自统计使用1次卷轴下最大累加和的情况，即premax[i], suffix[i]</span></span><br><span class="line">    <span class="comment">//最后枚举每个位置，获取全局最大的premax[i] + suffix[i]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSum2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不用卷轴的情况</span></span><br><span class="line">        <span class="comment">//直接统计数组和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            p1 += num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用1次卷轴的情况</span></span><br><span class="line">        <span class="comment">//数组前缀和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">presum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//数组最大前缀和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">presumMax</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//i为长度</span></span><br><span class="line">        <span class="type">int</span>[] prefix = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            prefix[i] = Math.max(prefix[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>], presumMax);</span><br><span class="line">            presum += nums[i - <span class="number">1</span>];</span><br><span class="line">            presumMax = Math.max(presum, presumMax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> prefix[n];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用2次卷轴的情况</span></span><br><span class="line">        <span class="comment">//直接两次 1种情况的分析</span></span><br><span class="line">        <span class="comment">//从后往前遍历</span></span><br><span class="line">        <span class="comment">//数组前缀和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">suffixsum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//数组最大前缀和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sufsumMax</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//i为长度</span></span><br><span class="line">        <span class="type">int</span>[] suffix = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            suffix[i] = Math.max(suffix[i + <span class="number">1</span>] + nums[i], sufsumMax);</span><br><span class="line">            suffixsum += nums[i];</span><br><span class="line">            sufsumMax = Math.max(suffixsum, sufsumMax);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p3</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">//枚举每个节点使用卷轴时的， 全局最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//这里要注意，因为i为长度，所以prefix是0..i-1位置，suffix是[i..len位置]</span></span><br><span class="line">            <span class="comment">//所以这就是个坑了，还不如一开始就定义i为坐标</span></span><br><span class="line">            p3 = Math.max(p3, prefix[i] + suffix[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.max(p1, Math.max(p2, p3));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左神代码，定义的i为坐标</span></span><br><span class="line">    <span class="comment">// 正式方法</span></span><br><span class="line">    <span class="comment">// 时间复杂度O(n)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSum3</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 情况1 : 完全不使用卷轴</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            p1 += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// prefix[i] : 0~i范围上一定要用1次卷轴的情况下，0~i范围上整体最大累加和多少</span></span><br><span class="line">        <span class="type">int</span>[] prefix = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="comment">// 每一步的前缀和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// maxPresum : 之前所有前缀和的最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxPresum</span> <span class="operator">=</span> Math.max(<span class="number">0</span>, nums[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            prefix[i] = Math.max(prefix[i - <span class="number">1</span>] + nums[i], maxPresum);</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            maxPresum = Math.max(maxPresum, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 情况二 : 必须用1次卷轴</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> prefix[n - <span class="number">1</span>];</span><br><span class="line">        <span class="comment">// suffix[i] : i~n-1范围上一定要用1次卷轴的情况下，i~n-1范围上整体最大累加和多少</span></span><br><span class="line">        <span class="type">int</span>[] suffix = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        sum = nums[n - <span class="number">1</span>];</span><br><span class="line">        maxPresum = Math.max(<span class="number">0</span>, sum);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            suffix[i] = Math.max(nums[i] + suffix[i + <span class="number">1</span>], maxPresum);</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            maxPresum = Math.max(maxPresum, sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 情况二 : 必须用2次卷轴</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">p3</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 枚举所有的划分点i</span></span><br><span class="line">            <span class="comment">// 0~i-1 左</span></span><br><span class="line">            <span class="comment">// i~n-1 右</span></span><br><span class="line">            p3 = Math.max(p3, prefix[i - <span class="number">1</span>] + suffix[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(p1, Math.max(p2, p3));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴力方法</span></span><br><span class="line">    <span class="comment">// 为了测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSum1</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            p1 += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> mustOneScroll(nums, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">p3</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            p3 = Math.max(p3, mustOneScroll(nums, <span class="number">0</span>, i - <span class="number">1</span>) + mustOneScroll(nums, i, n - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(p1, Math.max(p2, p3));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴力方法</span></span><br><span class="line">    <span class="comment">// 为了测试</span></span><br><span class="line">    <span class="comment">// nums[l...r]范围上一定要用一次卷轴情况下的最大累加和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">mustOneScroll</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="comment">// l...r范围上包含a...b范围</span></span><br><span class="line">        <span class="comment">// 如果a...b范围上的数字都变成0</span></span><br><span class="line">        <span class="comment">// 返回剩下数字的累加和</span></span><br><span class="line">        <span class="comment">// 所以枚举所有可能的a...b范围</span></span><br><span class="line">        <span class="comment">// 相当暴力，但是正确</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> l; a &lt;= r; a++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> a; b &lt;= r; b++) &#123;</span><br><span class="line">                <span class="comment">// l...a...b...r</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">curAns</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt; a; i++) &#123;</span><br><span class="line">                    curAns += nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> b + <span class="number">1</span>; i &lt;= r; i++) &#123;</span><br><span class="line">                    curAns += nums[i];</span><br><span class="line">                &#125;</span><br><span class="line">                ans = Math.max(ans, curAns);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] randomArray(<span class="type">int</span> n, <span class="type">int</span> v) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans[i] = (<span class="type">int</span>) (Math.random() * (v * <span class="number">2</span> + <span class="number">1</span>)) - v;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">testTime</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试开始&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * n);</span><br><span class="line">            <span class="type">int</span>[] nums = randomArray(len, v);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> maxSum1(nums);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> maxSum2(nums);</span><br><span class="line">            <span class="keyword">if</span> (ans1 != ans2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;出错了!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 子数组最大累加和问题扩展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 子数组最大累加和问题扩展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MaxSumDividedBy7</title>
      <link href="/2024/10/22/MaxSumDividedBy7/"/>
      <url>/2024/10/22/MaxSumDividedBy7/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.子数组最大累加和问题扩展;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/10/22 15:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子序列累加和必须被7整除的最大累加和</span></span><br><span class="line"><span class="comment">// 给定一个非负数组nums，</span></span><br><span class="line"><span class="comment">// 可以任意选择数字组成子序列，但是子序列的累加和必须被7整除</span></span><br><span class="line"><span class="comment">// 返回最大累加和</span></span><br><span class="line"><span class="comment">// 对数器验证</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxSumDividedBy7</span> &#123;</span><br><span class="line">    <span class="comment">//同余原理：  k = 8,</span></span><br><span class="line">    <span class="comment">//某数a  % k = 3， 要求最终余数是4，a需要再加多少呢？</span></span><br><span class="line">    <span class="comment">//公式：x = (r2 - r1 + k) % k</span></span><br><span class="line">    <span class="comment">//x = (4 - 3 + k) % k</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//原始分析，不正确</span></span><br><span class="line">    <span class="comment">//定义dp[i]为 0..i位置的子序列最大累加和（能被7整除）</span></span><br><span class="line">    <span class="comment">//所以dp[i] = dp[i- 1] + (nums[i] % 7) == b ? nums[i] : 0;</span></span><br><span class="line">    <span class="comment">//b = (7 - dp[i - 1] % 7) % 7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//没思路。。直接看答案吧</span></span><br><span class="line">    <span class="comment">//看了答案，至少应该要想到是二维dp的（因为有个余数一直在变）</span></span><br><span class="line">    <span class="comment">//定义dp[i][j] 为 前i个数能组成的子序列最大累加和。 j代表当前余数</span></span><br><span class="line">    <span class="comment">//所以</span></span><br><span class="line">    <span class="comment">//dp[i][j] = dp[i - 1][j] //不取当前位置时</span></span><br><span class="line">    <span class="comment">//dp[i][j] = dp[i - 1][b] + nums[i]</span></span><br><span class="line">    <span class="comment">//nums[i] % 7的余数a 和 余数b 要构成余数j，利用同余原理得</span></span><br><span class="line">    <span class="comment">//b = (j - nums[i] % 7 + 7) % 7</span></span><br><span class="line">    <span class="comment">//核心思想就是看之前是否有过目标余数的答案</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSum2</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length][<span class="number">7</span>];</span><br><span class="line">        Arrays.fill(dp[<span class="number">0</span>], -<span class="number">1</span>);</span><br><span class="line">        <span class="comment">//定义0层</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;<span class="comment">//不要当前数</span></span><br><span class="line">        dp[<span class="number">0</span>][nums[<span class="number">0</span>] %  <span class="number">7</span>] = nums[<span class="number">0</span>];<span class="comment">//要当前数</span></span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="comment">//针对每一个取或不取</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, cur; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//当前数需要的目标余数</span></span><br><span class="line">            cur = nums[i] % <span class="number">7</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, need; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">                need = (j - cur + <span class="number">7</span>) % <span class="number">7</span>;</span><br><span class="line">                <span class="comment">//逐个复制上层结果</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="comment">//找到上层对应目标余数了</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i - <span class="number">1</span>][need] != -<span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][need] + nums[i], dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里的i是长度出发，其他和上面一样</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSum3</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>][<span class="number">7</span>];</span><br><span class="line">        <span class="comment">//定义0层</span></span><br><span class="line">        Arrays.fill(dp[<span class="number">0</span>], -<span class="number">1</span>);</span><br><span class="line"><span class="comment">//        dp[0][nums[0] %  7] = nums[0];</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历数组</span></span><br><span class="line">        <span class="comment">//针对每一个取或不取</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, cur, x; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//当前数需要的目标余数</span></span><br><span class="line">            x = nums[i - <span class="number">1</span>];</span><br><span class="line">            cur = x % <span class="number">7</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, need; j &lt; <span class="number">7</span>; j++) &#123;</span><br><span class="line">                need = (j - cur + <span class="number">7</span>) % <span class="number">7</span>;</span><br><span class="line">                <span class="comment">//逐个复制上层结果</span></span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="comment">//找到上层对应目标余数了</span></span><br><span class="line">                <span class="keyword">if</span> (dp[i - <span class="number">1</span>][need] != -<span class="number">1</span>)&#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - <span class="number">1</span>][need] + x, dp[i - <span class="number">1</span>][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[nums.length][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 暴力方法</span></span><br><span class="line">    <span class="comment">// 为了验证</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSum1</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">// nums形成的所有子序列的累加和都求出来</span></span><br><span class="line">        <span class="comment">// 其中%7==0的那些累加和中，返回最大的</span></span><br><span class="line">        <span class="comment">// 就是如下f函数的功能</span></span><br><span class="line">        <span class="keyword">return</span> f(nums, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == nums.length) &#123;</span><br><span class="line">            <span class="keyword">return</span> s % <span class="number">7</span> == <span class="number">0</span> ? s : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(f(nums, i + <span class="number">1</span>, s), f(nums, i + <span class="number">1</span>, s + nums[i]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了测试</span></span><br><span class="line">    <span class="comment">// 生成随机数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] randomArray(<span class="type">int</span> n, <span class="type">int</span> v) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans[i] = (<span class="type">int</span>) (Math.random() * v);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了测试</span></span><br><span class="line">    <span class="comment">// 对数器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">15</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">testTime</span> <span class="operator">=</span> <span class="number">20000</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试开始&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * n) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span>[] nums = randomArray(len, v);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> maxSum1(nums);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> maxSum2(nums);</span><br><span class="line">            <span class="keyword">if</span> (ans1 != ans2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;出错了!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 子数组最大累加和问题扩展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 子数组最大累加和问题扩展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MaxProduct</title>
      <link href="/2024/10/22/MaxProduct/"/>
      <url>/2024/10/22/MaxProduct/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.子数组最大累加和问题扩展;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/10/22 15:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 乘积最大子数组</span></span><br><span class="line"><span class="comment">// 给你一个整数数组 nums</span></span><br><span class="line"><span class="comment">// 请你找出数组中乘积最大的非空连续子数组</span></span><br><span class="line"><span class="comment">// 并返回该子数组所对应的乘积</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/maximum-product-subarray/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxProduct</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//错误的代码！！！！！！！！！！！！</span></span><br><span class="line">    <span class="comment">//定义dp[i]为 包含当前位置的最大乘积</span></span><br><span class="line">    <span class="comment">//只要负数是偶数个，那答案就是全部相乘</span></span><br><span class="line">    <span class="comment">//否则 答案为局部子数组</span></span><br><span class="line">    <span class="comment">//所以这里只要找到局部最大子数组乘积即可，(这里写不出来）</span></span><br><span class="line">    <span class="comment">//所以dp[i] = Math.max(dp[i - 1] * nums[i], nums[i]) //当前数为正数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct0</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">zpre</span> <span class="operator">=</span> nums[<span class="number">0</span>], fpre = nums[<span class="number">0</span>], sum = nums[<span class="number">0</span>], ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum *= nums[i];</span><br><span class="line">            <span class="comment">//区分当前正负数逻辑</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                fpre = Math.min(fpre * nums[i], nums[i]);</span><br><span class="line">                zpre = <span class="number">1</span>;</span><br><span class="line">                ans = Math.max(ans, fpre);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                zpre = Math.max(zpre * nums[i], nums[i]);</span><br><span class="line">                fpre = <span class="number">1</span>;</span><br><span class="line">                ans = Math.max(ans, zpre);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            pre = Math.max(pre * nums[i], nums[i]);</span></span><br><span class="line"><span class="comment">//            ans = Math.max(ans, pre);</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(sum, ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//看了左神的代码</span></span><br><span class="line">    <span class="comment">//定义dp[i]为 包含当前位置的最大乘积</span></span><br><span class="line">    <span class="comment">//我想复杂了，直接针对当前i位置可能的情况分析即可啦</span></span><br><span class="line">    <span class="comment">//由于存在负数，那么会导致最大的变最小的，最小的变最大的。因此还需要维护当前最小值imin</span></span><br><span class="line">    <span class="comment">//1、只取i位置</span></span><br><span class="line">    <span class="comment">//2、dp[i - 1]max * i; (i为正数）</span></span><br><span class="line">    <span class="comment">//3、dp[i - 1]min * i; (i为负数）</span></span><br><span class="line">    <span class="comment">//3种情况取最大</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProduct</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> nums[<span class="number">0</span>], min = nums[<span class="number">0</span>], ans = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, curmin, curmax; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//包含i位置的最小乘积值.</span></span><br><span class="line">            <span class="comment">// 这里不区分正负数，直接用前面最大值和最小值乘以当前数去比较。 （因为存在min可能为max * nums[i]，反之也存在）</span></span><br><span class="line">            <span class="comment">// 例如【-2，3，-4】</span></span><br><span class="line">            curmin = Math.min(Math.min(min * nums[i], max * nums[i]), nums[i]);</span><br><span class="line">            <span class="comment">//包含i位置的最大乘积值</span></span><br><span class="line">            curmax = Math.max(Math.max(max * nums[i], min * nums[i]), nums[i]);</span><br><span class="line">            min = curmin;</span><br><span class="line">            max = curmax;</span><br><span class="line">            ans = Math.max(ans,max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 子数组最大累加和问题扩展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 子数组最大累加和问题扩展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MaximumSubmatrix</title>
      <link href="/2024/10/21/MaximumSubmatrix/"/>
      <url>/2024/10/21/MaximumSubmatrix/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.子数组最大累加和问题;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/10/21 16:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子矩阵最大累加和问题</span></span><br><span class="line"><span class="comment">// 给定一个二维数组grid，找到其中子矩阵的最大累加和</span></span><br><span class="line"><span class="comment">// 返回拥有最大累加和的子矩阵左上角和右下角坐标</span></span><br><span class="line"><span class="comment">// 如果有多个子矩阵都有最大累加和，返回哪一个都可以</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/max-submatrix-lcci/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaximumSubmatrix</span> &#123;</span><br><span class="line">    <span class="comment">//想了10分钟，没啥清晰的思路。感觉挺复杂的算法组合</span></span><br><span class="line">    <span class="comment">//看了左神代码，用压缩数组</span></span><br><span class="line">    <span class="comment">//也想过用压缩数组，但没深想怎么处理断层数据，直接弃用即可</span></span><br><span class="line">    <span class="comment">//总体流程：</span></span><br><span class="line">    <span class="comment">//1、从0-0，0-1，0-2... 1-1，1-2，1-3...依次遍历压缩数组 O(n*n)</span></span><br><span class="line">    <span class="comment">//2、变为处理一维的 子数组最大和并返回左右边界</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getMaxMatrix(<span class="type">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> matrix.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[] nums = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>, d = <span class="number">0</span>;<span class="comment">//定义答案的左上角和右下角坐标</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Integer.MIN_VALUE;<span class="comment">//全局最大答案</span></span><br><span class="line">        <span class="comment">//两层for循环遍历压缩</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">up</span> <span class="operator">=</span> <span class="number">0</span>; up &lt; n; up++) &#123;</span><br><span class="line">            <span class="comment">//清空</span></span><br><span class="line">            Arrays.fill(nums, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">down</span> <span class="operator">=</span> up; down &lt; n; down++) &#123;</span><br><span class="line">                <span class="comment">//一维 子数组最大和并返回左右边界问题</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>, l = <span class="number">0</span>, pre = <span class="number">0</span>; r &lt; m; r++) &#123;</span><br><span class="line">                    <span class="comment">//压缩</span></span><br><span class="line">                    nums[r] += matrix[down][r];</span><br><span class="line">                    <span class="comment">//如果前一个位置的最大值有益，那就加上当前值</span></span><br><span class="line">                    <span class="comment">//否则直接弃用 赋值为当前值, 并更新左边界</span></span><br><span class="line">                    <span class="keyword">if</span> (pre &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                        pre += nums[r];</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        pre = nums[r];</span><br><span class="line">                        l = r;<span class="comment">//更新左边界</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//更新最大值和边界</span></span><br><span class="line">                    <span class="keyword">if</span> (pre &gt; max)&#123;</span><br><span class="line">                        max = pre;</span><br><span class="line">                        a = up;<span class="comment">//从哪行开始的</span></span><br><span class="line">                        b = l;<span class="comment">//当前左边界</span></span><br><span class="line">                        c = down;<span class="comment">//当前遍历到哪行</span></span><br><span class="line">                        d = r;<span class="comment">//当前右边界</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;a,b,c,d&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 子数组最大累加和问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 子数组最大累加和问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HouseRobberIV</title>
      <link href="/2024/10/21/HouseRobberIV/"/>
      <url>/2024/10/21/HouseRobberIV/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.子数组最大累加和问题;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/10/21 11:24</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 打家劫舍 IV</span></span><br><span class="line"><span class="comment">// 沿街有一排连续的房屋。每间房屋内都藏有一定的现金</span></span><br><span class="line"><span class="comment">// 现在有一位小偷计划从这些房屋中窃取现金</span></span><br><span class="line"><span class="comment">// 由于相邻的房屋装有相互连通的防盗系统，所以小偷不会窃取相邻的房屋</span></span><br><span class="line"><span class="comment">// 小偷的 窃取能力 定义为他在窃取过程中能从单间房屋中窃取的 最大金额</span></span><br><span class="line"><span class="comment">// 给你一个整数数组 nums 表示每间房屋存放的现金金额</span></span><br><span class="line"><span class="comment">// 第i间房屋中放有nums[i]的钱数</span></span><br><span class="line"><span class="comment">// 另给你一个整数k，表示小偷需要窃取至少 k 间房屋</span></span><br><span class="line"><span class="comment">// 返回小偷需要的最小窃取能力值</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/house-robber-iv/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseRobberIV</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//题意： 至少窃取k间房，每完成所有窃取中，有个单间房屋最大窃取金额数，即maxI = max(dp[i])</span></span><br><span class="line">    <span class="comment">//返回所有方案中的最小答案，即ans = min(maxI)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//for循环遍历不行啊 n*n 超时啊</span></span><br><span class="line">    <span class="comment">///不知道怎么处理这个k了</span></span><br><span class="line">    <span class="comment">//虽然感觉像是二分答案法，但简单想了下没想到怎么处理</span></span><br><span class="line">    <span class="comment">//窃取流程</span></span><br><span class="line">    <span class="comment">//根据题意可分两种情况分析</span></span><br><span class="line">    <span class="comment">//1、取第一个位置时，必不能取最后一个位置，即讨论范围是0...length - 2</span></span><br><span class="line">    <span class="comment">//2.不取第一个位置时的讨论范围是 1...length - 1</span></span><br><span class="line">    <span class="comment">//上面两种情况的答案，取最小值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义dp[i] 为0..i位置能偷到的最大金额,可分两种情况讨论</span></span><br><span class="line">    <span class="comment">//1. 取i位置值时，dp[i] = dp[</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//以上是原有分析</span></span><br><span class="line">    <span class="comment">//看简单了左神代码后，果然是从二分答案法入手！！！！</span></span><br><span class="line">    <span class="comment">//开始二分答案分析：</span></span><br><span class="line">    <span class="comment">//定义小偷最大窃取能力为m，能不能偷k间房。 然后继续二分</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCapability</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//找最大、最小值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nums[<span class="number">0</span>],l = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            r = Math.max(num, r);</span><br><span class="line">            l = Math.min(num, l);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            m = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (can(m, k, nums)) &#123;</span><br><span class="line">                ans = m;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大偷窃能力为m的情况下，能否偷k间房</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">can</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> k, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length &amp;&amp; k &gt; <span class="number">0</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//能偷就偷: 当前能偷的和后面能偷的都是偷1间，没有别的区别，所以能偷就偷，还能让后续空间更大</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt;= m) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                --k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> k == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 子数组最大累加和问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 子数组最大累加和问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HouseRobberII</title>
      <link href="/2024/10/17/HouseRobberII/"/>
      <url>/2024/10/17/HouseRobberII/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.子数组最大累加和问题;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 打家劫舍II</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/10/17 11:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 环形数组中不能选相邻元素的最大累加和</span></span><br><span class="line"><span class="comment">// 给定一个数组nums，长度为n</span></span><br><span class="line"><span class="comment">// nums是一个环形数组，下标0和下标n-1是连在一起的</span></span><br><span class="line"><span class="comment">// 可以随意选择数字，但是不能选择相邻的数字</span></span><br><span class="line"><span class="comment">// 返回能得到的最大累加和</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/house-robber-ii/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseRobberII</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//审题不清晰啊！！！  “这意味着第一个房屋和最后一个房屋是紧挨着的” 环形啊！！！</span></span><br><span class="line">    <span class="comment">//下面的分析是非环形的情况·····！！</span></span><br><span class="line">    <span class="comment">//定义dp[i]为  0..i位置能偷窃到的最大金额</span></span><br><span class="line">    <span class="comment">//可分为偷当前位置 dp[i - 2] + nums[i]</span></span><br><span class="line">    <span class="comment">//不偷当前位置 dp[i - i]</span></span><br><span class="line">    <span class="comment">//dp[i]为两者取最大: dp[i] = Math.max(dp[i - 2] + nums[i], dp[i - i])</span></span><br><span class="line">    <span class="comment">//答案为max(dp[i])</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob0</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先处理i = 2之前的情况</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">prepre</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> pre;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, cur; i &lt; nums.length; i++) &#123;</span><br><span class="line">            cur = Math.max(prepre + nums[i], pre);</span><br><span class="line">            prepre = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            ans = Math.max(ans, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//环形的情况分析</span></span><br><span class="line">    <span class="comment">//在上面情况下 特殊处理最后一位</span></span><br><span class="line">    <span class="comment">//当必须取最后一位时，需要获取不包含位置0的，前i-2个位置的符合规则的最大和值</span></span><br><span class="line">    <span class="comment">//即这个值是从1...i-2的最大和值，所以我维持一个这个值spec即可</span></span><br><span class="line">    <span class="comment">//dp[i] = Math.max(spec + nums[i], dp[i - i])</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先处理i &lt; 2之前的情况</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">prepre</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> Math.max(nums[<span class="number">0</span>], nums[<span class="number">1</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> pre;</span><br><span class="line">        <span class="comment">//求范围是1..i-2的dp[i]</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">prepreSpec</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">preSpec</span> <span class="operator">=</span> nums[<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">curSpec</span> <span class="operator">=</span> preSpec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, cur; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//获取范围是1..i-2的dp[i]</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; nums.length - <span class="number">2</span>)&#123;</span><br><span class="line">                curSpec = Math.max(prepreSpec + nums[i], preSpec);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i == nums.length - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//长度小于3时，curSpec为0</span></span><br><span class="line">                <span class="keyword">if</span> (nums.length &lt;= <span class="number">3</span>)&#123;</span><br><span class="line">                    curSpec = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = Math.max(curSpec + nums[i], pre);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur = Math.max(prepre + nums[i], pre);</span><br><span class="line">            &#125;</span><br><span class="line">            prepreSpec = preSpec;</span><br><span class="line">            preSpec = curSpec;</span><br><span class="line"></span><br><span class="line">            prepre = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            ans = Math.max(ans, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左神算法，更简单。。。 只讨论取不取nums[0]即可， 上面的做法是讨论取不取末尾位置，会更复杂</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rob2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(best(nums, <span class="number">1</span>, n - <span class="number">1</span>), nums[<span class="number">0</span>] + best(nums, <span class="number">2</span>, n - <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// nums[l....r]范围上，没有环形的概念</span></span><br><span class="line">    <span class="comment">// 返回 : 可以随意选择数字，但不能选择相邻数字的情况下，最大累加和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">best</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> nums[l];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l + <span class="number">1</span> == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(nums[l], nums[r]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">prepre</span> <span class="operator">=</span> nums[l];</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> Math.max(nums[l], nums[l + <span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l + <span class="number">2</span>, cur; i &lt;= r; i++) &#123;</span><br><span class="line">            cur = Math.max(pre, nums[i] + Math.max(<span class="number">0</span>, prepre));</span><br><span class="line">            prepre = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 子数组最大累加和问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 子数组最大累加和问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MaxSubarraySumCircular</title>
      <link href="/2024/10/16/MaxSubarraySumCircular/"/>
      <url>/2024/10/16/MaxSubarraySumCircular/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.子数组最大累加和问题;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/10/16 16:04</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 环形数组的子数组最大累加和</span></span><br><span class="line"><span class="comment">// 给定一个数组nums，长度为n</span></span><br><span class="line"><span class="comment">// nums是一个环形数组，下标0和下标n-1是连在一起的</span></span><br><span class="line"><span class="comment">// 返回环形数组中，子数组最大累加和</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/maximum-sum-circular-subarray/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxSubarraySumCircular</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两个想法：1、重复复制数组成新数组，然后求子数组最大累加和</span></span><br><span class="line">    <span class="comment">//2、 区分不环绕 和 环绕两种情况</span></span><br><span class="line">    <span class="comment">// dp[i] 为 包含i位置的最大累加和</span></span><br><span class="line">    <span class="comment">// 前i - 1个位置为： dp[i] = Math.max( dp[ i - 1] + nums[i] , nums[i]) -》 A</span></span><br><span class="line">    <span class="comment">//第 i 位置最大和可以是 A的情况 ，也可以是i环绕0.. i - 1位置中的某个位置，取最大和</span></span><br><span class="line">    <span class="comment">//这里i位置开始，环绕的终点怎么取呢？ 取0..i-1中的最小和值，用整个数组和减去 minsum(0..i-1) -》 B   (这里不用担心i 环绕终点在i后面，这种情况答案会被后面的情况覆盖的）</span></span><br><span class="line">    <span class="comment">//两种情况取最大值即是i位置的结果</span></span><br><span class="line">    <span class="comment">//答案取 max dp[i]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubarraySumCircular</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">allSum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//数组总和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            allSum += num;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//答案</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">minsum</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//包含i-1位置的前i-1最小和</span></span><br><span class="line">        <span class="comment">//前一个最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">maxpre</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, pre; i &lt; nums.length; i++) &#123;</span><br><span class="line">            maxpre = Math.max(maxpre + nums[i], nums[i]); <span class="comment">// A</span></span><br><span class="line">            <span class="comment">//包含i-1位置的前i-1最小和</span></span><br><span class="line">            minsum = Math.min(minsum + nums[i - <span class="number">1</span>], nums[i - <span class="number">1</span>]);<span class="comment">//B</span></span><br><span class="line">            <span class="comment">//不环绕 和 环绕 (数组和 减去minsum(0..i-1)） 两种情况取最大</span></span><br><span class="line">            pre = Math.max(maxpre, allSum - minsum);</span><br><span class="line">            ans = Math.max(ans, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//左神算法 更美观简化吧</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxSubarraySumCircular2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length, all = nums[<span class="number">0</span>], maxsum = nums[<span class="number">0</span>], minsum = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, maxpre = nums[<span class="number">0</span>], minpre = nums[<span class="number">0</span>]; i &lt; n; i++) &#123;</span><br><span class="line">            all += nums[i];</span><br><span class="line">            maxpre = Math.max(nums[i], nums[i] + maxpre);</span><br><span class="line">            maxsum = Math.max(maxsum, maxpre);</span><br><span class="line">            minpre = Math.min(nums[i], nums[i] + minpre);</span><br><span class="line">            minsum = Math.min(minsum, minpre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 1) maxsum</span></span><br><span class="line">        <span class="comment">// 2) all - minsum</span></span><br><span class="line">        <span class="keyword">return</span> all == minsum ? maxsum : Math.max(maxsum, all - minsum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 子数组最大累加和问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 子数组最大累加和问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HouseRobber</title>
      <link href="/2024/10/10/HouseRobber/"/>
      <url>/2024/10/10/HouseRobber/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.子数组最大累加和问题;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 打家劫舍</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/10/10 17:49</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 数组中不能选相邻元素的最大累加和</span></span><br><span class="line"><span class="comment">// 给定一个数组，可以随意选择数字</span></span><br><span class="line"><span class="comment">// 但是不能选择相邻的数字，返回能得到的最大累加和</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/house-robber/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HouseRobber</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义dp[i] 为 0..i位置 能偷窃最高金额</span></span><br><span class="line">    <span class="comment">//dp[i]:   dp[i - 1] (不偷i位置）</span></span><br><span class="line">    <span class="comment">//dp[i - 2] + nums[i] (偷i位置）</span></span><br><span class="line">    <span class="comment">//dp[i] = 两种情况取最大</span></span><br><span class="line">    <span class="comment">//答案为全局最大</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rob</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">prepre</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, max; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//取dp[i]</span></span><br><span class="line">            max = Math.max(pre, prepre + nums[i]);</span><br><span class="line">            prepre = pre;</span><br><span class="line">            pre = max;</span><br><span class="line">            <span class="comment">//获取全局最大</span></span><br><span class="line">            ans = Math.max(ans, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 子数组最大累加和问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 子数组最大累加和问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MaximumSubarray</title>
      <link href="/2024/10/09/MaximumSubarray/"/>
      <url>/2024/10/09/MaximumSubarray/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.子数组最大累加和问题;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/10/9 17:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 子数组最大累加和</span></span><br><span class="line"><span class="comment">// 给你一个整数数组 nums</span></span><br><span class="line"><span class="comment">// 返回非空子数组的最大累加和</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/maximum-subarray/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaximumSubarray</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为不满足单调性，所以不能用滑动窗口</span></span><br><span class="line">    <span class="comment">//定义dp[i] 为 子数组必须以i位置的数做结尾，往左能延伸出来的最大累加和</span></span><br><span class="line">    <span class="comment">//dp[i] = Math.max（dp[i - 1] + nums[i&#125;, nums[i]) -&gt; 要么只取当前位置，要么加上前面的最大结果（因为要连续，所以一定要取当前位置）</span></span><br><span class="line">    <span class="comment">//所有结果取最大</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//获取当前dp[i] 并作为pre的值</span></span><br><span class="line">            pre = Math.max(pre + nums[i], nums[i]);</span><br><span class="line">            <span class="comment">//对比之前的答案取最大</span></span><br><span class="line">            ans = Math.max(ans, pre);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如下代码为附加问题的实现</span></span><br><span class="line">    <span class="comment">// 子数组中找到拥有最大累加和的子数组</span></span><br><span class="line">    <span class="comment">// 并返回如下三个信息:</span></span><br><span class="line">    <span class="comment">// 1) 最大累加和子数组的开头left</span></span><br><span class="line">    <span class="comment">// 2) 最大累加和子数组的结尾right</span></span><br><span class="line">    <span class="comment">// 3) 最大累加和子数组的累加和sum</span></span><br><span class="line">    <span class="comment">// 如果不止一个子数组拥有最大累加和，那么找到哪一个都可以</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> left;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> sum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到拥有最大累加和的子数组</span></span><br><span class="line">    <span class="comment">// 更新好全局变量left、right、sum</span></span><br><span class="line">    <span class="comment">// 上游调用函数可以直接使用这三个变量</span></span><br><span class="line">    <span class="comment">// 相当于返回了三个值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">extra</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        sum = Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>, pre = Integer.MIN_VALUE; r &lt; nums.length; r++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 吸收前面的累加和有利可图</span></span><br><span class="line">                <span class="comment">// 那就不换开头</span></span><br><span class="line">                pre += nums[r];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 吸收前面的累加和已经无利可图</span></span><br><span class="line">                <span class="comment">// 那就换开头</span></span><br><span class="line">                pre = nums[r];</span><br><span class="line">                l = r;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (pre &gt; sum) &#123;</span><br><span class="line">                sum = pre;</span><br><span class="line">                left = l;</span><br><span class="line">                right = r;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 子数组最大累加和问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 子数组最大累加和问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ScrambleString</title>
      <link href="/2024/09/20/ScrambleString/"/>
      <url>/2024/09/20/ScrambleString/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.三维动态规划;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/9/20 17:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扰乱字符串</span></span><br><span class="line"><span class="comment">// 使用下面描述的算法可以扰乱字符串 s 得到字符串 t ：</span></span><br><span class="line"><span class="comment">// 步骤1 : 如果字符串的长度为 1 ，算法停止</span></span><br><span class="line"><span class="comment">// 步骤2 : 如果字符串的长度 &gt; 1 ，执行下述步骤：</span></span><br><span class="line"><span class="comment">//        在一个随机下标处将字符串分割成两个非空的子字符串</span></span><br><span class="line"><span class="comment">//        已知字符串s，则可以将其分成两个子字符串x和y且满足s=x+y</span></span><br><span class="line"><span class="comment">//        可以决定是要 交换两个子字符串 还是要 保持这两个子字符串的顺序不变</span></span><br><span class="line"><span class="comment">//        即s可能是 s = x + y 或者 s = y + x</span></span><br><span class="line"><span class="comment">//        在x和y这两个子字符串上继续从步骤1开始递归执行此算法</span></span><br><span class="line"><span class="comment">// 给你两个 长度相等 的字符串 s1 和 s2，判断 s2 是否是 s1 的扰乱字符串</span></span><br><span class="line"><span class="comment">// 如果是，返回true ；否则，返回false</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/scramble-string/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ScrambleString</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暴力递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isScramble1</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> f1(<span class="number">0</span>, s1.length() - <span class="number">1</span>, <span class="number">0</span>, s2.length() - <span class="number">1</span>, s1.toCharArray(), s2.toCharArray());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归定义 其实如果按自然智慧去想，还是能想到的，只是有一丢丢抽象</span></span><br><span class="line">    <span class="comment">//按子问题去想： s1[l1..r1] 的扰乱字符串是否是 s2[l2...r2]</span></span><br><span class="line">    <span class="comment">// f(l1, r1, l2, r2, arr1, arr2)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> l1, <span class="type">int</span> r1, <span class="type">int</span> l2 , <span class="type">int</span> r2, <span class="type">char</span>[] arr1, <span class="type">char</span>[] arr2)</span>&#123;</span><br><span class="line">        <span class="comment">//剩一个字符直接对比</span></span><br><span class="line">        <span class="keyword">if</span> (l1 == r1)&#123;</span><br><span class="line">            <span class="keyword">return</span> arr1[l1] == arr2[l2];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环扰乱判断</span></span><br><span class="line">        <span class="comment">//正向对比每一个字符</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l1, j = l2; i &lt; r1; i++, j++) &#123;</span><br><span class="line">            <span class="comment">//左边扰乱对比 &amp;&amp; 右边 扰乱对比  如果都成立，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (f1(l1, i, l2, j, arr1, arr2) &amp;&amp; f1(i + <span class="number">1</span>, r1, j + <span class="number">1</span>, r2, arr1, arr2))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反向对比每一个字符， 即交换了位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l1, j = r2; i &lt; r1; i++, j--) &#123;</span><br><span class="line">            <span class="comment">//左边扰乱对比 &amp;&amp; 右边 扰乱对比  如果都成立，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (f1(l1, i, j, r2, arr1, arr2) &amp;&amp; f1(i + <span class="number">1</span>, r1, l2, j - <span class="number">1</span>, arr1, arr2))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记忆化搜索</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isScramble</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length();</span><br><span class="line">        <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n][n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> f2(<span class="number">0</span>, <span class="number">0</span>, n, s1.toCharArray(), s2.toCharArray(), dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//因为长度一样，用长度减少一个传参</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> l1, <span class="type">int</span> l2 , <span class="type">int</span> len, <span class="type">char</span>[] arr1, <span class="type">char</span>[] arr2, <span class="type">int</span>[][][] dp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> arr1[l1] == arr2[l2];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[l1][l2][len] != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[l1][l2][len] == <span class="number">1</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//循环扰乱判断</span></span><br><span class="line">        <span class="comment">//正向对比每一个字符</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f2(l1, l2, i, arr1, arr2, dp) &amp;&amp; f2(l1 + i, l2 + i, len - i, arr1, arr2, dp))&#123;</span><br><span class="line">                ans = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!ans)&#123;</span><br><span class="line">            <span class="comment">//反向对比每一个字符， 即交换了位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f2(l1, l2 + len - i, i, arr1, arr2, dp) &amp;&amp; f2(l1 + i, l2, len - i, arr1, arr2, dp))&#123;</span><br><span class="line">                    ans = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[l1][l2][len] = ans ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 三维动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三维动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PathsDivisibleByK</title>
      <link href="/2024/09/20/PathsDivisibleByK/"/>
      <url>/2024/09/20/PathsDivisibleByK/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.三维动态规划;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * 利用同余原理,反正(x + y) % k =&gt; (x % k + y % k) % k</span></span><br><span class="line"><span class="comment"> * 所以只要把路径上的数都求余，看最终余数结果是否等于0即可</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/9/20 10:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 矩阵中和能被 K 整除的路径</span></span><br><span class="line"><span class="comment">// 给一个下标从0开始的 n * m 整数矩阵 grid 和一个整数 k</span></span><br><span class="line"><span class="comment">// 从起点(0,0)出发，每步只能往下或者往右，你想要到达终点(m-1, n-1)</span></span><br><span class="line"><span class="comment">// 请你返回路径和能被 k 整除的路径数目</span></span><br><span class="line"><span class="comment">// 由于答案可能很大，返回答案对10^9+7取余的结果</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/paths-in-matrix-whose-sum-is-divisible-by-k/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PathsDivisibleByK</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记忆化搜索</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfPaths1</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][m][k];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                Arrays.fill(dp[i][j], -<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f1(<span class="number">0</span>, <span class="number">0</span>, grid[<span class="number">0</span>][<span class="number">0</span>] % k, grid, k, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用同余原理,反正(x + y) % k =&gt; (x % k + y % k) % k,所以只要把路径上的数都求余，看最终余数结果是否等于0即可</span></span><br><span class="line">    <span class="comment">//sum为余数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> sum, <span class="type">int</span>[][] grid, <span class="type">int</span> k, <span class="type">int</span>[][][] dp)</span>&#123;</span><br><span class="line">        <span class="comment">//到了边界 直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (i == grid.length - <span class="number">1</span> &amp;&amp; j == grid[<span class="number">0</span>].length - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> sum == <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[i][j][sum] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[i][j][sum];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//右下方向去找</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; grid[<span class="number">0</span>].length)&#123;</span><br><span class="line">            ans = f1(i, j + <span class="number">1</span>, (sum + grid[i][j + <span class="number">1</span>] % k) % k, grid, k, dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; grid.length)&#123;</span><br><span class="line">            ans = (ans +  f1(i + <span class="number">1</span>, j, (sum + grid[i + <span class="number">1</span>][j] % k) % k, grid, k, dp) % MOD) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dp[i][j][sum] = (<span class="type">int</span>) ans;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//严格位置依赖的dp</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfPaths</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//想象成二维数组，但每个值是厚度为k的值</span></span><br><span class="line">        <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][m][k];</span><br><span class="line">        <span class="comment">//填充边界</span></span><br><span class="line">        dp[n - <span class="number">1</span>][m - <span class="number">1</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//右侧边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, index; l &lt; k; l++) &#123;</span><br><span class="line">                index = (l + grid[i + <span class="number">1</span>][m - <span class="number">1</span>] % k) % k;</span><br><span class="line">                dp[i][m - <span class="number">1</span>][l] = (dp[i][m - <span class="number">1</span>][l] + dp[i + <span class="number">1</span>][m - <span class="number">1</span>][index] % MOD) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//底部边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> m - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, index; l &lt; k; l++) &#123;</span><br><span class="line">                index = (l + grid[n - <span class="number">1</span>][i + <span class="number">1</span>] % k) % k;</span><br><span class="line">                dp[n - <span class="number">1</span>][i][l] = (dp[n - <span class="number">1</span>][i][l] + dp[n - <span class="number">1</span>][i + <span class="number">1</span>][index] % MOD) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从右往左填充</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m - <span class="number">2</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="comment">//填充每一层厚度</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, index; l &lt; k; l++) &#123;</span><br><span class="line">                    index = (l + grid[i][j + <span class="number">1</span>] % k) % k;</span><br><span class="line">                    dp[i][j][l] = dp[i][j + <span class="number">1</span>][index] % MOD;</span><br><span class="line">                    index = (l + grid[i + <span class="number">1</span>][j] % k) % k;</span><br><span class="line">                    dp[i][j][l] = (dp[i][j][l] +  dp[i + <span class="number">1</span>][j][index] % MOD) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>][grid[<span class="number">0</span>][<span class="number">0</span>] % k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 三维动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三维动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KnightProbabilityInChessboard</title>
      <link href="/2024/09/19/KnightProbabilityInChessboard/"/>
      <url>/2024/09/19/KnightProbabilityInChessboard/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.三维动态规划;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/9/19 16:23</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 骑士在棋盘上的概率</span></span><br><span class="line"><span class="comment">// n * n的国际象棋棋盘上，一个骑士从单元格(row, col)开始，并尝试进行 k 次移动</span></span><br><span class="line"><span class="comment">// 行和列从0开始，所以左上单元格是 (0,0)，右下单元格是 (n-1, n-1)</span></span><br><span class="line"><span class="comment">// 象棋骑士有8种可能的走法。每次移动在基本方向上是两个单元格，然后在正交方向上是一个单元格</span></span><br><span class="line"><span class="comment">// 每次骑士要移动时，它都会随机从8种可能的移动中选择一种，然后移动到那里</span></span><br><span class="line"><span class="comment">// 骑士继续移动，直到它走了 k 步或离开了棋盘</span></span><br><span class="line"><span class="comment">// 返回 骑士在棋盘停止移动后仍留在棋盘上的概率</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/knight-probability-in-chessboard/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KnightProbabilityInChessboard</span> &#123;</span><br><span class="line">    <span class="comment">//计算概率： 当前停在棋盘上的概率，乘以上一次停在棋盘上的概率。</span></span><br><span class="line">    <span class="comment">// 即分母是 8 ^ k，分子是（当前停在棋盘上的步数 + 上一次停在棋盘上的步数）</span></span><br><span class="line">    <span class="comment">//dp定义 当前停在棋盘上的步数总数 dp[i] = 当前有效步数count</span></span><br><span class="line">    <span class="comment">//答案取sum当前层 * sum 上一层 / 8 ^ k</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//果然不从递归直接上dp  思维就会很混乱</span></span><br><span class="line">    <span class="comment">//还是乖乖从递归开始吧</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">knightProbability1</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> row, <span class="type">int</span> column)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> f1(n, k, row, column) / Math.pow(<span class="number">8</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//剩余操作数，当前所在位置</span></span><br><span class="line">    <span class="comment">//当前位置出发停在棋盘上有几种操作</span></span><br><span class="line">    <span class="comment">//思路：统计所有最后在棋盘上的有效的路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> row, <span class="type">int</span> column)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &gt;= n || column &gt;= n || column &lt; <span class="number">0</span> || row &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前位置在棋盘上</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//把各个位置加起来</span></span><br><span class="line">        ans += f1(n, k - <span class="number">1</span>, row - <span class="number">1</span>, column  - <span class="number">2</span>);</span><br><span class="line">        ans += f1(n, k - <span class="number">1</span>, row + <span class="number">1</span>, column  - <span class="number">2</span>);</span><br><span class="line">        ans += f1(n, k - <span class="number">1</span>, row + <span class="number">1</span>, column  + <span class="number">2</span>);</span><br><span class="line">        ans += f1(n, k - <span class="number">1</span>, row - <span class="number">1</span>, column  + <span class="number">2</span>);</span><br><span class="line">        ans += f1(n, k - <span class="number">1</span>, row - <span class="number">2</span>, column  - <span class="number">1</span>);</span><br><span class="line">        ans += f1(n, k - <span class="number">1</span>, row + <span class="number">2</span>, column  - <span class="number">1</span>);</span><br><span class="line">        ans += f1(n, k - <span class="number">1</span>, row + <span class="number">2</span>, column  + <span class="number">1</span>);</span><br><span class="line">        ans += f1(n, k - <span class="number">1</span>, row - <span class="number">2</span>, column  + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//记忆化搜索</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">knightProbability2</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> row, <span class="type">int</span> column)</span> &#123;</span><br><span class="line">        <span class="comment">//这里要用double，用int会出错</span></span><br><span class="line">        <span class="type">double</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">double</span>[n][n][k + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                Arrays.fill(dp[i][j], -<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f2(n, k, row, column, dp) / Math.pow(<span class="number">8</span>, k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//剩余操作数，当前所在位置</span></span><br><span class="line">    <span class="comment">//当前位置出发停在棋盘上有几种操作</span></span><br><span class="line">    <span class="comment">//思路：统计所有最后在棋盘上的有效的路径</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> k, <span class="type">int</span> row, <span class="type">int</span> column, <span class="type">double</span>[][][] dp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (row &gt;= n || column &gt;= n || column &lt; <span class="number">0</span> || row &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前位置在棋盘上</span></span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[row][column][k] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[row][column][k];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//把各个位置加起来</span></span><br><span class="line">        ans += f2(n, k - <span class="number">1</span>, row - <span class="number">1</span>, column  - <span class="number">2</span>, dp);</span><br><span class="line">        ans += f2(n, k - <span class="number">1</span>, row + <span class="number">1</span>, column  - <span class="number">2</span>, dp);</span><br><span class="line">        ans += f2(n, k - <span class="number">1</span>, row + <span class="number">1</span>, column  + <span class="number">2</span>, dp);</span><br><span class="line">        ans += f2(n, k - <span class="number">1</span>, row - <span class="number">1</span>, column  + <span class="number">2</span>, dp);</span><br><span class="line">        ans += f2(n, k - <span class="number">1</span>, row - <span class="number">2</span>, column  - <span class="number">1</span>, dp);</span><br><span class="line">        ans += f2(n, k - <span class="number">1</span>, row + <span class="number">2</span>, column  - <span class="number">1</span>, dp);</span><br><span class="line">        ans += f2(n, k - <span class="number">1</span>, row + <span class="number">2</span>, column  + <span class="number">1</span>, dp);</span><br><span class="line">        ans += f2(n, k - <span class="number">1</span>, row - <span class="number">2</span>, column  + <span class="number">1</span>, dp);</span><br><span class="line">        dp[row][column][k] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//严格位置依赖的dp</span></span><br><span class="line">    <span class="comment">//依赖下层 8 个方向的结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">knightProbability</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> t, <span class="type">int</span> row, <span class="type">int</span> column)</span> &#123;</span><br><span class="line">        <span class="type">double</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">double</span>[t + <span class="number">1</span>][n][n];</span><br><span class="line">        <span class="comment">//填充最底层</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                dp[<span class="number">0</span>][i][j] =  <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接从底到顶遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">1</span>; k &lt;= t; k++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    <span class="type">double</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">//把各个位置加起来</span></span><br><span class="line">                    <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; j - <span class="number">2</span> &gt;= <span class="number">0</span>) ans += dp[k - <span class="number">1</span>][i - <span class="number">1</span>][j - <span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">if</span> (i + <span class="number">1</span> &lt; n &amp;&amp; j - <span class="number">2</span> &gt;= <span class="number">0</span>) ans += dp[k - <span class="number">1</span>][i + <span class="number">1</span>][j - <span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">if</span> (i + <span class="number">1</span> &lt; n &amp;&amp; j + <span class="number">2</span> &lt; n) ans += dp[k - <span class="number">1</span>][i + <span class="number">1</span>][j + <span class="number">2</span>];</span><br><span class="line">                    <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; j + <span class="number">2</span> &lt; n) ans += dp[k - <span class="number">1</span>][i - <span class="number">1</span>][j + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (i - <span class="number">2</span> &gt;= <span class="number">0</span> &amp;&amp; j - <span class="number">1</span> &gt;= <span class="number">0</span>) ans += dp[k - <span class="number">1</span>][i - <span class="number">2</span>][j - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (i + <span class="number">2</span> &lt; n &amp;&amp; j - <span class="number">1</span> &gt;= <span class="number">0</span>) ans += dp[k - <span class="number">1</span>][i + <span class="number">2</span>][j - <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (i + <span class="number">2</span> &lt; n &amp;&amp; j + <span class="number">1</span> &lt; n) ans += dp[k - <span class="number">1</span>][i + <span class="number">2</span>][j + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (i - <span class="number">2</span> &gt;= <span class="number">0</span> &amp;&amp; j + <span class="number">1</span> &lt; n) ans += dp[k - <span class="number">1</span>][i - <span class="number">2</span>][j + <span class="number">1</span>];</span><br><span class="line">                    dp[k][i][j] = ans;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[t][row][column] / Math.pow(<span class="number">8</span>, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//    public int countTep(int row, int column, int n)&#123;</span></span><br><span class="line"><span class="comment">//        int ans = 0;</span></span><br><span class="line"><span class="comment">//        i = row - 1;j = column - 2;</span></span><br><span class="line"><span class="comment">//        if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; n &amp;&amp; j &lt; n) ans++;</span></span><br><span class="line"><span class="comment">//        i = row + 1;j = column - 2;</span></span><br><span class="line"><span class="comment">//        if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; n &amp;&amp; j &lt; n) ans++;</span></span><br><span class="line"><span class="comment">//        i = row + 1;j = column + 2;</span></span><br><span class="line"><span class="comment">//        if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; n &amp;&amp; j &lt; n) ans++;</span></span><br><span class="line"><span class="comment">//        i = row - 1;j = column + 2;</span></span><br><span class="line"><span class="comment">//        if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; n &amp;&amp; j &lt; n) ans++;</span></span><br><span class="line"><span class="comment">//        i = row - 2; j = column - 1;</span></span><br><span class="line"><span class="comment">//        if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; n &amp;&amp; j &lt; n) ans++;</span></span><br><span class="line"><span class="comment">//        i = row + 2; j = column - 1;</span></span><br><span class="line"><span class="comment">//        if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; n &amp;&amp; j &lt; n) ans++;</span></span><br><span class="line"><span class="comment">//        i = row + 2; j = column + 1;</span></span><br><span class="line"><span class="comment">//        if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; n &amp;&amp; j &lt; n) ans++;</span></span><br><span class="line"><span class="comment">//        i = row - 2; j = column + 1;</span></span><br><span class="line"><span class="comment">//        if (i &gt;= 0 &amp;&amp; j &gt;= 0 &amp;&amp; i &lt; n &amp;&amp; j &lt; n) ans++;</span></span><br><span class="line"><span class="comment">//        return ans;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 三维动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三维动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ProfitableSchemes</title>
      <link href="/2024/09/14/ProfitableSchemes/"/>
      <url>/2024/09/14/ProfitableSchemes/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.三维动态规划;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/9/14 11:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 盈利计划(多维费用背包)</span></span><br><span class="line"><span class="comment">// 集团里有 n 名员工，他们可以完成各种各样的工作创造利润</span></span><br><span class="line"><span class="comment">// 第 i 种工作会产生 profit[i] 的利润，它要求 group[i] 名成员共同参与</span></span><br><span class="line"><span class="comment">// 如果成员参与了其中一项工作，就不能参与另一项工作</span></span><br><span class="line"><span class="comment">// 工作的任何至少产生 minProfit 利润的子集称为 盈利计划</span></span><br><span class="line"><span class="comment">// 并且工作的成员总数最多为 n</span></span><br><span class="line"><span class="comment">// 有多少种计划可以选择？因为答案很大，所以 返回结果模 10^9 + 7 的值。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/profitable-schemes/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProfitableSchemes</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//选与不选的问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">profitableSchemes1</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> minProfit, <span class="type">int</span>[] group, <span class="type">int</span>[] profit)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> f1(n, minProfit, <span class="number">0</span>,  group, profit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接暴力递归</span></span><br><span class="line">    <span class="comment">//最大n个员工，需产生minProfit利润， 当前工作索引index</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> minProfit, <span class="type">int</span> index , <span class="type">int</span>[] group, <span class="type">int</span>[] profit)</span>&#123;</span><br><span class="line">        <span class="comment">//没工作 或 没人了</span></span><br><span class="line">        <span class="keyword">if</span> (index == group.length || n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//判断利润是否满足</span></span><br><span class="line">            <span class="keyword">return</span> minProfit &lt;= <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//即使利润足够了，也能继续参与工作，也是一个完整的盈利计划</span></span><br><span class="line">        <span class="comment">//所以不需要判断minProfit &lt; 0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> f1(n, minProfit, index + <span class="number">1</span>, group, profit);</span><br><span class="line">        <span class="comment">//要注意判断是否够人完成当前工作</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt;= group[index])&#123;</span><br><span class="line">            ans1 = f1(n - group[index], minProfit - profit[index], index + <span class="number">1</span>, group, profit);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不参与当前工作 和 参与当前工作 的结果加起来</span></span><br><span class="line">        <span class="keyword">return</span> ans2 + ans1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记忆化搜索</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">profitableSchemes2</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span>[] group, <span class="type">int</span>[] profit)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[group.length + <span class="number">1</span>][n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= group.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                Arrays.fill(dp[i][j], -<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f2(n, m, <span class="number">0</span>, group, profit, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> index , <span class="type">int</span>[] group, <span class="type">int</span>[] profit, <span class="type">int</span>[][][] dp)</span>&#123;</span><br><span class="line">        <span class="comment">//没工作 或 没人了</span></span><br><span class="line">        <span class="keyword">if</span> (index == group.length || n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//判断利润是否满足</span></span><br><span class="line">            <span class="keyword">return</span> m &lt;= <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[index][n][m] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[index][n][m];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//即使利润足够了，也能继续参与工作，也是一个完整的盈利计划</span></span><br><span class="line">        <span class="comment">//所以不需要判断minProfit &lt; 0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> f2(n, m, index + <span class="number">1</span>, group, profit, dp);</span><br><span class="line">        <span class="comment">//要注意判断是否够人完成当前工作</span></span><br><span class="line">        <span class="keyword">if</span> (n &gt;= group[index])&#123;</span><br><span class="line">            <span class="comment">//这里为了避免负数，利润取最小0值</span></span><br><span class="line">            ans1 = f2(n - group[index], Math.max(m - profit[index], <span class="number">0</span>), index + <span class="number">1</span>, group, profit, dp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不参与当前工作 和 参与当前工作 的结果加起来</span></span><br><span class="line">        dp[index][n][m] = (ans2 + ans1) % mod;</span><br><span class="line">        <span class="keyword">return</span> dp[index][n][m];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//严格位置依赖的动态规划</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">profitableSchemes3</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span>[] group, <span class="type">int</span>[] profit)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> group.length;</span><br><span class="line">        <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[l + <span class="number">1</span>][n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//填充最上层</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">//利润为0，总有方案</span></span><br><span class="line">            dp[l][i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从顶到底， 从左到右递推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> l - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                <span class="comment">//纠正：</span></span><br><span class="line">                <span class="comment">//这里不要填充当前0值</span></span><br><span class="line">                <span class="comment">// 因为每一层的值都是由上一层的当前值和左上角值决定</span></span><br><span class="line">                <span class="comment">//注释原本错误做法： （只能是至少有1个方案，而不是只有1个方案）</span></span><br><span class="line">                <span class="comment">//利润为0 肯定有一种方案</span></span><br><span class="line"><span class="comment">//                dp[index][i][0] = 1;</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> dp[index + <span class="number">1</span>][i][j];</span><br><span class="line">                    <span class="comment">//要注意判断是否够人完成当前工作</span></span><br><span class="line">                    <span class="keyword">if</span> (i &gt;= group[index])&#123;</span><br><span class="line">                        <span class="comment">//这里为了避免负数，利润取最小0值</span></span><br><span class="line">                        ans1 = dp[index + <span class="number">1</span>][i - group[index]][Math.max(j - profit[index], <span class="number">0</span>)];</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">//不参与当前工作 和 参与当前工作 的结果加起来</span></span><br><span class="line">                    dp[index][i][j] = (ans2 + ans1) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n][m];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空间压缩</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">profitableSchemes</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span>[] group, <span class="type">int</span>[] profit)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//填充最上层值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每一层的值由上一层的 当前位置 和 上一层左上方的值决定</span></span><br><span class="line">        <span class="comment">//所以从末置位更新，因为其他位置还会用到</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> group.length - <span class="number">1</span>; index &gt;= <span class="number">0</span>; index--) &#123;</span><br><span class="line">            <span class="comment">//只有i &gt;= group[index]位置的才要更新</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &gt;= group[index]; i--) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                    <span class="comment">//不参与当前工作 和 参与当前工作 的结果加起来</span></span><br><span class="line">                    dp[i][j] = (dp[i][j] + dp[i - group[index]][Math.max(j - profit[index], <span class="number">0</span>)]) % mod;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 三维动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三维动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OnesAndZeroes</title>
      <link href="/2024/09/13/OnesAndZeroes/"/>
      <url>/2024/09/13/OnesAndZeroes/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.三维动态规划;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/9/13 17:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 一和零(多维费用背包)</span></span><br><span class="line"><span class="comment">// 给你一个二进制字符串数组 strs 和两个整数 m 和 n</span></span><br><span class="line"><span class="comment">// 请你找出并返回 strs 的最大子集的长度</span></span><br><span class="line"><span class="comment">// 该子集中 最多 有 m 个 0 和 n 个 1</span></span><br><span class="line"><span class="comment">// 如果 x 的所有元素也是 y 的元素，集合 x 是集合 y 的 子集</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/ones-and-zeroes/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OnesAndZeroes</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> one,zero;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//暴力递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm1</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> f1(strs, <span class="number">0</span>, m, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">(String[] strs, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="comment">//判断当前是否满足条件</span></span><br><span class="line">        <span class="comment">//超出数组  或 都不能包含0 ，1时直接返回0</span></span><br><span class="line">        <span class="keyword">if</span> (l == strs.length || (m == <span class="number">0</span> &amp;&amp; n == <span class="number">0</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计当前字符0， 1数</span></span><br><span class="line">        countNum(strs[l]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//取当前字符串</span></span><br><span class="line">        <span class="keyword">if</span> (zero &lt;= m &amp;&amp; one &lt;= n)&#123;</span><br><span class="line">            ans1 = f1(strs, l + <span class="number">1</span>, m - zero, n - one) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不取</span></span><br><span class="line">        ans2 = f1(strs, l + <span class="number">1</span>, m, n);</span><br><span class="line">        <span class="keyword">return</span> Math.max(ans1, ans2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记忆化搜素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm2</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[strs.length][n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strs.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                Arrays.fill(dp[i][j], -<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> f2(strs, <span class="number">0</span>, m, n, dp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f2</span><span class="params">(String[] strs, <span class="type">int</span> l, <span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span>[][][] dp)</span>&#123;</span><br><span class="line">        <span class="comment">//判断当前是否满足条件</span></span><br><span class="line">        <span class="comment">//超出数组  或 都不能包含0 ，1时直接返回0</span></span><br><span class="line">        <span class="keyword">if</span> (l == strs.length || (m == <span class="number">0</span> &amp;&amp; n == <span class="number">0</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[l][n][m] != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[l][n][m];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计当前字符0， 1数</span></span><br><span class="line">        countNum(strs[l]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//取当前字符串</span></span><br><span class="line">        <span class="keyword">if</span> (zero &lt;= m &amp;&amp; one &lt;= n)&#123;</span><br><span class="line">            ans1 = f2(strs, l + <span class="number">1</span>, m - zero, n - one, dp) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不取</span></span><br><span class="line">        ans2 = f2(strs, l + <span class="number">1</span>, m, n, dp);</span><br><span class="line">        dp[l][n][m] = Math.max(ans1, ans2);</span><br><span class="line">        <span class="keyword">return</span> dp[l][n][m];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//严格位置依赖的dp</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm3</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> strs.length;</span><br><span class="line">        <span class="comment">//第l层都是0</span></span><br><span class="line">        <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[l + <span class="number">1</span>][n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从顶到底， 从左到右递推</span></span><br><span class="line">        <span class="comment">//第l层全是0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//统计当前字符0， 1数</span></span><br><span class="line">            countNum(strs[i]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt;= m; k++) &#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                    <span class="comment">//取当前字符串</span></span><br><span class="line">                    <span class="keyword">if</span> (zero &lt;= k &amp;&amp; one &lt;= j)&#123;</span><br><span class="line">                        ans1 = dp[i + <span class="number">1</span>][j - one][k - zero] + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//不取</span></span><br><span class="line">                    ans2 = dp[i + <span class="number">1</span>][j][k];</span><br><span class="line">                    dp[i][j][k] = Math.max(ans1, ans2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n][m];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//严格位置依赖的dp + 空间压缩</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> strs.length;</span><br><span class="line">        <span class="comment">//第l层都是0</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (String str : strs) &#123;</span><br><span class="line">            <span class="comment">//统计当前字符0， 1数</span></span><br><span class="line">            countNum(str);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//为什么这里要从底层 从右到左更新呢？</span></span><br><span class="line">            <span class="comment">//因为从递归分析可知，当前层依赖宇上一层的对应位置的dp[i][j], 以及其左上方位置</span></span><br><span class="line">            <span class="comment">//所以更新当前层要从最末端更新，否则会破环其他位置的取值</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里还有个小优化，当one &lt;= i &amp;&amp; zero &lt;= j时才更新dp值，否则直接用旧值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n; i &gt;= one; i--) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m; j &gt;= zero; j--) &#123;</span><br><span class="line">                    dp[i][j] = Math.max(dp[i - one][j - zero] + <span class="number">1</span>, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">countNum</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        one = <span class="number">0</span>;</span><br><span class="line">        zero = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                zero++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                one++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//原始直接dp的分析，错在了k - 1上</span></span><br><span class="line">    <span class="comment">//strs[前缀长为k]， 子集中最多有i个0 和 j个1</span></span><br><span class="line">    <span class="comment">//统计0，1前缀和</span></span><br><span class="line">    <span class="comment">// count[i - 1] 满足  0 和 1个数， dp[k][i][j] = dp[k - 1][i - x][j - y] + 1</span></span><br><span class="line">    <span class="comment">//dp[k][i][j] = dp[k - 1][i][j];</span></span><br><span class="line">    <span class="comment">//两数求最大</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxForm0</span><span class="params">(String[] strs, <span class="type">int</span> m, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 三维动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 三维动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinimumDeleteBecomeSubstring</title>
      <link href="/2024/09/12/MinimumDeleteBecomeSubstring/"/>
      <url>/2024/09/12/MinimumDeleteBecomeSubstring/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.二维动态规划;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/9/12 15:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除至少几个字符可以变成另一个字符串的子串</span></span><br><span class="line"><span class="comment">// 给定两个字符串s1和s2</span></span><br><span class="line"><span class="comment">// 返回s1至少删除多少字符可以成为s2的子串</span></span><br><span class="line"><span class="comment">// 对数器验证</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinimumDeleteBecomeSubstring</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//大意了，是子串 而不是变成另一个字符串</span></span><br><span class="line">    <span class="comment">//dp[i][j],定义s[前缀长i]个字符，变成t[前缀长j]个字符串的子串，需要删除多少个字符串</span></span><br><span class="line">    <span class="comment">//具体分析：</span></span><br><span class="line">    <span class="comment">//1.s[i - 1] == t[j - 1], dp[i - 1][j - 1]， 相同直接看上一个字符</span></span><br><span class="line">    <span class="comment">//2.</span></span><br><span class="line">    <span class="comment">// a. 当前字符s[i - 1]不是该子串组成， 删除当前s[i - 1]字符, dp[i - 1][j] + 1</span></span><br><span class="line">    <span class="comment">// b. 当前字符s[i - 1]可能是该t[..j]子串组成，不删s，遍历t上一个字符，dp[i][j - 1]</span></span><br><span class="line">    <span class="comment">// 2种情况取最小</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是修正后的定义！！！</span></span><br><span class="line">    <span class="comment">//上面dp定义不大对，所以会产生2.b的情况</span></span><br><span class="line">    <span class="comment">//这里定义dp[i][j],定义s[前缀长i]个字符，变成t[前缀长j]个字符串的后缀子串（即 s[i - 1] 得 和 t[j -1]相同），需要删除多少个字符串</span></span><br><span class="line">    <span class="comment">//这里得到的都是后缀串，所以取最后一行的最小值，作为子串的结果</span></span><br><span class="line">    <span class="comment">//所以dp只能讨论这两种情况</span></span><br><span class="line">    <span class="comment">//具体分析：</span></span><br><span class="line">    <span class="comment">//1.s[i - 1] == t[j - 1], dp[i - 1][j - 1]， 相同直接看上一个字符</span></span><br><span class="line">    <span class="comment">//2.当前字符s[i - 1]不是该子串组成， 删除当前s[i - 1]字符, dp[i - 1][j] + 1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minDelete0</span><span class="params">(String s1, String s2)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] s = s1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] t = s2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> t.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//填充边界值</span></span><br><span class="line">        <span class="comment">//第一列 全删</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从左往右递推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">//原本错误定义下的做法</span></span><br><span class="line"><span class="comment">//                dp[i][j] = s[i - 1] == t[j - 1] ? dp[i - 1][j - 1] :  Math.min(dp[i - 1][j] + 1, dp[i][j - 1]);</span></span><br><span class="line">                dp[i][j] = s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>] ? dp[i - <span class="number">1</span>][j - <span class="number">1</span>] :  dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        return dp[n][m];</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            ans = Math.min(dp[n][i], ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴力方法</span></span><br><span class="line">    <span class="comment">// 为了验证</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minDelete1</span><span class="params">(String s1, String s2)</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        f(s1.toCharArray(), <span class="number">0</span>, <span class="string">&quot;&quot;</span>, list);</span><br><span class="line">        <span class="comment">// 排序 : 长度大的子序列先考虑</span></span><br><span class="line">        <span class="comment">// 因为如果长度大的子序列是s2的子串</span></span><br><span class="line">        <span class="comment">// 那么需要删掉的字符数量 = s1的长度 - s1子序列长度</span></span><br><span class="line">        <span class="comment">// 子序列长度越大，需要删掉的字符数量就越少</span></span><br><span class="line">        <span class="comment">// 所以长度大的子序列先考虑</span></span><br><span class="line">        list.sort((a, b) -&gt; b.length() - a.length());</span><br><span class="line">        <span class="keyword">for</span> (String str : list) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s2.indexOf(str) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 检查s2中，是否包含当前的s1子序列str</span></span><br><span class="line">                <span class="keyword">return</span> s1.length() - str.length();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s1.length();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成s1字符串的所有子序列串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">char</span>[] s1, <span class="type">int</span> i, String path, List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == s1.length) &#123;</span><br><span class="line">            list.add(path);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            f(s1, i + <span class="number">1</span>, path, list);</span><br><span class="line">            f(s1, i + <span class="number">1</span>, path + s1[i], list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正式方法，动态规划</span></span><br><span class="line">    <span class="comment">// 已经展示太多次从递归到动态规划了</span></span><br><span class="line">    <span class="comment">// 直接写动态规划吧</span></span><br><span class="line">    <span class="comment">// 也不做空间压缩了，因为千篇一律</span></span><br><span class="line">    <span class="comment">// 有兴趣的同学自己试试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minDelete2</span><span class="params">(String str1, String str2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s1 = str1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] s2 = str2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s2.length;</span><br><span class="line">        <span class="comment">// dp[len1][len2] :</span></span><br><span class="line">        <span class="comment">// s1[前缀长度为i]至少删除多少字符，可以变成s2[前缀长度为j]的任意后缀串</span></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            ans = Math.min(ans, dp[n][j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了验证</span></span><br><span class="line">    <span class="comment">// 生成长度为n，有v种字符的随机字符串</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">randomString</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] ans = <span class="keyword">new</span> <span class="title class_">char</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans[i] = (<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span> + (<span class="type">int</span>) (Math.random() * v));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(ans);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了验证</span></span><br><span class="line">    <span class="comment">// 对数器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 测试的数据量比较小</span></span><br><span class="line">        <span class="comment">// 那是因为数据量大了，暴力方法过不了</span></span><br><span class="line">        <span class="comment">// 但是这个数据量足够说明正式方法是正确的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">12</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">testTime</span> <span class="operator">=</span> <span class="number">20000</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试开始&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * n) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * n) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> randomString(len1, v);</span><br><span class="line">            <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> randomString(len2, v);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> minDelete1(s1, s2);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> minDelete0(s1, s2);</span><br><span class="line">            <span class="keyword">if</span> (ans1 != ans2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;出错了!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二维动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FillCellsUseAllColorsWays</title>
      <link href="/2024/09/12/FillCellsUseAllColorsWays/"/>
      <url>/2024/09/12/FillCellsUseAllColorsWays/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.二维动态规划;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/9/12 11:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有效涂色问题</span></span><br><span class="line"><span class="comment">// 给定n、m两个参数</span></span><br><span class="line"><span class="comment">// 一共有n个格子，每个格子可以涂上一种颜色，颜色在m种里选</span></span><br><span class="line"><span class="comment">// 当涂满n个格子，并且m种颜色都使用了，叫一种有效方法</span></span><br><span class="line"><span class="comment">// 求一共有多少种有效的涂色方法</span></span><br><span class="line"><span class="comment">// 1 &lt;= n, m &lt;= 5000</span></span><br><span class="line"><span class="comment">// 结果比较大请 % 1000000007 之后返回</span></span><br><span class="line"><span class="comment">// 对数器验证</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FillCellsUseAllColorsWays</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前n个格子，涂m种颜色，一共有多少种有效的涂色方法</span></span><br><span class="line">    <span class="comment">//当前i个格子，涂满j种颜色，一共有多少种有效的涂色方法</span></span><br><span class="line">    <span class="comment">//怎么分析子问题呢？ 当前第i个格子有几种涂法？</span></span><br><span class="line">    <span class="comment">//如果前面格子已经涂满了j种颜色，则当前格子涂法为j种（当前颜色任意涂）</span></span><br><span class="line">    <span class="comment">//若前面格子只涂了j - 1种颜色，则当前格子涂法为 m - (j - 1)</span></span><br><span class="line">    <span class="comment">//dp[i][j] = &#123;</span></span><br><span class="line">    <span class="comment">//1.dp[i - 1][j] * j</span></span><br><span class="line">    <span class="comment">//2.dp[i - 1][j - 1] * (m - (j - 1))</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ways0</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//填充边界值</span></span><br><span class="line">        <span class="comment">//i个格子填一种颜色共有m种方法</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = m;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从左到右填充</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                dp[i][j] = (<span class="type">int</span>) ((<span class="type">long</span>)dp[i - <span class="number">1</span>][j] * j % mod);</span><br><span class="line">                dp[i][j] = (<span class="type">int</span>) (((<span class="type">long</span>)dp[i - <span class="number">1</span>][j - <span class="number">1</span>] * (m - (j - <span class="number">1</span>)) + dp[i][j]) % mod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 暴力方法</span></span><br><span class="line">    <span class="comment">// 为了验证</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ways1</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> f(<span class="keyword">new</span> <span class="title class_">int</span>[n], <span class="keyword">new</span> <span class="title class_">boolean</span>[m + <span class="number">1</span>], <span class="number">0</span>, n, m);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把所有填色的方法暴力枚举</span></span><br><span class="line">    <span class="comment">// 然后一个一个验证是否有效</span></span><br><span class="line">    <span class="comment">// 这是一个带路径的递归</span></span><br><span class="line">    <span class="comment">// 无法改成动态规划</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] path, <span class="type">boolean</span>[] set, <span class="type">int</span> i, <span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            Arrays.fill(set, <span class="literal">false</span>);</span><br><span class="line">            <span class="type">int</span> <span class="variable">colors</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> c : path) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!set[c]) &#123;</span><br><span class="line">                    set[c] = <span class="literal">true</span>;</span><br><span class="line">                    colors++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> colors == m ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                path[i] = j;</span><br><span class="line">                ans += f(path, set, i + <span class="number">1</span>, n, m);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 正式方法</span></span><br><span class="line">    <span class="comment">// 时间复杂度O(n * m)</span></span><br><span class="line">    <span class="comment">// 已经展示太多次从递归到动态规划了</span></span><br><span class="line">    <span class="comment">// 直接写动态规划吧</span></span><br><span class="line">    <span class="comment">// 也不做空间压缩了，因为千篇一律</span></span><br><span class="line">    <span class="comment">// 有兴趣的同学自己试试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">5001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">ways2</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="comment">// dp[i][j]:</span></span><br><span class="line">        <span class="comment">// 一共有m种颜色</span></span><br><span class="line">        <span class="comment">// 前i个格子涂满j种颜色的方法数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">1</span>] = m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                dp[i][j] = (<span class="type">int</span>) (((<span class="type">long</span>) dp[i - <span class="number">1</span>][j] * j) % mod);</span><br><span class="line">                dp[i][j] = (<span class="type">int</span>) ((((<span class="type">long</span>) dp[i - <span class="number">1</span>][j - <span class="number">1</span>] * (m - j + <span class="number">1</span>)) + dp[i][j]) % mod);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 测试的数据量比较小</span></span><br><span class="line">        <span class="comment">// 那是因为数据量大了，暴力方法过不了</span></span><br><span class="line">        <span class="comment">// 但是这个数据量足够说明正式方法是正确的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">9</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;功能测试开始&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">1</span>; n &lt;= N; n++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">1</span>; m &lt;= M; m++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> ways1(n, m);</span><br><span class="line">                <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> ways0(n, m);</span><br><span class="line">                <span class="keyword">if</span> (ans1 != ans2) &#123;</span><br><span class="line">                    System.out.println(<span class="string">&quot;出错了!&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;功能测试结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;性能测试开始&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">5000</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">4877</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;n : &quot;</span> + n);</span><br><span class="line">        System.out.println(<span class="string">&quot;m : &quot;</span> + m);</span><br><span class="line">        <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> ways2(n, m);</span><br><span class="line">        <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;取余之后的结果 : &quot;</span> + ans);</span><br><span class="line">        System.out.println(<span class="string">&quot;运行时间 : &quot;</span> + (end - start) + <span class="string">&quot; 毫秒&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;性能测试结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二维动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>InterleavingString</title>
      <link href="/2024/09/12/InterleavingString/"/>
      <url>/2024/09/12/InterleavingString/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.二维动态规划;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/9/12 11:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 交错字符串</span></span><br><span class="line"><span class="comment">// 给定三个字符串 s1、s2、s3</span></span><br><span class="line"><span class="comment">// 请帮忙验证s3是否由s1和s2交错组成</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/interleaving-string/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">InterleavingString</span> &#123;</span><br><span class="line">    <span class="comment">//dp&#123;i][j] 定义 s1[前i个字符] 和 s1[前j个字符] 能否组成s3[前i + j个字符]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//那就是取s1字符或取s2字符，组成当前s3字符</span></span><br><span class="line">    <span class="comment">//讨论s3末置位字符，要么取s1[i - 1]，要么取s2[j - 1]</span></span><br><span class="line">    <span class="comment">//得出下面转移方程      取s1,则看dp[i-1][j],因为j未取，i取了一个，即i -1</span></span><br><span class="line">    <span class="comment">//dp[i][j] = (s1[i - 1] == s3[i + j - 1] &amp;&amp; dp[i - 1][j]) || (s2[j - 1] == s3[i + j - 1] &amp;&amp; dp[i][j - 1]);</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterleave1</span><span class="params">(String s1, String s2, String s3)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s2.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length();</span><br><span class="line">        <span class="keyword">if</span> (n + m != s3.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] c1 = s1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] c2 = s2.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] c3 = s3.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[][] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//空串</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//填充边界</span></span><br><span class="line">        <span class="comment">//第一行 判断s2每个字符是否组成s3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c3[j - <span class="number">1</span>] != c2[j - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一列 判断s1每个字符是否组成s3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c3[i - <span class="number">1</span>] != c1[i - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">//要么取 s1, 要么取s2</span></span><br><span class="line">                dp[i][j] = (c1[i - <span class="number">1</span>] == c3[i + j - <span class="number">1</span>] &amp;&amp; dp[i - <span class="number">1</span>][j]) || (c2[j - <span class="number">1</span>] == c3[i + j - <span class="number">1</span>] &amp;&amp; dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空间压缩</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isInterleave</span><span class="params">(String s1, String s2, String s3)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> s2.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s1.length();</span><br><span class="line">        <span class="keyword">if</span> (n + m != s3.length())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">char</span>[] c1 = s1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] c2 = s2.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] c3 = s3.toCharArray();</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[] dp = <span class="keyword">new</span> <span class="title class_">boolean</span>[m + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//第一行 判断s2每个字符是否组成s3</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c3[j - <span class="number">1</span>] != c2[j - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[j] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">//注意这里别漏了dp[0]的定义，因为下面是从dp[1]开始的</span></span><br><span class="line">            dp[<span class="number">0</span>] = c3[i - <span class="number">1</span>] == c1[i - <span class="number">1</span>] &amp;&amp; dp[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">//要么取 s1, 要么取s2</span></span><br><span class="line">                <span class="comment">//原二维dp取上一个或者取左边</span></span><br><span class="line">                dp[j] = (c1[i - <span class="number">1</span>] == c3[i + j - <span class="number">1</span>] &amp;&amp; dp[j]) || (c2[j - <span class="number">1</span>] == c3[i + j - <span class="number">1</span>] &amp;&amp; dp[j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二维动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>EditDistance</title>
      <link href="/2024/09/11/EditDistance/"/>
      <url>/2024/09/11/EditDistance/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.二维动态规划;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/9/11 15:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 编辑距离</span></span><br><span class="line"><span class="comment">// 给你两个单词 word1 和 word2</span></span><br><span class="line"><span class="comment">// 请返回将 word1 转换成 word2 所使用的最少代价</span></span><br><span class="line"><span class="comment">// 你可以对一个单词进行如下三种操作：</span></span><br><span class="line"><span class="comment">// 插入一个字符，代价a</span></span><br><span class="line"><span class="comment">// 删除一个字符，代价b</span></span><br><span class="line"><span class="comment">// 替换一个字符，代价c</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/edit-distance/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EditDistance</span> &#123;</span><br><span class="line">    <span class="comment">//定义dp[i][j] 为 s[前缀长为i] 变成 t[前缀长为j]要经过多少操作</span></span><br><span class="line">    <span class="comment">//s[i -1] == t [j - 1] , dp[i - 1][j - 1],操作0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当不相等时</span></span><br><span class="line">    <span class="comment">//这是原有分析！！！！！</span></span><br><span class="line">    <span class="comment">//从末置位字符不等分析，难点在于选哪个操作</span></span><br><span class="line">    <span class="comment">//s[i - 2] == t[j - 1], 删除操作 dp[i - 1][j] + 1</span></span><br><span class="line">    <span class="comment">//其余进行替换操作，   dp[i-1][j-1] + 1</span></span><br><span class="line">    <span class="comment">// 当i &lt; j时，新增操作  dp[i][j-1] + 1</span></span><br><span class="line">    <span class="comment">//正确分析！！！！</span></span><br><span class="line">    <span class="comment">//每个操作都试一遍，取最小值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//分析边界值，当j == 0 , i = i</span></span><br><span class="line">    <span class="comment">// 当 i == 0, j == j</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minDistance</span><span class="params">(String word1, String word2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = word1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] t = word2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> t.length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//填充边界值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;<span class="comment">//全部删除操作</span></span><br><span class="line">            dp[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123;<span class="comment">//全部新增操作</span></span><br><span class="line">            dp[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从上往下，左到右递推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>]) &#123;<span class="comment">//不操作</span></span><br><span class="line">                    dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//原计划不行</span></span><br><span class="line"><span class="comment">//                    if (i - 2 &gt;= 0 &amp;&amp; s[i - 2] == t[j - 1])&#123;//删除操作</span></span><br><span class="line"><span class="comment">//                        dp[i][j] = dp[i - 1][j] + 1;</span></span><br><span class="line"><span class="comment">//                    &#125;else if (i &lt; j)&#123;//新增操作</span></span><br><span class="line"><span class="comment">//                        dp[i][j] = dp[i][j - 1] + 1;</span></span><br><span class="line"><span class="comment">//                    &#125;else &#123;//替换操作</span></span><br><span class="line"><span class="comment">//                        dp[i][j] = dp[i - 1][j - 1] + 1;</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line">                    <span class="comment">//直接每种操作都试一遍，取最小值</span></span><br><span class="line">                    <span class="comment">//删除操作</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> dp[i][j] = dp[i - <span class="number">1</span>][j] + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//新增操作</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> dp[i][j] = dp[i][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    <span class="comment">//替换操作</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">p3</span> <span class="operator">=</span> dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">                    dp[i][j] = Math.min(Math.min(p1, p2) ,p3);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二维动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DistinctSubsequences</title>
      <link href="/2024/09/11/DistinctSubsequences/"/>
      <url>/2024/09/11/DistinctSubsequences/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.二维动态规划;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/9/11 14:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同的子序列</span></span><br><span class="line"><span class="comment">// 给你两个字符串s和t ，统计并返回在s的子序列中t出现的个数</span></span><br><span class="line"><span class="comment">// 答案对1000000007取余</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/distinct-subsequences/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistinctSubsequences</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//针对左边的字符i取不取，从而决定右边字符下标是否前进</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct1</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] arr1 = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] arr2 = t.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> arr2.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                dp[i][j] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f1(arr1, arr2, <span class="number">0</span>, <span class="number">0</span>, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接记忆化搜索</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">(<span class="type">char</span>[] s, <span class="type">char</span>[] t, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[][] dp)</span>&#123;</span><br><span class="line">        <span class="comment">//顺利走完全程，该种取法成立</span></span><br><span class="line">        <span class="keyword">if</span> (j == t.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//源字符走完全程，还没出现t</span></span><br><span class="line">        <span class="keyword">if</span> (i == s.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][j] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//相同取和不取都可</span></span><br><span class="line">        <span class="keyword">if</span> (s[i] == t[j])&#123;</span><br><span class="line">            ans = (ans + (<span class="type">long</span>) f1(s, t, i + <span class="number">1</span>, j + <span class="number">1</span>, dp) % MOD) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        ans = (ans + (<span class="type">long</span>) f1(s, t, i + <span class="number">1</span>, j, dp) % MOD) % MOD;</span><br><span class="line">        dp[i][j] = (<span class="type">int</span>) ans;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//严格位置依赖的dp</span></span><br><span class="line">    <span class="comment">//分析递归，上面的值由下面决定， 所以从底部往上推</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct2</span><span class="params">(String s1, String t1)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = s1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] t = t1.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> t.length;</span><br><span class="line">        <span class="type">long</span>[][] dp = <span class="keyword">new</span> <span class="title class_">long</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//填充固定值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][m] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="comment">//相同取和不取都可</span></span><br><span class="line">                <span class="keyword">if</span> (s[i] == t[j])&#123;</span><br><span class="line">                    dp[i][j] = (dp[i][j] + dp[i + <span class="number">1</span>][j + <span class="number">1</span>] % MOD) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = (dp[i][j] + dp[i + <span class="number">1</span>][j] % MOD) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以末置位来分析dp，</span></span><br><span class="line">    <span class="comment">// dp[i][j] 定义为 s[前缀长度为i]的所有子序列中，有多少个子序列等于t[前缀长度为j]</span></span><br><span class="line">    <span class="comment">// 核心点在于怎么分析子问题：</span></span><br><span class="line">    <span class="comment">//以末置位来分析 -》 s[i - 1]字符 是否取</span></span><br><span class="line">    <span class="comment">// dp[i][j] &#123;</span></span><br><span class="line">    <span class="comment">//1.dp[i-1][j]  //不取当前字符</span></span><br><span class="line">    <span class="comment">//2.s[i - 1] == t[j-1], dp[i-1][j-1]  //取当前字符</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDistinct</span><span class="params">(String s1, String t1)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] s = s1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] t = t1.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> t.length;</span><br><span class="line">        <span class="type">long</span>[][] dp = <span class="keyword">new</span> <span class="title class_">long</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//填充固定值  对应t 为空串时，有空集和s对应</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">//相同取和不取都可</span></span><br><span class="line">                <span class="keyword">if</span> (s[i - <span class="number">1</span>] == t[j - <span class="number">1</span>])&#123;</span><br><span class="line">                    dp[i][j] = (dp[i][j] + dp[i - <span class="number">1</span>][j - <span class="number">1</span>] % MOD) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">                dp[i][j] = (dp[i][j] + dp[i - <span class="number">1</span>][j] % MOD) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二维动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LongestIncreasingPath</title>
      <link href="/2024/09/10/LongestIncreasingPath/"/>
      <url>/2024/09/10/LongestIncreasingPath/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.二维动态规划;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 困难标签的简单题，很难改成位置依赖的dp，直接记忆化搜索即可</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/9/10 17:56</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongestIncreasingPath</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, m;</span><br><span class="line">    <span class="comment">//暴力递归， i,j,</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestIncreasingPath1</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        n = matrix.length;</span><br><span class="line">        m = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从每个位置出发，遍历获取最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                ans = Math.max(ans, f1(i,j,matrix));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用当前参数对比四周，看哪个方向能递增。 遍历4个方向，取最大答案</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[][] matrix)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">        <span class="type">int</span> <span class="variable">up</span> <span class="operator">=</span> <span class="number">0</span>, down = <span class="number">0</span>, left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; n &amp;&amp; cur &lt; matrix[i + <span class="number">1</span>][j])&#123;</span><br><span class="line">            down = f1(i + <span class="number">1</span>, j, matrix);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; cur &lt; matrix[i - <span class="number">1</span>][j])&#123;</span><br><span class="line">            up = f1(i - <span class="number">1</span>, j, matrix);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; m &amp;&amp; cur &lt; matrix[i][j + <span class="number">1</span>])&#123;</span><br><span class="line">            right = f1(i, j + <span class="number">1</span>, matrix);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; cur &lt; matrix[i][j - <span class="number">1</span>])&#123;</span><br><span class="line">            left = f1(i, j - <span class="number">1</span>, matrix);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//四个方向取最大值</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + Math.max(Math.max(up, down), Math.max(left, right));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记忆化搜索</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestIncreasingPath</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        n = matrix.length;</span><br><span class="line">        m = matrix[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                dp[i][j] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从每个位置出发，遍历获取最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                ans = Math.max(ans, f2(i,j,matrix, dp));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用当前参数对比四周，看哪个方向能递增。 遍历4个方向，取最大答案</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[][] matrix, <span class="type">int</span>[][] dp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][j] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> matrix[i][j];</span><br><span class="line">        <span class="type">int</span> <span class="variable">up</span> <span class="operator">=</span> <span class="number">0</span>, down = <span class="number">0</span>, left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; n &amp;&amp; cur &lt; matrix[i + <span class="number">1</span>][j])&#123;</span><br><span class="line">            down = f2(i + <span class="number">1</span>, j, matrix, dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; cur &lt; matrix[i - <span class="number">1</span>][j])&#123;</span><br><span class="line">            up = f2(i - <span class="number">1</span>, j, matrix, dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; m &amp;&amp; cur &lt; matrix[i][j + <span class="number">1</span>])&#123;</span><br><span class="line">            right = f2(i, j + <span class="number">1</span>, matrix, dp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span> &amp;&amp; cur &lt; matrix[i][j - <span class="number">1</span>])&#123;</span><br><span class="line">            left = f2(i, j - <span class="number">1</span>, matrix, dp);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//四个方向取最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span> + Math.max(Math.max(up, down), Math.max(left, right));</span><br><span class="line">        dp[i][j] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//严格位置依赖的dp  哦吼，不好改，看了答案也没dp</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二维动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NodenHeightNotLargerThanm</title>
      <link href="/2024/09/10/NodenHeightNotLargerThanm/"/>
      <url>/2024/09/10/NodenHeightNotLargerThanm/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.二维动态规划;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>  经典题，递归思路可以记下</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/9/10 11:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 节点数为n高度不大于m的二叉树个数</span></span><br><span class="line"><span class="comment">// 现在有n个节点，计算出有多少个不同结构的二叉树</span></span><br><span class="line"><span class="comment">// 满足节点个数为n且树的高度不超过m的方案</span></span><br><span class="line"><span class="comment">// 因为答案很大，所以答案需要模上1000000007后输出</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.nowcoder.com/practice/aaefe5896cce4204b276e213e725f3ea</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下所有代码，把主类名改成Main，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NodenHeightNotLargerThanm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">int</span>) in.nval;</span><br><span class="line">            in.nextToken();</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (<span class="type">int</span>) in.nval;</span><br><span class="line">            out.println(compute2(n, m));</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">51</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">    <span class="comment">// 记忆化搜索</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span>[][] dp1 = <span class="keyword">new</span> <span class="title class_">long</span>[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAXN; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; MAXN; j++) &#123;</span><br><span class="line">                dp1[i][j] = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没分析出正确的递归的思路，看了答案其实和前几题递归挺类似</span></span><br><span class="line">    <span class="comment">//思路：以头节点来定递归，总数为n，高度为m，</span></span><br><span class="line">    <span class="comment">// 左树取k个，右数只能取n-k-1个，要求左右树高度都不超过m - 1，然后各自递归</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接记忆化搜索版本</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute1</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span>&#123;</span><br><span class="line">        <span class="comment">//空树也是一种结构</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//n 大于0， 却要求高度等于0， 不存在</span></span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp1[n][m] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>) dp1[n][m];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//以当前节点为头节点定递归</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//左子树取i个，右子树只能取n - i - 1个</span></span><br><span class="line">            <span class="comment">//左右子树结构数相乘,</span></span><br><span class="line">            <span class="comment">//把循环的所有结果加上</span></span><br><span class="line">            ans = (ans + (<span class="type">long</span>) compute1(i, m - <span class="number">1</span>) * compute1(n - i - <span class="number">1</span>, m - <span class="number">1</span>) % MOD) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        dp1[n][m] = ans;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dp</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span>[][] dp2 = <span class="keyword">new</span> <span class="title class_">long</span>[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//严格位置依赖的dp</span></span><br><span class="line">    <span class="comment">//观察递归，发现依赖的位置， 列都是m - 1, 行都是小于n，即只要左边列且小于当前行的dp[x]</span></span><br><span class="line">    <span class="comment">//所以按照从左到右的递推</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute2</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第一行都是1  base case（n == 0)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp2[<span class="number">0</span>][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接套两层for循环（因为是二维dp）</span></span><br><span class="line">        <span class="comment">//注意从1开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">//先重置0</span></span><br><span class="line">                dp2[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//再代入原递归逻辑</span></span><br><span class="line">                <span class="comment">// 注意这里原逻辑的n 要变成i</span></span><br><span class="line">                <span class="comment">//m 变成j</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">                    <span class="comment">//左子树取i个，右子树只能取n - i - 1个</span></span><br><span class="line">                    <span class="comment">//左右子树结构数相乘,</span></span><br><span class="line">                    <span class="comment">//把循环的所有结果加上</span></span><br><span class="line">                    dp2[i][j] = (dp2[i][j] + dp2[k][j - <span class="number">1</span>] * dp2[i - k - <span class="number">1</span>][j - <span class="number">1</span>] % MOD) % MOD;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) dp2[n][m];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二维动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LongestPalindromeSubseq</title>
      <link href="/2024/09/10/LongestPalindromeSubseq/"/>
      <url>/2024/09/10/LongestPalindromeSubseq/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.二维动态规划;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/9/10 11:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最长回文子序列</span></span><br><span class="line"><span class="comment">// 给你一个字符串 s ，找出其中最长的回文子序列，并返回该序列的长度</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/longest-palindromic-subsequence/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongestPalindromeSubseq</span> &#123;</span><br><span class="line">    <span class="comment">//这题可以转换为最长公共子序列去做，用原字符串取反去获取最长公共子序列即可</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里是常规分析题目，暴力递归做法</span></span><br><span class="line">    <span class="comment">//因为是要找回文子序列，所以只要递归比对首末两个字符是否相等即可（中间不等的可以删除从而形成回文串）</span></span><br><span class="line">    <span class="comment">//1、当相等时，直接取当前长度 + 递归下一个的结果</span></span><br><span class="line">    <span class="comment">//2、不等时，取左和取右，再取递归结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq1</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="keyword">return</span> f1(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">(<span class="type">char</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//单个字符也能形成回文串</span></span><br><span class="line">        <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[l] == arr[r])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span> + f1(arr, l + <span class="number">1</span>, r - <span class="number">1</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不取左和不取右去对比</span></span><br><span class="line">            <span class="keyword">return</span>  Math.max(f1(arr, l + <span class="number">1</span>, r), f1(arr, l, r - <span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f2(arr, <span class="number">0</span>, n - <span class="number">1</span>, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记忆化搜索</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f2</span><span class="params">(<span class="type">char</span>[] arr, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span>[][] dp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//单个字符也能形成回文串</span></span><br><span class="line">        <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (dp[l][r] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[l][r];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans;</span><br><span class="line">        <span class="keyword">if</span> (arr[l] == arr[r])&#123;</span><br><span class="line">            ans = <span class="number">2</span> + f2(arr, l + <span class="number">1</span>, r - <span class="number">1</span>, dp);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//不取左和不取右去对比</span></span><br><span class="line">            ans = Math.max(f2(arr, l + <span class="number">1</span>, r, dp), f2(arr, l, r - <span class="number">1</span>, dp));</span><br><span class="line">        &#125;</span><br><span class="line">        dp[l][r] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//严格位置依赖的dp</span></span><br><span class="line">    <span class="comment">//从递归观察，先填充固定值，再搬迁原有递归逻辑（dp转移方程）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq3</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="comment">//填充固定值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从底部，从左往右递推。（递归观察而来，左下，左，下才决定当前值）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> n - <span class="number">2</span>; l &gt;= <span class="number">0</span>; l--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; n; r++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (l &lt; r)&#123;</span><br><span class="line">                    <span class="comment">//搬迁原有递归逻辑</span></span><br><span class="line">                    <span class="keyword">if</span> (arr[l] == arr[r]) &#123;</span><br><span class="line">                        dp[l][r] = <span class="number">2</span> + dp[l + <span class="number">1</span>][r - <span class="number">1</span>];</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//不取左和不取右去对比</span></span><br><span class="line">                        dp[l][r] = Math.max(dp[l + <span class="number">1</span>][r], dp[l][r - <span class="number">1</span>]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//严格位置依赖的dp + 空间压缩</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestPalindromeSubseq</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从底部，从左往右递推。（递归观察而来，左下，左，下才决定当前值）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> n - <span class="number">1</span>; l &gt;= <span class="number">0</span>; l--) &#123;</span><br><span class="line">            <span class="comment">//填充固定值 ( l == r)</span></span><br><span class="line">            dp[l] = <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">leftdown</span> <span class="operator">=</span> <span class="number">0</span>, backup;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; n; r++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (l &lt; r)&#123;<span class="comment">//只有上半部分才计算</span></span><br><span class="line">                    <span class="comment">//第一次进来这个条件的leftdown都是0</span></span><br><span class="line">                    <span class="comment">// 刚好对应上轮次的dp值，即下轮次左下角值</span></span><br><span class="line">                    backup = dp[r];</span><br><span class="line">                    <span class="comment">//搬迁原有递归逻辑</span></span><br><span class="line">                    <span class="keyword">if</span> (arr[l] == arr[r]) &#123;</span><br><span class="line">                        <span class="comment">//左下角值</span></span><br><span class="line">                        dp[r] = <span class="number">2</span> + leftdown;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">//左边的值 和 下面的值（当前旧值）做对比</span></span><br><span class="line">                        dp[r] = Math.max(dp[r - <span class="number">1</span>], dp[r]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    leftdown = backup;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二维动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LongestCommonSubsequence</title>
      <link href="/2024/09/09/LongestCommonSubsequence/"/>
      <url>/2024/09/09/LongestCommonSubsequence/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.二维动态规划;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 经典题，但没思路，记住思路吧</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/9/9 16:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最长公共子序列</span></span><br><span class="line"><span class="comment">// 给定两个字符串text1和text2</span></span><br><span class="line"><span class="comment">// 返回这两个字符串的最长 公共子序列 的长度</span></span><br><span class="line"><span class="comment">// 如果不存在公共子序列，返回0</span></span><br><span class="line"><span class="comment">// 两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/longest-common-subsequence/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongestCommonSubsequence</span> &#123;</span><br><span class="line">    <span class="comment">//没思路</span></span><br><span class="line">    <span class="comment">//看了答案，有点抽象的递归。好像很多题目都是 取或不取的思路</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence1</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] array1 = text1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] array2 = text2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> array1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> array2.length;</span><br><span class="line">        <span class="keyword">return</span> f1(array1, array2, n - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暴力递归</span></span><br><span class="line">    <span class="comment">//i,j表索引</span></span><br><span class="line">    <span class="comment">//思路： 针对当前位置字符，取或不取：</span></span><br><span class="line">    <span class="comment">//1、都不取，则去获取f1(i - 1, j- 1)答案</span></span><br><span class="line">    <span class="comment">//2、取一个，不取一个：</span></span><br><span class="line">    <span class="comment">//  f1(i - 1, j), f1(i, j- 1) 各获取答案</span></span><br><span class="line">    <span class="comment">//3、若arr1[i] == arr2[j]  则获取 情况1 的答案  再加 1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">(<span class="type">char</span>[] arr1, <span class="type">char</span>[] arr2, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="comment">//越界，返回0的长度</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//都不取</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> f1(arr1, arr2, i - <span class="number">1</span>, j - <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//只取一侧</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> f1(arr1, arr2, i, j - <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans3</span> <span class="operator">=</span> f1(arr1, arr2, i - <span class="number">1</span>, j);</span><br><span class="line">        <span class="comment">//当前字符相同，都取，获取下一个答案</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans4</span> <span class="operator">=</span> arr1[i] == arr2[j] ? ans1 + <span class="number">1</span> : ans1;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回最大长度</span></span><br><span class="line">        <span class="keyword">return</span>  Math.max(Math.max(ans1, ans2), Math.max(ans3, ans4));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence2</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] array1 = text1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] array2 = text2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> array1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> array2.length;</span><br><span class="line">        <span class="keyword">return</span> f2(array1, array2, n - <span class="number">1</span>, m - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//避免边界讨论的递归</span></span><br><span class="line">    <span class="comment">//len代表从0 到 len - 1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f2</span><span class="params">(<span class="type">char</span>[] arr1, <span class="type">char</span>[] arr2, <span class="type">int</span> len1, <span class="type">int</span> len2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">0</span> || len2 == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//小优化</span></span><br><span class="line">        <span class="comment">//只要相等，直接取用，并探讨下一个递归答案。 如果不取用，即使前面有相同字符，但该范围结果也缩小了</span></span><br><span class="line">        <span class="keyword">if</span> (arr1[len1 - <span class="number">1</span>] == arr2[len2 - <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> f2(arr1, arr2, len1 - <span class="number">1</span>, len2 - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//去除了 都不取的情况，因为都不取的情况 答案范围是小于下面两种情况的</span></span><br><span class="line">            <span class="keyword">return</span> Math.max(f2(arr1, arr2, len1, len2 - <span class="number">1</span>), f2(arr1, arr2, len1 - <span class="number">1</span>, len2));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记忆化搜素</span></span><br><span class="line">    <span class="comment">//避免边界讨论的递归</span></span><br><span class="line">    <span class="comment">//len代表从0 到 len - 1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence3</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] array1 = text1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] array2 = text2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> array1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> array2.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f3(array1, array2, n, m, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f3</span><span class="params">(<span class="type">char</span>[] arr1, <span class="type">char</span>[] arr2, <span class="type">int</span> len1, <span class="type">int</span> len2, <span class="type">int</span>[][] dp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (len1 == <span class="number">0</span> || len2 == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[len1][len2] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[len1][len2];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans;</span><br><span class="line">        <span class="comment">//只要相等，直接取用，并探讨下一个递归答案。 如果不取用，即使前面有相同字符，但该范围结果也缩小了</span></span><br><span class="line">        <span class="keyword">if</span> (arr1[len1 - <span class="number">1</span>] == arr2[len2 - <span class="number">1</span>])&#123;</span><br><span class="line">            ans = f3(arr1, arr2, len1 - <span class="number">1</span>, len2 - <span class="number">1</span>, dp) + <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//去除了 都不取的情况，因为都不取的情况 答案范围是小于下面两种情况的</span></span><br><span class="line">            ans = Math.max(f3(arr1, arr2, len1, len2 - <span class="number">1</span>, dp), f3(arr1, arr2, len1 - <span class="number">1</span>, len2, dp));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dp[len1][len2] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//严格位置依赖的dp</span></span><br><span class="line">    <span class="comment">//观察递归很容易得到转移方程</span></span><br><span class="line">    <span class="comment">// dp[i][j] = arr[i] == arr[j] ? dp[i - 1][j - 1] + 1 : Math.max(dp[i - 1][j], dp[i][j - 1]);</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence4</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] arr1 = text1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] arr2 = text2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> arr2.length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先填充边界 递归的base case</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= m; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> <span class="number">1</span>; len1 &lt;= n; len1++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> <span class="number">1</span>; len2 &lt;= m; len2++) &#123;</span><br><span class="line">                <span class="comment">//照搬的递归原逻辑</span></span><br><span class="line"><span class="comment">//                if (arr1[len1 - 1] == arr2[len2 - 1])&#123;</span></span><br><span class="line"><span class="comment">//                    dp[len1][len2] = dp[len1 - 1][len2 - 1] + 1;</span></span><br><span class="line"><span class="comment">//                &#125;else &#123;</span></span><br><span class="line"><span class="comment">//                    //去除了 都不取的情况，因为都不取的情况 答案范围是小于下面两种情况的</span></span><br><span class="line"><span class="comment">//                    dp[len1][len2] = Math.max(dp[len1 - 1][len2], dp[len1][len2 - 1]);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//直接套转移方程</span></span><br><span class="line">                dp[len1][len2] = arr1[len1 - <span class="number">1</span>] == arr2[len2 - <span class="number">1</span>] ? dp[len1 - <span class="number">1</span>][len2 - <span class="number">1</span>] + <span class="number">1</span> : Math.max(dp[len1 - <span class="number">1</span>][len2], dp[len1][len2 - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n][m];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//严格位置依赖的dp + 空间压缩的dp</span></span><br><span class="line">    <span class="comment">//基本就是原dp，只是在第二层循环那里处理dp数组</span></span><br><span class="line">    <span class="comment">//用一维数组轮次更新，代替二维数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestCommonSubsequence</span><span class="params">(String text1, String text2)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] arr1 = text1.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] arr2 = text2.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr1.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> arr2.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//先填充边界 递归的base case</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= m; i++) &#123;</span><br><span class="line">            dp[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="comment">//左上角的值,用于更新下一个左上角值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> <span class="number">0</span>, backUp;</span><br><span class="line">            <span class="comment">//更新当轮次数组值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">//当前旧值就是下一个左上角值</span></span><br><span class="line">                backUp = dp[j];</span><br><span class="line">                dp[j] = arr1[i - <span class="number">1</span>] == arr2[j - <span class="number">1</span>] ? tmp + <span class="number">1</span> : Math.max(dp[j - <span class="number">1</span>], dp[j]);</span><br><span class="line">                tmp = backUp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二维动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WordSearch</title>
      <link href="/2024/09/08/WordSearch/"/>
      <url>/2024/09/08/WordSearch/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.二维动态规划;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/9/8 16:50</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单词搜索（无法改成动态规划）</span></span><br><span class="line"><span class="comment">// 给定一个 m x n 二维字符网格 board 和一个字符串单词 word</span></span><br><span class="line"><span class="comment">// 如果 word 存在于网格中，返回 true ；否则，返回 false 。</span></span><br><span class="line"><span class="comment">// 单词必须按照字母顺序，通过相邻的单元格内的字母构成</span></span><br><span class="line"><span class="comment">// 其中&quot;相邻&quot;单元格是那些水平相邻或垂直相邻的单元格</span></span><br><span class="line"><span class="comment">// 同一个单元格内的字母不允许被重复使用</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/word-search/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WordSearch</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> n ,m, len;</span><br><span class="line">    <span class="comment">//一般这种类型的题目都是遍历每个格子出发， 然后再递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">        n = board.length;</span><br><span class="line">        m = board[<span class="number">0</span>].length;</span><br><span class="line">        len = word.length();</span><br><span class="line">        <span class="type">char</span>[] array = word.toCharArray();</span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][m];</span><br><span class="line">        <span class="comment">//从每个位置出发寻找</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (f1(array, board, i, j, <span class="number">0</span>, visited))&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">f1</span><span class="params">(<span class="type">char</span>[] tar, <span class="type">char</span>[][] board, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> index, <span class="type">boolean</span>[][] visited)</span>&#123;</span><br><span class="line">        <span class="comment">//找齐所有字母了，返回true</span></span><br><span class="line">        <span class="keyword">if</span> (index == len)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//越界returnfalse</span></span><br><span class="line">        <span class="keyword">if</span> (i == n || j == m || i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || board[i][j] != tar[index])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (visited[i][j])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//从当前位置出发，上下左右找目前字符</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span>  f1(tar, board, i, j + <span class="number">1</span>, index + <span class="number">1</span>, visited) || f1(tar, board, i, j - <span class="number">1</span>, index + <span class="number">1</span>, visited)</span><br><span class="line">                || f1(tar, board, i + <span class="number">1</span>, j, index + <span class="number">1</span>, visited) ||  f1(tar, board, i - <span class="number">1</span>, j, index + <span class="number">1</span>, visited);</span><br><span class="line"></span><br><span class="line">        visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二维动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinPathSum</title>
      <link href="/2024/09/06/MinPathSum/"/>
      <url>/2024/09/06/MinPathSum/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.二维动态规划;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/9/6 15:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小路径和</span></span><br><span class="line"><span class="comment">// 给定一个包含非负整数的 m x n 网格 grid</span></span><br><span class="line"><span class="comment">// 请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</span></span><br><span class="line"><span class="comment">// 说明：每次只能向下或者向右移动一步。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/minimum-path-sum/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinPathSum</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//第一想法就是DJ最短路径算法</span></span><br><span class="line">    <span class="comment">//因为每次只能向下或向右移动，所有dp应该更简单</span></span><br><span class="line">    <span class="comment">//先尝试递归做法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum1</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">return</span> f1(n - <span class="number">1</span>,  m - <span class="number">1</span>, grid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归的思路：</span></span><br><span class="line">    <span class="comment">//盘终点的左边和上面的点，哪个最小就取哪个。 递归盘下去知道零点位置</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[][] grid)</span>&#123;</span><br><span class="line">        <span class="comment">//只剩一个点了，直接该点的值</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> grid[i][j];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">up</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="comment">//加上当前位置，去递归加上剩下路径的位置</span></span><br><span class="line">            <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                up = grid[i][j] + f1(i - <span class="number">1</span>, j, grid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                left = grid[i][j] + f1(i , j - <span class="number">1</span>, grid);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较路径总和哪个小</span></span><br><span class="line">            <span class="comment">//这一点就已经盘了能到此点的最小路径值了</span></span><br><span class="line">            <span class="keyword">return</span> Math.min(up, left);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记忆化搜索</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum2</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Arrays.fill(dp[i], <span class="number">0</span>, m, Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f2(n - <span class="number">1</span>,  m - <span class="number">1</span>, grid, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[][] grid, <span class="type">int</span>[][] dp)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][j] != Integer.MAX_VALUE)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[i][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> ans;</span><br><span class="line">        <span class="comment">//只剩一个点了，直接该点的值</span></span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>)&#123;</span><br><span class="line">            ans = grid[i][j];</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">up</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">            <span class="comment">//加上当前位置，去递归加上剩下路径的位置</span></span><br><span class="line">            <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                up = grid[i][j] + f2(i - <span class="number">1</span>, j, grid, dp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                left = grid[i][j] + f2(i , j - <span class="number">1</span>, grid, dp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//比较路径总和哪个小</span></span><br><span class="line">            <span class="comment">//这一点就已经盘了能到此点的最小路径值了</span></span><br><span class="line">            ans = Math.min(up, left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//到这一点的路径和最小值</span></span><br><span class="line">        dp[i][j] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//严格位置依赖的动态规划</span></span><br><span class="line">    <span class="comment">//需要从递归观察dp[i][j] 和其他位置的关系，即观察分析得出dp转移方程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum3</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//从递归可知，底部依赖左边和上面的值，即整个递推方向是往右斜下方的</span></span><br><span class="line">        <span class="comment">//所以先最左边和最上面的值，因为这里的值都是可以确定的</span></span><br><span class="line">        <span class="comment">//填充左边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i - <span class="number">1</span>][<span class="number">0</span>] + grid[i][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//填充上边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//递推往右下角填充整个dp数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">                dp[i][j] = Math.min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>][m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 严格位置依赖的动态规划 + 空间压缩技巧</span></span><br><span class="line">    <span class="comment">//空间压缩技巧： 只用一维数组，讨论左边和上面的值，每轮都更新数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minPathSum</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一维数组</span></span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        dp[<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//先更新第一行的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">            dp[j] = dp[j - <span class="number">1</span>] + grid[<span class="number">0</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//更新剩下行的值，每轮都更新一维数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//更新数组的第一个值</span></span><br><span class="line">            dp[<span class="number">0</span>] += grid[i][<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//循环更新数组右边的值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="comment">//dp[j] 的值等于左边的值 和未更新的值（即上一行的值） 取最小 ，再加当前值</span></span><br><span class="line">                dp[j] = Math.min(dp[j - <span class="number">1</span>], dp[j]) + grid[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">t</span> <span class="operator">=</span> <span class="number">1725958641711L</span>;</span><br><span class="line">        <span class="type">Long</span> <span class="variable">diff</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Date</span>().getTime() - t;</span><br><span class="line">        System.out.println(TimeUnit.MINUTES.toMillis(<span class="number">3</span>) &gt;= diff);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二维动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DistinctSubsequencesII</title>
      <link href="/2024/09/05/DistinctSubsequencesII/"/>
      <url>/2024/09/05/DistinctSubsequencesII/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.从递归入手到一维动态规划;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>  难题啊，很难</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/9/5 17:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 不同的子序列 II</span></span><br><span class="line"><span class="comment">// 给定一个字符串 s，计算 s 的 不同非空子序列 的个数</span></span><br><span class="line"><span class="comment">// 因为结果可能很大，所以返回答案需要对 10^9 + 7 取余</span></span><br><span class="line"><span class="comment">// 字符串的 子序列 是经由原字符串删除一些（也可能不删除）</span></span><br><span class="line"><span class="comment">// 字符但不改变剩余字符相对位置的一个新字符串</span></span><br><span class="line"><span class="comment">// 例如，&quot;ace&quot; 是 &quot;abcde&quot; 的一个子序列，但 &quot;aec&quot; 不是</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/distinct-subsequences-ii/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistinctSubsequencesII</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//很难，没思路，直接看的答案</span></span><br><span class="line">    <span class="comment">//答案思路遵循：</span></span><br><span class="line">    <span class="comment">//1、纯新增：all - 当前字符上次记录</span></span><br><span class="line">    <span class="comment">//2、当前字符记录 += 纯新</span></span><br><span class="line">    <span class="comment">//3、all += 纯新</span></span><br><span class="line">    <span class="comment">// 时间复杂度O(n)，n是字符串s的长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">distinctSubseqII</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">        <span class="type">char</span>[] str = s.toCharArray();</span><br><span class="line">        <span class="comment">//记录以当前字符结尾的子序列个数</span></span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="comment">//1为空集吧</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">all</span> <span class="operator">=</span> <span class="number">1</span>, newAdd;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> x : str) &#123;</span><br><span class="line">            <span class="comment">//纯新增</span></span><br><span class="line">            newAdd = (all - cnt[x - <span class="string">&#x27;a&#x27;</span>] + mod) % mod;</span><br><span class="line">            <span class="comment">//更新以当前字符结尾的子序列个数</span></span><br><span class="line">            cnt[x - <span class="string">&#x27;a&#x27;</span>] = (cnt[x - <span class="string">&#x27;a&#x27;</span>] + newAdd) % mod;</span><br><span class="line">            <span class="comment">//总数</span></span><br><span class="line">            all = (all + newAdd) % mod;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//减去一开始的空集 1</span></span><br><span class="line">        <span class="keyword">return</span> (all - <span class="number">1</span> + mod) % mod;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 从递归入手到一维动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 从递归入手到一维动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UniqueSubstringsWraparoundString</title>
      <link href="/2024/09/03/UniqueSubstringsWraparoundString/"/>
      <url>/2024/09/03/UniqueSubstringsWraparoundString/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.从递归入手到一维动态规划;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/9/3 17:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 环绕字符串中唯一的子字符串</span></span><br><span class="line"><span class="comment">// 定义字符串 base 为一个 &quot;abcdefghijklmnopqrstuvwxyz&quot; 无限环绕的字符串</span></span><br><span class="line"><span class="comment">// 所以 base 看起来是这样的：</span></span><br><span class="line"><span class="comment">// &quot;..zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd..&quot;</span></span><br><span class="line"><span class="comment">// 给你一个字符串 s ，请你统计并返回 s 中有多少 不同非空子串 也在 base 中出现</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/unique-substrings-in-wraparound-string/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UniqueSubstringsWraparoundString</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp定义：以字符c结尾，能往前顺序延伸的最大长度</span></span><br><span class="line">    <span class="comment">//得到每个字符c结尾的长度后，把所有能产生的结果数加起来</span></span><br><span class="line">    <span class="comment">//eg: 得到以b结尾的长度为3， 则0.。2， 1.。2， 2，2为3种，</span></span><br><span class="line">    <span class="comment">//即结果为 len数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findSubstringInWraproundString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//转换为数字好处理</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> s.length();</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[i] = s.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        dp[arr[<span class="number">0</span>]] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//统计每个数字结尾能往前延伸的最大长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, pre, cur, len = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            pre = arr[i - <span class="number">1</span>];</span><br><span class="line">            cur = arr[i];</span><br><span class="line">            <span class="comment">//如果是顺序延伸</span></span><br><span class="line">            <span class="comment">//这里为什么用len记录长度 而 不用dp[i - 1]呢？</span></span><br><span class="line">            <span class="comment">// 是因为dp[i- 1]是记录的最大长度，不代表pre到cur顺延的实际长度，所以用len记录实际长度</span></span><br><span class="line">            <span class="keyword">if</span> ((pre == <span class="number">25</span> &amp;&amp; cur == <span class="number">0</span>) || pre + <span class="number">1</span> == cur)&#123;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                len = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            dp[cur] = Math.max(len, dp[cur]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//eg: 得到以b结尾的长度为3， 则0.。2， 1.。2， 2，2为3种，</span></span><br><span class="line">        <span class="comment">//即结果为 len数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            ans += dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 从递归入手到一维动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 从递归入手到一维动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LongestValidParentheses</title>
      <link href="/2024/09/03/LongestValidParentheses/"/>
      <url>/2024/09/03/LongestValidParentheses/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.从递归入手到一维动态规划;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/9/3 15:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最长有效括号</span></span><br><span class="line"><span class="comment">// 给你一个只包含 &#x27;(&#x27; 和 &#x27;)&#x27; 的字符串</span></span><br><span class="line"><span class="comment">// 找出最长有效（格式正确且连续）括号子串的长度。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/longest-valid-parentheses/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongestValidParentheses</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基本dp思路：考虑以位置i结尾，往前延申最长的长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestValidParentheses</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] array = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> array.length;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//i为当前位置，t为对应括号所在位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, t = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i] == <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//为对应括号所在位置</span></span><br><span class="line">                t = i - dp[i - <span class="number">1</span>] - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (t &gt;= <span class="number">0</span> &amp;&amp; array[t] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    <span class="comment">//当前位置至少长度 = 上一个位置最长长度 + 目前位置对应的两个合适的括号</span></span><br><span class="line">                    dp[i] = dp[i - <span class="number">1</span>] + <span class="number">2</span>;</span><br><span class="line">                    <span class="comment">//如果对应括号还有前一个位置，则再加上该位置能往前延伸的长度</span></span><br><span class="line">                    <span class="keyword">if</span> (t - <span class="number">1</span> &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                        dp[i] += dp[t - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                    ans = Math.max(ans, dp[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 从递归入手到一维动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 从递归入手到一维动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UglyNumberII</title>
      <link href="/2024/09/03/UglyNumberII/"/>
      <url>/2024/09/03/UglyNumberII/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.从递归入手到一维动态规划;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/9/3 15:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 丑数 II</span></span><br><span class="line"><span class="comment">// 给你一个整数 n ，请你找出并返回第 n 个 丑数</span></span><br><span class="line"><span class="comment">// 丑数 就是只包含质因数 2、3 或 5 的正整数</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/ugly-number-ii/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UglyNumberII</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自己写的错误解法!!!!!!!!</span></span><br><span class="line">    <span class="comment">//用最小值乘以 2、3、5就是下一个丑数，</span></span><br><span class="line">    <span class="comment">// 优先队列获取最小值</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthUglyNumber1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        queue.clear();</span><br><span class="line">        <span class="keyword">return</span> f1(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前丑数、索引，限制</span></span><br><span class="line">    <span class="comment">//有坑啊，队列里会有重复数值，这里是错误的解法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> i, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="comment">//第i个丑数，直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i1</span> <span class="operator">=</span> m * <span class="number">2</span>, i2 = m * <span class="number">3</span>, i3 = m * <span class="number">5</span>;</span><br><span class="line">        queue.add(i1);</span><br><span class="line">        queue.add(i2);</span><br><span class="line">        queue.add(i3);</span><br><span class="line">        <span class="keyword">return</span> f1(queue.poll(), i + <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接dp</span></span><br><span class="line">    <span class="comment">//用三个指针 来表示乘值所在索引</span></span><br><span class="line">    <span class="comment">//对比三个乘值，取结果最小放入数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//i为当前索引的丑数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>, i2 = <span class="number">1</span>, i3 = <span class="number">1</span>, i5 = <span class="number">1</span>, a,b,c; i &lt;= n; i++) &#123;</span><br><span class="line">            a = dp[i2] * <span class="number">2</span>;</span><br><span class="line">            b = dp[i3] * <span class="number">3</span>;</span><br><span class="line">            c = dp[i5] * <span class="number">5</span>;</span><br><span class="line">            dp[i] = Math.min(Math.min(a,b), c);</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == a)&#123;</span><br><span class="line">                i2++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == b)&#123;</span><br><span class="line">                i3++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dp[i] == c)&#123;</span><br><span class="line">                i5++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 从递归入手到一维动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 从递归入手到一维动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NumDecodings</title>
      <link href="/2024/08/25/NumDecodings/"/>
      <url>/2024/08/25/NumDecodings/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.从递归入手到一维动态规划;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/8/25 22:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 解码方法</span></span><br><span class="line"><span class="comment">// 一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：</span></span><br><span class="line"><span class="comment">// &#x27;A&#x27; -&gt; &quot;1&quot;</span></span><br><span class="line"><span class="comment">// &#x27;B&#x27; -&gt; &quot;2&quot;</span></span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="comment">// &#x27;Z&#x27; -&gt; &quot;26&quot;</span></span><br><span class="line"><span class="comment">// 要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）</span></span><br><span class="line"><span class="comment">// 例如，&quot;11106&quot; 可以映射为：&quot;AAJF&quot;、&quot;KJF&quot;</span></span><br><span class="line"><span class="comment">// 注意，消息不能分组为(1 11 06)，因为 &quot;06&quot; 不能映射为 &quot;F&quot;</span></span><br><span class="line"><span class="comment">// 这是由于 &quot;6&quot; 和 &quot;06&quot; 在映射中并不等价</span></span><br><span class="line"><span class="comment">// 给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数</span></span><br><span class="line"><span class="comment">// 题目数据保证答案肯定是一个 32位 的整数</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/decode-ways/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumDecodings</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodings1</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> f1(<span class="number">0</span>, s.toCharArray());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暴力递归</span></span><br><span class="line">    <span class="comment">//当前字符取1位和取2位进行后续递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> i, <span class="type">char</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == arr.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取1位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> f1(i + <span class="number">1</span>, arr);</span><br><span class="line">        <span class="comment">//取2位</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; arr.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                ans += f1(i + <span class="number">2</span>, arr);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[i]== <span class="string">&#x27;2&#x27;</span> &amp;&amp; arr[i + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span> &lt;= <span class="number">6</span>)&#123;</span><br><span class="line">                ans += f1(i + <span class="number">2</span>, arr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="comment">//记忆化搜索</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodings2</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Arrays.fill(dp, <span class="number">0</span>, s.length() + <span class="number">1</span>, Integer.MAX_VALUE);</span><br><span class="line">        <span class="keyword">return</span> f2(<span class="number">0</span>, s.toCharArray());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暴力递归</span></span><br><span class="line">    <span class="comment">//当前字符取1位和取2位进行后续递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> i, <span class="type">char</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == arr.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] != Integer.MAX_VALUE)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取1位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> f2(i + <span class="number">1</span>, arr);</span><br><span class="line">        <span class="comment">//取2位</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; arr.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                ans += f2(i + <span class="number">2</span>, arr);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[i]== <span class="string">&#x27;2&#x27;</span> &amp;&amp; arr[i + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span> &lt;= <span class="number">6</span>)&#123;</span><br><span class="line">                ans += f2(i + <span class="number">2</span>, arr);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态规划</span></span><br><span class="line">    <span class="comment">//从递归看，很容易得知要从后往前推</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numDecodings</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">        Arrays.fill(dp, <span class="number">0</span>, arr.length + <span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        dp[arr.length] = <span class="number">1</span>;<span class="comment">//对应递归的base case</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//对应base case</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                dp[i] = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//取1位</span></span><br><span class="line">                dp[i] = dp[i + <span class="number">1</span>];</span><br><span class="line">                <span class="comment">//取2位</span></span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; arr.length)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (arr[i] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                        dp[i] += dp[i + <span class="number">2</span>];</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[i]== <span class="string">&#x27;2&#x27;</span> &amp;&amp; arr[i + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span> &lt;= <span class="number">6</span>)&#123;</span><br><span class="line">                        dp[i] += dp[i + <span class="number">2</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 从递归入手到一维动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 从递归入手到一维动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinimumCostForTickets</title>
      <link href="/2024/08/23/MinimumCostForTickets/"/>
      <url>/2024/08/23/MinimumCostForTickets/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.从递归入手到一维动态规划;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/8/23 17:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最低票价</span></span><br><span class="line"><span class="comment">// 在一个火车旅行很受欢迎的国度，你提前一年计划了一些火车旅行</span></span><br><span class="line"><span class="comment">// 在接下来的一年里，你要旅行的日子将以一个名为 days 的数组给出</span></span><br><span class="line"><span class="comment">// 每一项是一个从 1 到 365 的整数</span></span><br><span class="line"><span class="comment">// 火车票有 三种不同的销售方式</span></span><br><span class="line"><span class="comment">// 一张 为期1天 的通行证售价为 costs[0] 美元</span></span><br><span class="line"><span class="comment">// 一张 为期7天 的通行证售价为 costs[1] 美元</span></span><br><span class="line"><span class="comment">// 一张 为期30天 的通行证售价为 costs[2] 美元</span></span><br><span class="line"><span class="comment">// 通行证允许数天无限制的旅行</span></span><br><span class="line"><span class="comment">// 例如，如果我们在第 2 天获得一张 为期 7 天 的通行证</span></span><br><span class="line"><span class="comment">// 那么我们可以连着旅行 7 天(第2~8天)</span></span><br><span class="line"><span class="comment">// 返回 你想要完成在给定的列表 days 中列出的每一天的旅行所需要的最低消费</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/minimum-cost-for-tickets/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinimumCostForTickets</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态规划 是将待求解的问题分解成若干个子问题，先求解子问题，然后从这些子问题的解中 得到原有问题的解</span></span><br><span class="line">    <span class="comment">//所以根据基本思想去解题就会有思路</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//例如这题，从第1个计划开始到整个计划的最少花费</span></span><br><span class="line">    <span class="comment">//通常会用定尾部来分析问题</span></span><br><span class="line">    <span class="comment">//可以拆解为开始到目前的第i计划，目前的最少花费</span></span><br><span class="line">    <span class="comment">//[i....]目前的最少花费</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 无论提交什么方法都带着这个数组      0  1  2</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] durations = &#123; <span class="number">1</span>, <span class="number">7</span>, <span class="number">30</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">366</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//一坨屎，做不出</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mincostTickets1</span><span class="params">(<span class="type">int</span>[] days, <span class="type">int</span>[] costs)</span> &#123;</span><br><span class="line"><span class="comment">//        return f(1, 0, days, costs);</span></span><br><span class="line">        <span class="keyword">return</span> f1(<span class="number">0</span>, days, costs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//来到计划中的某天，每种票价都选择一遍，继续递归</span></span><br><span class="line">    <span class="comment">//返回最低spend</span></span><br><span class="line">    <span class="comment">//明明按照这个思路，却coding不出来</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">f0</span><span class="params">(<span class="type">int</span> d, <span class="type">int</span> spend, <span class="type">int</span>[] days, <span class="type">int</span>[] costs)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> days.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> costs.length;</span><br><span class="line">        <span class="keyword">if</span> (d &gt; <span class="number">365</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> spend;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">one</span> <span class="operator">=</span> spend, two = spend, three = spend, four = spend;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (d == days[i]) &#123;</span><br><span class="line">                one = f0(d + <span class="number">1</span>, spend + costs[<span class="number">0</span>], days, costs);</span><br><span class="line">                two = f0(d + <span class="number">7</span>, spend + costs[<span class="number">1</span>], days, costs);</span><br><span class="line">                three = f0(d + <span class="number">30</span>, spend + costs[<span class="number">2</span>], days, costs);</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!flag)&#123;</span><br><span class="line">            four = f0(d + <span class="number">1</span>, spend, days, costs);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.min(Math.min(one, two), Math.min(three, four));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//看了左神思路后的代码</span></span><br><span class="line">    <span class="comment">//从i索引开始处理，当前i也要处理</span></span><br><span class="line">    <span class="comment">//这个思路是，将每个计划天数的花费都记起来</span></span><br><span class="line">    <span class="comment">//暴力递归</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span>[] days, <span class="type">int</span>[] costs)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> days.length;</span><br><span class="line">        <span class="keyword">if</span> (i == n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//每种方案都试一遍</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>, j = i; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">            <span class="comment">//当前天数 加上当前购买票对应的天数 看能略过几天天数</span></span><br><span class="line">            <span class="comment">//相等不能跳过，因为相等时 该天数还是要付费的</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; days[i] + durations[k] &gt; days[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前花费 和 之前的对比</span></span><br><span class="line">            ans =  Math.min(costs[k] + f1(j, days, costs), ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记忆化搜素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mincostTickets2</span><span class="params">(<span class="type">int</span>[] days, <span class="type">int</span>[] costs)</span> &#123;</span><br><span class="line">        Arrays.fill(dp, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> f2(<span class="number">0</span>, days, costs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记忆化搜索</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span>[] days, <span class="type">int</span>[] costs)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> days.length;</span><br><span class="line">        <span class="keyword">if</span> (i == n)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//每种方案都试一遍</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>, j = i; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">            <span class="comment">//当前天数 加上当前购买票对应的天数 看能略过几天天数</span></span><br><span class="line">            <span class="comment">//相等不能跳过，因为相等时 该天数还是要付费的</span></span><br><span class="line">            <span class="keyword">while</span> (j &lt; n &amp;&amp; days[i] + durations[k] &gt; days[j])&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前花费 和 之前的对比</span></span><br><span class="line">            ans =  Math.min(costs[k] + f2(j, days, costs), ans);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//dp</span></span><br><span class="line">    <span class="comment">//从递归改写到dp</span></span><br><span class="line">    <span class="comment">//从递归可知，前面的解依赖后面的解，所以这里从简单到复杂去推的顺序是 从右往左，从底到顶</span></span><br><span class="line">    <span class="comment">//即从dp[n]  -&gt; dp[0]</span></span><br><span class="line">    <span class="comment">//暴力递归是从顶到底推，是从0 -&gt; n</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">mincostTickets</span><span class="params">(<span class="type">int</span>[] days, <span class="type">int</span>[] costs)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> f3(days, costs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">f3</span><span class="params">(<span class="type">int</span>[] days, <span class="type">int</span>[] costs)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> days.length;</span><br><span class="line">        Arrays.fill(dp, <span class="number">0</span>, n + <span class="number">1</span>, Integer.MAX_VALUE);</span><br><span class="line">        dp[n] = <span class="number">0</span>;<span class="comment">//对应递归的base case</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;<span class="comment">//从底到顶递推</span></span><br><span class="line">            <span class="comment">//再把递归的逻辑copy过来</span></span><br><span class="line">            <span class="comment">//每种方案都试一遍</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>, j = i; k &lt; <span class="number">3</span>; k++) &#123;</span><br><span class="line">                <span class="comment">//这里是看当前计划 加上当前票数对应的免费天数，能否超过下一个计划</span></span><br><span class="line">                <span class="keyword">while</span> (j &lt; n &amp;&amp; days[i] + durations[k] &gt; days[j])&#123;</span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当前花费 和 之前的对比</span></span><br><span class="line">                dp[i] =  Math.min(dp[i], costs[k] + dp[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回顶部结果</span></span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 从递归入手到一维动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 从递归入手到一维动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FibonacciNumber</title>
      <link href="/2024/08/23/FibonacciNumber/"/>
      <url>/2024/08/23/FibonacciNumber/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.动态规划.从递归入手到一维动态规划;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/8/23 17:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 斐波那契数</span></span><br><span class="line"><span class="comment">// 斐波那契数 （通常用 F(n) 表示）形成的序列称为 斐波那契数列</span></span><br><span class="line"><span class="comment">// 该数列由 0 和 1 开始，后面的每一项数字都是前面两项数字的和。</span></span><br><span class="line"><span class="comment">// 也就是：F(0) = 0，F(1) = 1</span></span><br><span class="line"><span class="comment">// F(n) = F(n - 1) + F(n - 2)，其中 n &gt; 1</span></span><br><span class="line"><span class="comment">// 给定 n ，请计算 F(n)</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/fibonacci-number/</span></span><br><span class="line"><span class="comment">// 注意：最优解来自矩阵快速幂，时间复杂度可以做到O(log n)</span></span><br><span class="line"><span class="comment">// 后续课程一定会讲述！本节课不涉及！</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FibonacciNumber</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span>  <span class="number">31</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        Arrays.fill(dp, <span class="number">0</span>, n + <span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> f(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//简单递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f0</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> f(n - <span class="number">2</span>) + f(n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//带记忆搜索的递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[n] != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> dp[n];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            ans = n;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            ans = f(n - <span class="number">2</span>) + f(n - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dp[n] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//动态规划</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空间压缩 的dp</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">nextnext</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            nextnext = cur + next;</span><br><span class="line">            cur = next;</span><br><span class="line">            next = nextnext;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nextnext;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 从递归入手到一维动态规划 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 从递归入手到一维动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SPFA</title>
      <link href="/2024/08/15/SPFA/"/>
      <url>/2024/08/15/SPFA/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.源点到目标点最短距离拓展;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 由BellmanFord很容易想到要优化，只处理松驰过的点，所以SPFA算法出现了</span></span><br><span class="line"><span class="comment"> *核心点就是 将处理过的入队，并打上标记，出队消除标记。只处理队列中的点. 记录每个点的松弛次数，次数超过点数则有负环</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/8/15 16:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Bellman-Ford + SPFA优化模版（洛谷）</span></span><br><span class="line"><span class="comment">// 给定n个点的有向图，请求出图中是否存在从顶点1出发能到达的负环</span></span><br><span class="line"><span class="comment">// 负环的定义是：一条边权之和为负数的回路</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P3385</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下所有代码，把主类名改成Main，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SPFA</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//点数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">2001</span>;</span><br><span class="line">    <span class="comment">//边数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIM</span> <span class="operator">=</span> <span class="number">6001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// SPFA需要</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXQ</span> <span class="operator">=</span> <span class="number">4000001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] head = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] to = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] weight = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//松驰点入队</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] queue = <span class="keyword">new</span> <span class="title class_">int</span>[MAXQ];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] distance = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录哪些点已入队  防止重复入队。即允许多次松弛同一个点，但只入队一次</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span>[] enter = <span class="keyword">new</span> <span class="title class_">boolean</span>[MAIN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录每个点的松弛次数，如果某个点的松弛次数超过点的个数，则有负环</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] updateCnt = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> cnt, n, m, l, r;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(bf);</span><br><span class="line">        <span class="keyword">while</span> (st.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> (<span class="type">int</span>) st.nval;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                n = (<span class="type">int</span>) st.nval;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                m = (<span class="type">int</span>) st.nval;</span><br><span class="line">                build();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, u, v, w; j &lt; m; j++) &#123;</span><br><span class="line">                    st.nextToken();u = (<span class="type">int</span>) st.nval;</span><br><span class="line">                    st.nextToken();v = (<span class="type">int</span>) st.nval;</span><br><span class="line">                    st.nextToken();w = (<span class="type">int</span>) st.nval;</span><br><span class="line">                    addEdge(u, v, w);</span><br><span class="line">                    <span class="keyword">if</span> (w &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                        addEdge(v, u, w);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                out.println(spfa() ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        bf.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Bellman-Ford + SPFA优化的模版</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">spfa</span><span class="params">()</span>&#123;</span><br><span class="line">        queue[r++] = <span class="number">1</span>;</span><br><span class="line">        enter[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        distance[<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        updateCnt[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> queue[l++];</span><br><span class="line">            enter[u] = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">ei</span> <span class="operator">=</span> head[u], v; ei &gt; <span class="number">0</span>; ei = next[ei]) &#123;</span><br><span class="line">                v = to[ei];</span><br><span class="line">                <span class="comment">//当前点出发去下一个点更近.这里即允许多次松弛同一个点，后面只允许入队1次</span></span><br><span class="line">                <span class="keyword">if</span> (distance[u] + weight[ei] &lt; distance[v])&#123;</span><br><span class="line">                    distance[v] = distance[u] + weight[ei];</span><br><span class="line">                    <span class="comment">//如果这个点没松驰过 且</span></span><br><span class="line">                    <span class="keyword">if</span> (!enter[v])&#123;</span><br><span class="line">                        <span class="keyword">if</span> (updateCnt[v]++ == n)&#123;</span><br><span class="line">                            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        queue[r++] = v;</span><br><span class="line">                        enter[v] = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        l = r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            head[i] = <span class="number">0</span>;</span><br><span class="line">            distance[i] = Integer.MAX_VALUE;</span><br><span class="line">            enter[i] = <span class="literal">false</span>;</span><br><span class="line">            updateCnt[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="comment">//        Arrays.fill(head, 0, n + 1, 0);</span></span><br><span class="line"><span class="comment">//        Arrays.fill(distance, 0, n + 1, Integer.MAX_VALUE);</span></span><br><span class="line"><span class="comment">//        Arrays.fill(enter, 0, n + 1, false);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span>&#123;</span><br><span class="line">        next[cnt] = head[u];</span><br><span class="line">        to[cnt] = v;</span><br><span class="line">        weight[cnt] = w;</span><br><span class="line">        head[u] = cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 源点到目标点最短距离拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源点到目标点最短距离拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BellmanFord</title>
      <link href="/2024/08/14/BellmanFord/"/>
      <url>/2024/08/14/BellmanFord/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.源点到目标点最短距离拓展;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> Bellman-Ford算法，单源最短路算法，可以有负边，但不能有负环</span></span><br><span class="line"><span class="comment"> *  假设有n点，正常最多松弛n - 1轮即结束，如果有负环则大于 n - 1轮，所以可以用来判断从某点出发是否有负环。</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/8/14 18:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Bellman-Ford算法应用（不是模版）</span></span><br><span class="line"><span class="comment">// k站中转内最便宜的航班</span></span><br><span class="line"><span class="comment">// 有 n 个城市通过一些航班连接。给你一个数组 flights</span></span><br><span class="line"><span class="comment">// 其中 flights[i] = [fromi, toi, pricei]</span></span><br><span class="line"><span class="comment">// 表示该航班都从城市 fromi 开始，以价格 pricei 抵达 toi。</span></span><br><span class="line"><span class="comment">// 现在给定所有的城市和航班，以及出发城市 src 和目的地 dst，你的任务是找到出一条最多经过 k 站中转的路线</span></span><br><span class="line"><span class="comment">// 使得从 src 到 dst 的 价格最便宜 ，并返回该价格。 如果不存在这样的路线，则输出 -1。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/cheapest-flights-within-k-stops/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BellmanFord</span> &#123;</span><br><span class="line">    <span class="comment">//有点和Floyd一样利用跳板的意思。 利用处理过的每条边，继续看是否能有更短路径。 循环处理</span></span><br><span class="line">    <span class="comment">//时间复杂度为O(N*M) 点 * 边数量</span></span><br><span class="line">    <span class="comment">//此题为阉割版</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findCheapestPrice</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] flights, <span class="type">int</span> src, <span class="type">int</span> dst, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//源点到该点最短距离，多次循环更新</span></span><br><span class="line">        <span class="type">int</span>[] cur = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        Arrays.fill(cur, Integer.MAX_VALUE);</span><br><span class="line">        cur[src] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//处理k次</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= k; i++) &#123;</span><br><span class="line">            <span class="comment">//这里是因为每轮处理的点的个数，可能是多个，不符合k次的要求</span></span><br><span class="line">            <span class="comment">//所以这里只用来处理单论的结果</span></span><br><span class="line">            <span class="type">int</span>[] next = Arrays.copyOf(cur, n);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] edge : flights) &#123;</span><br><span class="line">                <span class="comment">//已处理过的出发点，才处理该边</span></span><br><span class="line">                <span class="keyword">if</span> (cur[edge[<span class="number">0</span>]] != Integer.MAX_VALUE)&#123;</span><br><span class="line">                    <span class="comment">//这里是用原数组，为了符合k次转机</span></span><br><span class="line">                    next[edge[<span class="number">1</span>]] = Math.min(next[edge[<span class="number">1</span>]], cur[edge[<span class="number">0</span>]] + edge[<span class="number">2</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur[dst] == Integer.MAX_VALUE ? -<span class="number">1</span> : cur[dst];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 源点到目标点最短距离拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源点到目标点最短距离拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Floyd</title>
      <link href="/2024/08/14/Floyd/"/>
      <url>/2024/08/14/Floyd/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.源点到目标点最短距离拓展;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> Floyd算法，得到图中任意两点间的最短距离。</span></span><br><span class="line"><span class="comment"> * 适用于任何图，不管有向、无向，不管边权正负，但不能有负环（保证最短路存在）</span></span><br><span class="line"><span class="comment"> * 挺直接、巧妙的</span></span><br><span class="line"><span class="comment"> * 已知所有路径权值，用于求每个点到其他点的最短路径</span></span><br><span class="line"><span class="comment"> * 主要就是更新每个点到其他点的最短路，做法就是让每个点充当跳板，以跳板去走，看看这条路能不能更短</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/8/14 17:21</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Floyd算法模版（洛谷）</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P2910</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下所有代码，把主类名改成Main，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Floyd</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXM</span> <span class="operator">=</span> <span class="number">10001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//规定要经过的点，即源点和目标点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] path = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从i点出发到j点的最短距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] distance = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN][MAXN];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, m, ans;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始时设置任意两点之间的最短距离为无穷大，表示任何路不存在</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                distance[i][j] = Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            n = (<span class="type">int</span>) in.nval;</span><br><span class="line">            in.nextToken();</span><br><span class="line">            m = (<span class="type">int</span>) in.nval;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                in.nextToken();</span><br><span class="line">                path[i] = (<span class="type">int</span>) in.nval - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这道题给的图是邻接矩阵的形式</span></span><br><span class="line">            <span class="comment">// 任意两点之间的边权都会给定</span></span><br><span class="line">            <span class="comment">// 所以显得distance初始化不太必要</span></span><br><span class="line">            <span class="comment">// 但是一般情况下，distance初始化一定要做</span></span><br><span class="line">            build();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    in.nextToken();</span><br><span class="line">                    distance[i][j] = (<span class="type">int</span>) in.nval;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            floyd();</span><br><span class="line">            ans = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//获取此条路径的值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">                ans += distance[path[i - <span class="number">1</span>]][path[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(ans);</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//更新每个点到其他点的最短距离。 利用跳板实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">floyd</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">bridge</span> <span class="operator">=</span> <span class="number">0</span>; bridge &lt; n; bridge++) &#123;<span class="comment">//跳板，源点从此点去目标点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;<span class="comment">//源点</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;<span class="comment">//目标点</span></span><br><span class="line">                    <span class="comment">//跳板有路径，且从跳板去目标点更近</span></span><br><span class="line">                    <span class="keyword">if</span> (distance[i][bridge] &lt; Integer.MAX_VALUE &amp;&amp; distance[bridge][j] &lt; Integer.MAX_VALUE</span><br><span class="line">                            &amp;&amp; distance[i][bridge] + distance[bridge][j] &lt; distance[i][j])&#123;</span><br><span class="line">                        distance[i][j] = distance[i][bridge] + distance[bridge][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 源点到目标点最短距离拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源点到目标点最短距离拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AStarAlgorithm</title>
      <link href="/2024/08/14/AStarAlgorithm/"/>
      <url>/2024/08/14/AStarAlgorithm/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.源点到目标点最短距离拓展;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> A星算法模板</span></span><br><span class="line"><span class="comment"> * 和DJ算法的唯一区别就是堆中距离，堆中距离为 到源点距离 + 距离目标点预估距离。 A*算法主要是这个预估距离要怎么做</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/8/14 15:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AStarAlgorithm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0:上，1:右，2:下，3:左</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] move = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dijkstra算法</span></span><br><span class="line">    <span class="comment">// grid[i][j] == 0 代表障碍</span></span><br><span class="line">    <span class="comment">// grid[i][j] == 1 代表道路</span></span><br><span class="line">    <span class="comment">// 只能走上、下、左、右，不包括斜线方向</span></span><br><span class="line">    <span class="comment">// 返回从(startX, startY)到(targetX, targetY)的最短距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minDistance1</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> startX, <span class="type">int</span> startY, <span class="type">int</span> targetX, <span class="type">int</span> targetY)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[startX][startY] == <span class="number">0</span> || grid[targetX][targetY] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] distance = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][m];</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b) -&gt; (a[<span class="number">2</span>] - b[<span class="number">2</span>]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Arrays.fill(distance[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        distance[startX][startY] = <span class="number">0</span>;</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;startX, startY, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] cur = queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cur[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> cur[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> cur[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (x == targetX &amp;&amp; y == targetY)&#123;</span><br><span class="line">                <span class="keyword">return</span> d;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (visited[x][y])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, nx,ny,nd; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                nx = x + move[i];</span><br><span class="line">                ny = y + move[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m &amp;&amp; !visited[nx][ny])&#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[nx][ny] == <span class="number">1</span> &amp;&amp; distance[x][y] + <span class="number">1</span> &lt; distance[nx][ny])&#123;</span><br><span class="line">                        distance[nx][ny] = distance[x][y] + <span class="number">1</span>;</span><br><span class="line">                        queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nx, ny, distance[nx][ny]&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// A*算法</span></span><br><span class="line">    <span class="comment">//和DJ算法的唯一区别就是堆中距离，堆中距离为 到源点距离 + 距离目标点预估距离。 A*算法主要是这个预估距离要怎么做</span></span><br><span class="line">    <span class="comment">// grid[i][j] == 0 代表障碍</span></span><br><span class="line">    <span class="comment">// grid[i][j] == 1 代表道路</span></span><br><span class="line">    <span class="comment">// 只能走上、下、左、右，不包括斜线方向</span></span><br><span class="line">    <span class="comment">// 返回从(startX, startY)到(targetX, targetY)的最短距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minDistance2</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> startX, <span class="type">int</span> startY, <span class="type">int</span> targetX, <span class="type">int</span> targetY)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid[startX][startY] == <span class="number">0</span> || grid[targetX][targetY] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] distance = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][m];</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b) -&gt; (a[<span class="number">2</span>] - b[<span class="number">2</span>]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Arrays.fill(distance[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        distance[startX][startY] = <span class="number">0</span>;</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;startX, startY, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] cur = queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cur[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> cur[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (x == targetX &amp;&amp; y == targetY)&#123;</span><br><span class="line">                <span class="keyword">return</span> distance[x][y];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (visited[x][y])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, nx,ny,nd; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                nx = x + move[i];</span><br><span class="line">                ny = y + move[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m &amp;&amp; !visited[nx][ny])&#123;</span><br><span class="line">                    <span class="keyword">if</span> (grid[nx][ny] == <span class="number">1</span> &amp;&amp; distance[x][y] + <span class="number">1</span> &lt; distance[nx][ny])&#123;</span><br><span class="line">                        distance[nx][ny] = distance[x][y] + <span class="number">1</span>;</span><br><span class="line">                        queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nx, ny, distance[nx][ny] + f1(nx, ny, targetX, targetY)&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//曼哈顿距离</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> tx, <span class="type">int</span> ty)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(tx - x) + Math.abs(ty - y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对角线距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f2</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> targetX, <span class="type">int</span> targetY)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.max(Math.abs(targetX - x), Math.abs(targetY - y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 欧式距离</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">f3</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span> targetX, <span class="type">int</span> targetY)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> Math.sqrt(Math.pow(targetX - x, <span class="number">2</span>) + Math.pow(targetY - y, <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] randomGrid(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">int</span>[][] grid = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (Math.random() &lt; <span class="number">0.3</span>) &#123;</span><br><span class="line">                    <span class="comment">// 每个格子有30%概率是0</span></span><br><span class="line">                    grid[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 每个格子有70%概率是1</span></span><br><span class="line">                    grid[i][j] = <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">testTime</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;功能测试开始&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * len) + <span class="number">2</span>;</span><br><span class="line">            <span class="type">int</span>[][] grid = randomGrid(n);</span><br><span class="line">            <span class="type">int</span> <span class="variable">startX</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * n);</span><br><span class="line">            <span class="type">int</span> <span class="variable">startY</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * n);</span><br><span class="line">            <span class="type">int</span> <span class="variable">targetX</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * n);</span><br><span class="line">            <span class="type">int</span> <span class="variable">targetY</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * n);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> minDistance1(grid, startX, startY, targetX, targetY);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> minDistance2(grid, startX, startY, targetX, targetY);</span><br><span class="line">            <span class="keyword">if</span> (ans1 != ans2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;出错了!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;功能测试结束&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;性能测试开始&quot;</span>);</span><br><span class="line">        <span class="type">int</span>[][] grid = randomGrid(<span class="number">4000</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">startX</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">startY</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">targetX</span> <span class="operator">=</span> <span class="number">3900</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">targetY</span> <span class="operator">=</span> <span class="number">3900</span>;</span><br><span class="line">        <span class="type">long</span> start, end;</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> minDistance1(grid, startX, startY, targetX, targetY);</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;运行dijskra算法结果: &quot;</span> + ans1 + <span class="string">&quot;, 运行时间(毫秒) : &quot;</span> + (end - start));</span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> minDistance2(grid, startX, startY, targetX, targetY);</span><br><span class="line">        end = System.currentTimeMillis();</span><br><span class="line">        System.out.println(<span class="string">&quot;运行A*算法结果: &quot;</span> + ans2 + <span class="string">&quot;, 运行时间(毫秒) : &quot;</span> + (end - start));</span><br><span class="line">        System.out.println(<span class="string">&quot;性能测试结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 源点到目标点最短距离拓展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 源点到目标点最短距离拓展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FlightPath</title>
      <link href="/2024/08/13/FlightPath/"/>
      <url>/2024/08/13/FlightPath/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.分层最短路;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/8/13 16:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 飞行路线（语言提供的堆）</span></span><br><span class="line"><span class="comment">// Alice和Bob现在要乘飞机旅行，他们选择了一家相对便宜的航空公司</span></span><br><span class="line"><span class="comment">// 该航空公司一共在n个城市设有业务，设这些城市分别标记为0 ~ n−1</span></span><br><span class="line"><span class="comment">// 一共有m种航线，每种航线连接两个城市，并且航线有一定的价格</span></span><br><span class="line"><span class="comment">// Alice 和 Bob 现在要从一个城市沿着航线到达另一个城市，途中可以进行转机</span></span><br><span class="line"><span class="comment">// 航空公司对他们这次旅行也推出优惠，他们可以免费在最多k种航线上搭乘飞机</span></span><br><span class="line"><span class="comment">// 那么 Alice 和 Bob 这次出行最少花费多少</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P4568</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下所有代码，把主类名改成Main，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FlightPath</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//点数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">10001</span>;</span><br><span class="line">    <span class="comment">//边数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIM</span> <span class="operator">=</span> <span class="number">100001</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] head = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] to = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line">    <span class="comment">//权值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] weight = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIK</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line">    <span class="comment">//当前点，已免费次数 -》 花销</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[][] costs = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM][MAIK];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[MAIM][MAIK];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> cnt, n, m, k, s, t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前点cur， 剩余免费次数free，已花费cost</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> PriorityQueue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b) -&gt; a[<span class="number">2</span>] - b[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(bf);</span><br><span class="line">        <span class="keyword">while</span> (st.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            n = (<span class="type">int</span>) st.nval;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            m = (<span class="type">int</span>) st.nval;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            k = (<span class="type">int</span>) st.nval;</span><br><span class="line"></span><br><span class="line">            st.nextToken();</span><br><span class="line">            s = (<span class="type">int</span>) st.nval;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            t = (<span class="type">int</span>) st.nval;</span><br><span class="line">            build();</span><br><span class="line">            <span class="comment">//链式前向星建图</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, u, v, w; i &lt; m; i++) &#123;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                u = (<span class="type">int</span>) st.nval;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                v = (<span class="type">int</span>) st.nval;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                w = (<span class="type">int</span>) st.nval;</span><br><span class="line">                addEdge(u, v, w);</span><br><span class="line">                addEdge(v, u, w);</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(DJ());</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        bf.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当次免费与不免费的走</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">DJ</span><span class="params">()</span>&#123;</span><br><span class="line">        costs[s][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;s, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] cur = queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">point</span> <span class="operator">=</span> cur[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">free</span> <span class="operator">=</span> cur[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">cost</span> <span class="operator">=</span> cur[<span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (point == t)&#123;</span><br><span class="line">                <span class="keyword">return</span> cost;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (visited[point][free])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[point][free] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">ei</span> <span class="operator">=</span> head[point], t, nextCost; ei &gt; <span class="number">0</span>; ei = next[ei]) &#123;</span><br><span class="line">                <span class="comment">//去往的点</span></span><br><span class="line">                t = to[ei];</span><br><span class="line">                <span class="comment">//当次免费 &amp;&amp; 去往下一个点花销较小</span></span><br><span class="line">                <span class="keyword">if</span> (free &lt; k &amp;&amp; !visited[t][free + <span class="number">1</span>] &amp;&amp; cost &lt; costs[t][free + <span class="number">1</span>])&#123;</span><br><span class="line">                    costs[t][free + <span class="number">1</span>] = cost;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;t, free + <span class="number">1</span>, cost&#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//当次不免费</span></span><br><span class="line">                nextCost = cost + weight[ei];</span><br><span class="line">                <span class="keyword">if</span> (!visited[t][free] &amp;&amp; nextCost &lt; costs[t][free])&#123;</span><br><span class="line">                    costs[t][free] = nextCost;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;t, free, nextCost&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        queue.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            head[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt;= k; j++) &#123;</span><br><span class="line">                visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">                costs[i][j] = Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span>&#123;</span><br><span class="line">        next[cnt] = head[u];</span><br><span class="line">        to[cnt] = v;</span><br><span class="line">        weight[cnt] = w;</span><br><span class="line">        head[u] = cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 分层最短路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分层最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElectricCarPlan</title>
      <link href="/2024/08/13/ElectricCarPlan/"/>
      <url>/2024/08/13/ElectricCarPlan/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.分层最短路;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>  这题重点在于分清楚拓展什么变量作为路径值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/8/13 16:07</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 电动车游城市</span></span><br><span class="line"><span class="comment">// 小明的电动车电量充满时可行驶距离为 cnt，每行驶 1 单位距离消耗 1 单位电量，且花费 1 单位时间</span></span><br><span class="line"><span class="comment">// 小明想选择电动车作为代步工具。地图上共有 N 个景点，景点编号为 0 ~ N-1</span></span><br><span class="line"><span class="comment">// 他将地图信息以 [城市 A 编号,城市 B 编号,两城市间距离] 格式整理在在二维数组 paths，</span></span><br><span class="line"><span class="comment">// 表示城市 A、B 间存在双向通路。</span></span><br><span class="line"><span class="comment">// 初始状态，电动车电量为 0。每个城市都设有充电桩，</span></span><br><span class="line"><span class="comment">// charge[i] 表示第 i 个城市每充 1 单位电量需要花费的单位时间。</span></span><br><span class="line"><span class="comment">// 请返回小明最少需要花费多少单位时间从起点城市 start 抵达终点城市 end</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/DFPeFJ/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ElectricCarPlan</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line">    <span class="comment">//当前点 当前电量  val = 花费的总时间</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[][] wasteTime = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN][MAIN];</span><br><span class="line">    <span class="comment">//当前点 当前电量</span></span><br><span class="line">    <span class="comment">//因为有wasteTime在，这里不用visited也可以，用了相当于剪枝</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[MAIN][MAIN];</span><br><span class="line">    <span class="comment">//当前点  -》 到达的点、权值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ArrayList&lt;ArrayList&lt;<span class="type">int</span>[]&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> n,m;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将到达当前城市还有几个电，作为状态编入路径中</span></span><br><span class="line">    <span class="comment">//当前点、当前电量、源点到当前点距离</span></span><br><span class="line">    <span class="comment">// a, z, d</span></span><br><span class="line">    <span class="comment">//由于可行使距离不一样，即权值不同，故使用DJ算法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">electricCarPlan</span><span class="params">(<span class="type">int</span>[][] paths, <span class="type">int</span> cnt, <span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span>[] charge)</span> &#123;</span><br><span class="line">        n = charge.length;</span><br><span class="line">        m = cnt;</span><br><span class="line">        build(paths);</span><br><span class="line">        <span class="comment">//以距离排序</span></span><br><span class="line">        <span class="comment">//当前点、当前电量、源点到当前点所花费时间</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="number">2</span>] - b[<span class="number">2</span>]);</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;start, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        wasteTime[start][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] cur = queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cur[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> cur[<span class="number">1</span>];<span class="comment">//电量</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> cur[<span class="number">2</span>];<span class="comment">//来到当前点所耗费时间</span></span><br><span class="line">            <span class="keyword">if</span> (x == end)&#123;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (visited[x][p])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[x][p] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//可以选择继续原地充电</span></span><br><span class="line">            <span class="comment">//继续原地充电</span></span><br><span class="line">            <span class="keyword">if</span> (p &lt; cnt)&#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[x][p + <span class="number">1</span>] &amp;&amp; t + charge[x] &lt; wasteTime[x][p + <span class="number">1</span>])&#123;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, p + <span class="number">1</span>, t + charge[x]&#125;);</span><br><span class="line">                    wasteTime[x][p + <span class="number">1</span>] = t + charge[x];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//或者不充电直接去别的城市</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] next : graph.get(x)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">nx</span> <span class="operator">=</span> next[<span class="number">0</span>];<span class="comment">//下一个点</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> next[<span class="number">1</span>];<span class="comment">//权值</span></span><br><span class="line">                <span class="comment">//直接走</span></span><br><span class="line">                <span class="keyword">if</span> (p &gt;= d &amp;&amp; !visited[nx][p - d] &amp;&amp; t + d &lt; wasteTime[nx][p - d]) &#123;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nx, p - d, t + d&#125;);</span><br><span class="line">                    wasteTime[nx][p - d] = t + d;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span>[][] paths)</span>&#123;</span><br><span class="line">        graph.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            Arrays.fill(wasteTime[i], <span class="number">0</span>, m + <span class="number">1</span>, Integer.MAX_VALUE);</span><br><span class="line">            Arrays.fill(visited[i], <span class="number">0</span>, m + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//建图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] path : paths) &#123;</span><br><span class="line">            graph.get(path[<span class="number">0</span>]).add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;path[<span class="number">1</span>], path[<span class="number">2</span>]&#125;);</span><br><span class="line">            graph.get(path[<span class="number">1</span>]).add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;path[<span class="number">0</span>], path[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 分层最短路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分层最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ShortestPathAllKeys</title>
      <link href="/2024/08/12/ShortestPathAllKeys/"/>
      <url>/2024/08/12/ShortestPathAllKeys/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.分层最短路;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 很巧妙，拓展状态也为一个路径，然后执行算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/8/12 15:55</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取所有钥匙的最短路径</span></span><br><span class="line"><span class="comment">// 给定一个二维网格 grid ，其中：</span></span><br><span class="line"><span class="comment">// &#x27;.&#x27; 代表一个空房间、&#x27;#&#x27; 代表一堵、&#x27;@&#x27; 是起点</span></span><br><span class="line"><span class="comment">// 小写字母代表钥匙、大写字母代表锁</span></span><br><span class="line"><span class="comment">// 从起点开始出发，一次移动是指向四个基本方向之一行走一个单位空间</span></span><br><span class="line"><span class="comment">// 不能在网格外面行走，也无法穿过一堵墙</span></span><br><span class="line"><span class="comment">// 如果途经一个钥匙，我们就把它捡起来。除非我们手里有对应的钥匙，否则无法通过锁。</span></span><br><span class="line"><span class="comment">// 假设 k 为 钥匙/锁 的个数，且满足 1 &lt;= k &lt;= 6，</span></span><br><span class="line"><span class="comment">// 字母表中的前 k 个字母在网格中都有自己对应的一个小写和一个大写字母</span></span><br><span class="line"><span class="comment">// 换言之，每个锁有唯一对应的钥匙，每个钥匙也有唯一对应的锁</span></span><br><span class="line"><span class="comment">// 另外，代表钥匙和锁的字母互为大小写并按字母顺序排列</span></span><br><span class="line"><span class="comment">// 返回获取所有钥匙所需要的移动的最少次数。如果无法获取所有钥匙，返回 -1 。</span></span><br><span class="line"><span class="comment">// 测试链接：https://leetcode.cn/problems/shortest-path-to-get-all-keys</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShortestPathAllKeys</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXM</span> <span class="operator">=</span> <span class="number">31</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXK</span> <span class="operator">=</span> <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0:上，1:右，2:下，3:左</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] move = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span> &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span>[][][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[MAXN][MAXM][<span class="number">1</span> &lt;&lt; MAXK];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> startX, startY, n, m,l,r, keys;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[][][] distance = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN][MAXM][<span class="number">1</span> &lt;&lt; MAXK];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span>[][] grid = <span class="keyword">new</span> <span class="title class_">char</span>[MAXN][];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//很神奇，拓展定义，</span></span><br><span class="line">    <span class="comment">//对于路径上的每个格子，加多一个获取钥匙数量的定义</span></span><br><span class="line">    <span class="comment">//其他和DJ算法基本一样了</span></span><br><span class="line">    <span class="comment">//看起来像是01bfs,实际上0不存在，不能走就不走了，所以就是普通的bfs算法即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestPathAllKeys</span><span class="params">(String[] grid)</span> &#123;</span><br><span class="line">        build(grid);</span><br><span class="line">        distance[startX][startY][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//x，y,z钥匙数量，d移动次数</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="number">3</span>] - b[<span class="number">3</span>]);</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;startX, startY, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] cur = queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cur[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> cur[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">z</span> <span class="operator">=</span> cur[<span class="number">2</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> cur[<span class="number">3</span>];</span><br><span class="line">            <span class="comment">//持有所有钥匙</span></span><br><span class="line">            <span class="keyword">if</span> (z == keys)&#123;</span><br><span class="line">                <span class="keyword">return</span> d;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (visited[x][y][z])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[x][y][z] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, nx,ny,nz,nd; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                nx = x + move[i];</span><br><span class="line">                ny = y + move[i + <span class="number">1</span>];</span><br><span class="line">                nz = z;</span><br><span class="line">                <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m)&#123;</span><br><span class="line">                    <span class="type">char</span> <span class="variable">ndex</span> <span class="operator">=</span> grid[nx].charAt(ny);</span><br><span class="line">                    <span class="comment">//遇到墙不能走</span></span><br><span class="line">                    <span class="keyword">if</span> (ndex == <span class="string">&#x27;#&#x27;</span>)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果遇到锁，但没拿到对应钥匙</span></span><br><span class="line">                    <span class="keyword">if</span> (isLock(ndex) &amp;&amp; (whichKey(toSmall(ndex)) &amp; nz) == <span class="number">0</span>)&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//遇到锁</span></span><br><span class="line">                    <span class="keyword">if</span> (isKey(ndex))&#123;</span><br><span class="line">                        nz |= whichKey(ndex);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (visited[nx][ny][nz])&#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//如果当前步 比已有步数少，更新步数</span></span><br><span class="line">                    <span class="keyword">if</span> (distance[x][y][z] + <span class="number">1</span> &lt; distance[nx][ny][nz])&#123;</span><br><span class="line">                        distance[nx][ny][nz] = distance[x][y][z] + <span class="number">1</span>;</span><br><span class="line">                        queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nx,ny,nz,distance[nx][ny][nz]&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(String[] grid)</span>&#123;</span><br><span class="line">        n = grid.length;</span><br><span class="line">        m = grid[<span class="number">0</span>].length();</span><br><span class="line">        <span class="comment">//对于x,y这个点，z持有钥匙数量，到达这一步需要走的路长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                Arrays.fill(distance[i][j], Integer.MAX_VALUE);</span><br><span class="line">                Arrays.fill(visited[i][j],<span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        startX = startY = keys = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//找到起始点,和钥匙总数量</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">char</span>[] array = grid[i].toCharArray();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; array.length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (array[j] == <span class="string">&#x27;@&#x27;</span>)&#123;</span><br><span class="line">                    startX = i;</span><br><span class="line">                    startY = j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (isKey(array[j]))&#123;</span><br><span class="line">                    keys |= whichKey(array[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下是左神思路，直接bfs算法解决</span></span><br><span class="line">    <span class="comment">// 0 : 行</span></span><br><span class="line">    <span class="comment">// 1 : 列</span></span><br><span class="line">    <span class="comment">// 2 : 收集钥匙的状态</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] queue = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN * MAXM * (<span class="number">1</span> &lt;&lt; MAXK)][<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build1</span><span class="params">(String[] g)</span> &#123;</span><br><span class="line">        l = r = keys = <span class="number">0</span>;</span><br><span class="line">        n = g.length;</span><br><span class="line">        m = g[<span class="number">0</span>].length();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            grid[i] = g[i].toCharArray();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;@&#x27;</span>) &#123;</span><br><span class="line">                    queue[r][<span class="number">0</span>] = i;</span><br><span class="line">                    queue[r][<span class="number">1</span>] = j;</span><br><span class="line">                    <span class="comment">// 0 : 000000</span></span><br><span class="line">                    queue[r++][<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; grid[i][j] &lt;= <span class="string">&#x27;f&#x27;</span>) &#123;</span><br><span class="line">                    keys |= <span class="number">1</span> &lt;&lt; (grid[i][j] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> <span class="number">0</span>; s &lt;= keys; s++) &#123;</span><br><span class="line">                    visited[i][j][s] = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">shortestPathAllKeys1</span><span class="params">(String[] g)</span> &#123;</span><br><span class="line">        build1(g);</span><br><span class="line">        <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>, size = r - l, x, y, s; k &lt; size; k++) &#123;</span><br><span class="line">                x = queue[l][<span class="number">0</span>];</span><br><span class="line">                y = queue[l][<span class="number">1</span>];</span><br><span class="line">                s = queue[l++][<span class="number">2</span>];</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, nx, ny, ns; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                    nx = x + move[i];</span><br><span class="line">                    ny = y + move[i + <span class="number">1</span>];</span><br><span class="line">                    ns = s;</span><br><span class="line">                    <span class="keyword">if</span> (nx &lt; <span class="number">0</span> || nx == n || ny &lt; <span class="number">0</span> || ny == m || grid[nx][ny] == <span class="string">&#x27;#&#x27;</span>) &#123;</span><br><span class="line">                        <span class="comment">// 越界或者障碍</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (grid[nx][ny] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; grid[nx][ny] &lt;= <span class="string">&#x27;F&#x27;</span> &amp;&amp; ((ns &amp; (<span class="number">1</span> &lt;&lt; (grid[nx][ny] - <span class="string">&#x27;A&#x27;</span>))) == <span class="number">0</span>)) &#123;</span><br><span class="line">                        <span class="comment">// 是锁，又没有对应的钥匙</span></span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (grid[nx][ny] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; grid[nx][ny] &lt;= <span class="string">&#x27;f&#x27;</span>) &#123;</span><br><span class="line">                        <span class="comment">// 是某一把钥匙</span></span><br><span class="line">                        ns |= (<span class="number">1</span> &lt;&lt; (grid[nx][ny] - <span class="string">&#x27;a&#x27;</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (ns == keys) &#123;</span><br><span class="line">                        <span class="comment">// 常见剪枝</span></span><br><span class="line">                        <span class="comment">// 发现终点直接返回</span></span><br><span class="line">                        <span class="comment">// 不用等都结束</span></span><br><span class="line">                        <span class="keyword">return</span> level;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (!visited[nx][ny][ns]) &#123;</span><br><span class="line">                        visited[nx][ny][ns] = <span class="literal">true</span>;</span><br><span class="line">                        queue[r][<span class="number">0</span>] = nx;</span><br><span class="line">                        queue[r][<span class="number">1</span>] = ny;</span><br><span class="line">                        queue[r++][<span class="number">2</span>] = ns;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">whichKey</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> &lt;&lt; (i - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">toSmall</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c + <span class="number">32</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isLock</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isKey</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; c &lt;= <span class="string">&#x27;f&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ShortestPathAllKeys</span> <span class="variable">shortestPathAllKeys</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ShortestPathAllKeys</span>();</span><br><span class="line">        shortestPathAllKeys.shortestPathAllKeys(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;@.a..&quot;</span>, <span class="string">&quot;###.#&quot;</span>, <span class="string">&quot;b.A.B&quot;</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 分层最短路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分层最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SwimInWater</title>
      <link href="/2024/08/06/SwimInWater/"/>
      <url>/2024/08/06/SwimInWater/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.Dijkstra;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/8/6 17:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 水位上升的泳池中游泳</span></span><br><span class="line"><span class="comment">// 在一个 n x n 的整数矩阵 grid 中</span></span><br><span class="line"><span class="comment">// 每一个方格的值 grid[i][j] 表示位置 (i, j) 的平台高度</span></span><br><span class="line"><span class="comment">// 当开始下雨时，在时间为 t 时，水池中的水位为 t</span></span><br><span class="line"><span class="comment">// 你可以从一个平台游向四周相邻的任意一个平台，但是前提是此时水位必须同时淹没这两个平台</span></span><br><span class="line"><span class="comment">// 假定你可以瞬间移动无限距离，也就是默认在方格内部游动是不耗时的</span></span><br><span class="line"><span class="comment">// 当然，在你游泳的时候你必须待在坐标方格里面。</span></span><br><span class="line"><span class="comment">// 你从坐标方格的左上平台 (0，0) 出发</span></span><br><span class="line"><span class="comment">// 返回 你到达坐标方格的右下平台 (n-1, n-1) 所需的最少时间</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/swim-in-rising-water/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SwimInWater</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] move = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//DJ算法，从源点到当前点的信息为  bfs的层高，保存最小层高</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">swimInWater</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="comment">//保存源点到该点的最小层高</span></span><br><span class="line">        <span class="type">int</span>[][] distance = <span class="keyword">new</span> <span class="title class_">int</span>[n][n];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Arrays.fill(distance[i], Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按层高排序</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="number">2</span>] - b[<span class="number">2</span>]);</span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][n];</span><br><span class="line">        <span class="comment">//注意这里取值要用数组中的值</span></span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>, grid[<span class="number">0</span>][<span class="number">0</span>]&#125;);</span><br><span class="line">        distance[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] cur = queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cur[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> cur[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> cur[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (x == n - <span class="number">1</span> &amp;&amp; y == n - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> d;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (visited[x][y]) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, nx, ny, nd; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                nx = x + move[i];</span><br><span class="line">                ny = y + move[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; n &amp;&amp; !visited[nx][ny]) &#123;</span><br><span class="line">                    <span class="comment">//超过限定值才会增加步数</span></span><br><span class="line"><span class="comment">//                    nd = d &gt;= low ? d + 1 : low;</span></span><br><span class="line">                    <span class="comment">//只要有路就走，走不了就停着，时间+1</span></span><br><span class="line">                    <span class="comment">// 大于当前路径才更新</span></span><br><span class="line"><span class="comment">//                    nd = d + 1;</span></span><br><span class="line"><span class="comment">//                    queue.add(new int[]&#123;nx,ny,nd&#125;);</span></span><br><span class="line"><span class="comment">//                    //更新当前值</span></span><br><span class="line"><span class="comment">//                    if (nd &gt;= grid[nx][ny] &amp;&amp; nd &lt; distance[nx][ny])&#123;</span></span><br><span class="line"><span class="comment">//                        distance[nx][ny] = nd;</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//憨憨，上面是原本的思路，怎么就没想到要nd和grid对齐呢?</span></span><br><span class="line">                    nd = Math.max(d, grid[nx][ny]);</span><br><span class="line">                    <span class="keyword">if</span> (nd &lt; distance[nx][ny]) &#123;</span><br><span class="line">                        distance[nx][ny] = nd;</span><br><span class="line">                        queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nx, ny, nd&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> Dijkstra </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dijkstra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinimumEffortPath</title>
      <link href="/2024/08/01/MinimumEffortPath/"/>
      <url>/2024/08/01/MinimumEffortPath/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.Dijkstra;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/8/1 18:05</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小体力消耗路径</span></span><br><span class="line"><span class="comment">// 你准备参加一场远足活动。给你一个二维 rows x columns 的地图 heights</span></span><br><span class="line"><span class="comment">// 其中 heights[row][col] 表示格子 (row, col) 的高度</span></span><br><span class="line"><span class="comment">// 一开始你在最左上角的格子 (0, 0) ，且你希望去最右下角的格子 (rows-1, columns-1)</span></span><br><span class="line"><span class="comment">// （注意下标从 0 开始编号）。你每次可以往 上，下，左，右 四个方向之一移动</span></span><br><span class="line"><span class="comment">// 你想要找到耗费 体力 最小的一条路径</span></span><br><span class="line"><span class="comment">// 一条路径耗费的体力值是路径上，相邻格子之间高度差绝对值的最大值</span></span><br><span class="line"><span class="comment">// 请你返回从左上角走到右下角的最小 体力消耗值</span></span><br><span class="line"><span class="comment">// 测试链接 ：https://leetcode.cn/problems/path-with-minimum-effort/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinimumEffortPath</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] move = &#123;-<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,-<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//distance保存差值</span></span><br><span class="line">    <span class="comment">//有想过distance一直保存差值的最小值， 但思路错了，想的是distance保持某个点的差值最小值。</span></span><br><span class="line">    <span class="comment">//正确的思路是distance保存从源点出发到该点，整条路径上的差值最大值，而不是某点</span></span><br><span class="line">    <span class="comment">//重点思考：</span></span><br><span class="line">    <span class="comment">//所以这是为什么01bfs不适用，对于01bfs来说，保持某个点的差值最小值，就是保持了整条路径差值的最大值了。因为（差值一样，0，1）</span></span><br><span class="line">    <span class="comment">//而Dijkstra正是解决权值不一样，且没负值时，从源点到每个点最小距离，</span></span><br><span class="line">    <span class="comment">// 这个最小距离也可以理解为从源点到每个点可携带的信息，只不过标准的Dijkstra携带的刚好是这些距离的和。</span></span><br><span class="line">    <span class="comment">// 所以DJ变种可以在 从源点到每个点可携带的信息上做文章， 例如此题，从源点到每个点携带的信息为 每个点差值的最大值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumEffortPath0</span><span class="params">(<span class="type">int</span>[][] heights)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> heights.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> heights[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//反正总能到达最右下角，那就将distance全都更为最小？</span></span><br><span class="line">        <span class="type">int</span>[][] distance = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                distance[i][j] = Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        distance[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[][] queue = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">200</span>][<span class="number">2</span>];</span><br><span class="line">        queue[r++] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="comment">//bfs四周扩</span></span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][m];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span>[] cur = queue[l++];</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cur[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> cur[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (visited[x][y])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, nx,ny; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                nx = x + move[i];</span><br><span class="line">                ny = y + move[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m &amp;&amp; !visited[nx][ny])&#123;</span><br><span class="line">                    <span class="keyword">if</span> ( Math.abs(heights[nx][ny] - heights[x][y]) &lt; distance[nx][ny])&#123;</span><br><span class="line">                        distance[nx][ny] = Math.abs(heights[nx][ny] - heights[x][y]);</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue[r++] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nx,ny&#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                ans = Math.max(distance[i][j], ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用Dijkstra解决，可看出套了DJ的外壳，变了从源点到每个点可携带的信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumEffortPath</span><span class="params">(<span class="type">int</span>[][] heights)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> heights.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> heights[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][m];</span><br><span class="line">        <span class="comment">//保存从源点到该点路径上的最大差值</span></span><br><span class="line">        <span class="type">int</span>[][] distance = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            Arrays.fill(distance[i], <span class="number">0</span>, m, Integer.MAX_VALUE);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="number">2</span>] - b[<span class="number">2</span>]);</span><br><span class="line">        distance[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span> , <span class="number">0</span>&#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] cur = queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cur[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> cur[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> cur[<span class="number">2</span>];</span><br><span class="line">            <span class="comment">//正是由于优先队列的存在，会优先返回差值最小的那条路径，所以这里遇到目标点可以直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (x == n - <span class="number">1</span> &amp;&amp; y == m - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> w;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (visited[x][y])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, nx, ny, nw; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                nx = x + move[i];</span><br><span class="line">                ny = y + move[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m &amp;&amp; !visited[nx][ny])&#123;</span><br><span class="line">                    <span class="comment">//用此前的差值最大值，和当前点到下一个点差值最大值做对比</span></span><br><span class="line">                    <span class="comment">//就是取包括下一个点在内的，此路径差值最大值</span></span><br><span class="line">                    nw =  Math.max(Math.abs(heights[nx][ny] - heights[x][y]), w);</span><br><span class="line">                    <span class="comment">//如果差值最大值都比已存在的小，更新差值</span></span><br><span class="line">                    <span class="keyword">if</span> (nw &lt; distance[nx][ny])&#123;</span><br><span class="line">                        distance[nx][ny] = nw;</span><br><span class="line">                        queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nx, ny, nw&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> Dijkstra </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dijkstra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DijkstraLuogu</title>
      <link href="/2024/08/01/DijkstraLuogu/"/>
      <url>/2024/08/01/DijkstraLuogu/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.Dijkstra;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>  链式前向星模板</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/8/1 14:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dijkstra算法模版（洛谷）</span></span><br><span class="line"><span class="comment">// 静态空间实现 : 链式前向星 + 反向索引堆</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P4779</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下所有代码，把主类名改成Main，可以直接通过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DijkstraLuogu</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">100001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAIM</span> <span class="operator">=</span> <span class="number">200001</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] head = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] distance = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[MAIN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] to = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] weight = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> n, m ,s;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(in);</span><br><span class="line">        <span class="keyword">while</span> (st.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            n = (<span class="type">int</span>) st.nval;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            m = (<span class="type">int</span>) st.nval;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            s = (<span class="type">int</span>) st.nval;</span><br><span class="line">            build();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                <span class="type">int</span> <span class="variable">u</span> <span class="operator">=</span> (<span class="type">int</span>) st.nval;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> (<span class="type">int</span>) st.nval;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> (<span class="type">int</span>) st.nval;</span><br><span class="line">                addEdge(u, v, w);</span><br><span class="line">            &#125;</span><br><span class="line">            compute();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">                out.print(distance[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(distance[n]);</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">()</span>&#123;</span><br><span class="line">        distance[s] = <span class="number">0</span>;</span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; queue =  <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a,b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;s, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll()[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (visited[cur])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[cur] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">ei</span> <span class="operator">=</span> head[cur], v, w; ei &gt; <span class="number">0</span>;  ei = next[ei]) &#123;</span><br><span class="line">                v = to[ei];</span><br><span class="line">                w = weight[ei];</span><br><span class="line">                <span class="keyword">if</span> (!visited[v] &amp;&amp; distance[cur] + w &lt; distance[v])&#123;</span><br><span class="line">                    distance[v] = distance[cur] + w;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;v, distance[v]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        Arrays.fill(head, <span class="number">0</span>, n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        Arrays.fill(distance, <span class="number">0</span>, n + <span class="number">1</span>, Integer.MAX_VALUE);</span><br><span class="line">        Arrays.fill(visited, <span class="number">0</span>, n + <span class="number">1</span>, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span>&#123;</span><br><span class="line">        <span class="comment">//当前边的下一条边是现在这个位置的头号边</span></span><br><span class="line">        <span class="comment">//更新当前边下一条边</span></span><br><span class="line">        next[cnt] = head[u];</span><br><span class="line">        to[cnt] = v;</span><br><span class="line">        weight[cnt] = w;</span><br><span class="line">        head[u] = cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> Dijkstra </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dijkstra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DijkstraLeetcode</title>
      <link href="/2024/08/01/DijkstraLeetcode/"/>
      <url>/2024/08/01/DijkstraLeetcode/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.Dijkstra;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/8/1 14:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Dijkstra算法模版（Leetcode）</span></span><br><span class="line"><span class="comment">// 网络延迟时间</span></span><br><span class="line"><span class="comment">// 有 n 个网络节点，标记为 1 到 n</span></span><br><span class="line"><span class="comment">// 给你一个列表 times，表示信号经过 有向 边的传递时间</span></span><br><span class="line"><span class="comment">// times[i] = (ui, vi, wi)，表示从ui到vi传递信号的时间是wi</span></span><br><span class="line"><span class="comment">// 现在，从某个节点 s 发出一个信号</span></span><br><span class="line"><span class="comment">// 需要多久才能使所有节点都收到信号</span></span><br><span class="line"><span class="comment">// 如果不能使所有节点收到信号，返回 -1</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/network-delay-time</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DijkstraLeetcode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求最短路径，DJ算法</span></span><br><span class="line">    <span class="comment">//注意distance的定义</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">networkDelayTime</span><span class="params">(<span class="type">int</span>[][] times, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        ArrayList&lt;ArrayList&lt;<span class="type">int</span>[]&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//距离数组</span></span><br><span class="line">        <span class="type">int</span>[] distance = <span class="keyword">new</span> <span class="title class_">int</span>[n+<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//访问过的节点</span></span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//注意这里要从零填充graph</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            distance[i] = Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//建图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] time : times) &#123;</span><br><span class="line">            graph.get(time[<span class="number">0</span>]).add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;time[<span class="number">1</span>], time[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//源点到当前点的距离排序</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">        distance[k] = <span class="number">0</span>;</span><br><span class="line">        queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;k, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="comment">//弹出来处理当前边 去往下一条边</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] poll = queue.poll();</span><br><span class="line">            <span class="comment">//当前边</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> poll[<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//处理过就不处理了</span></span><br><span class="line">            <span class="keyword">if</span> (visited[cur])&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            visited[cur] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//下一条边和权值</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] g : graph.get(cur)) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> g[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> g[<span class="number">1</span>];</span><br><span class="line">                <span class="comment">//如果下一个点没处理过 &amp;&amp; 走当前这条路 比 之前的距离短</span></span><br><span class="line">                <span class="keyword">if</span> (!visited[next] &amp;&amp; distance[cur] + w &lt; distance[next])&#123;</span><br><span class="line">                    distance[next] = distance[cur] + w;</span><br><span class="line">                    <span class="comment">//源点到当前next点 的距离为 distance[next]。 入队</span></span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;next, distance[next]&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (distance[i] == Integer.MAX_VALUE)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(distance[i], ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> Dijkstra </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dijkstra </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinAbsDifference</title>
      <link href="/2024/07/31/MinAbsDifference/"/>
      <url>/2024/07/31/MinAbsDifference/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.双向广搜;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 双向广搜难点在于，双指针左右两边合并的思路</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/31 17:38</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最接近目标值的子序列和</span></span><br><span class="line"><span class="comment">// 给你一个整数数组 nums 和一个目标值 goal</span></span><br><span class="line"><span class="comment">// 你需要从 nums 中选出一个子序列，使子序列元素总和最接近 goal</span></span><br><span class="line"><span class="comment">// 也就是说，如果子序列元素和为 sum ，你需要 最小化绝对差 abs(sum - goal)</span></span><br><span class="line"><span class="comment">// 返回 abs(sum - goal) 可能的 最小值</span></span><br><span class="line"><span class="comment">// 注意，数组的子序列是通过移除原始数组中的某些元素（可能全部或无）而形成的数组。</span></span><br><span class="line"><span class="comment">// 数据量描述:</span></span><br><span class="line"><span class="comment">// 1 &lt;= nums.length &lt;= 40</span></span><br><span class="line"><span class="comment">// -10^7 &lt;= nums[i] &lt;= 10^7</span></span><br><span class="line"><span class="comment">// -10^9 &lt;= goal &lt;= 10^9</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/closest-subsequence-sum/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinAbsDifference</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个选择后 子序列的结果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] larr = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] rarr = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个位置拿或不拿组成的所有结果，但是由于数据太多，所以用双向广搜</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minAbsDifference</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> goal)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//剪枝操作</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                max += nums[i];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                min += nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//所有最大值都小于goal</span></span><br><span class="line">        <span class="keyword">if</span> (max &lt; goal) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>) Math.abs(max - goal);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//所有最小值都大于goal</span></span><br><span class="line">        <span class="keyword">if</span> (min &gt; goal) &#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="type">int</span>) Math.abs(min - goal);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//每个位置拿或不拿，组成的所有结果，在和goal对比</span></span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        f(<span class="number">0</span>, n / <span class="number">2</span>, larr, <span class="number">0</span>, nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">lsize</span> <span class="operator">=</span> cnt;</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        f(n / <span class="number">2</span>, n, rarr, <span class="number">0</span>, nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rsize</span> <span class="operator">=</span> cnt;</span><br><span class="line">        Arrays.sort(larr, <span class="number">0</span>, lsize);</span><br><span class="line">        Arrays.sort(rarr, <span class="number">0</span>, rsize);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Math.abs(goal);</span><br><span class="line">        <span class="comment">//目标是左右两边相加 和goal的差值尽可能小</span></span><br><span class="line">        <span class="comment">//这里用两个for循环会超时，要用双指针不回退</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, i = rsize - <span class="number">1</span>; j &lt; lsize; j++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &gt; <span class="number">0</span> &amp;&amp; Math.abs(goal - rarr[i] - larr[j]) &gt;= Math.abs(goal - rarr[i - <span class="number">1</span>] - larr[j]))&#123;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.min(ans, Math.abs(goal - rarr[i] - larr[j]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归获取所有路径的结果, 并返回数组长度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">int</span>[] arr, <span class="type">int</span> sum, <span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end) &#123;</span><br><span class="line">            arr[cnt++] = sum;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//原本思路</span></span><br><span class="line"><span class="comment">//        //不拿 当前值</span></span><br><span class="line"><span class="comment">//        f(start + 1, end, arr, sum, nums);</span></span><br><span class="line"><span class="comment">//        //拿当前值</span></span><br><span class="line"><span class="comment">//        return f(start + 1, end, arr, sum + nums[start], nums);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//剪枝操作，跳过重复值的拿取</span></span><br><span class="line">        <span class="comment">// nums[i.....]这一组，相同的数字有几个</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> start + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (j &lt; end &amp;&amp; nums[j] == nums[start]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nums[ 1 1 1 1 1 2....</span></span><br><span class="line">        <span class="comment">//       i         j</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt;= j - start; k++) &#123;</span><br><span class="line">            <span class="comment">// k = 0个</span></span><br><span class="line">            <span class="comment">// k = 1个</span></span><br><span class="line">            <span class="comment">// k = 2个</span></span><br><span class="line">            <span class="comment">//剪枝操作，跳过重复值的拿取</span></span><br><span class="line">            f(j, end, arr, sum + k * nums[start], nums);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 双向广搜 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双向广搜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SnacksWaysBuyTickets</title>
      <link href="/2024/07/31/SnacksWaysBuyTickets/"/>
      <url>/2024/07/31/SnacksWaysBuyTickets/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.双向广搜;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/31 10:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 牛牛的背包问题 &amp; 世界冰球锦标赛</span></span><br><span class="line"><span class="comment">// 牛牛准备参加学校组织的春游, 出发前牛牛准备往背包里装入一些零食, 牛牛的背包容量为w。</span></span><br><span class="line"><span class="comment">// 牛牛家里一共有n袋零食, 第i袋零食体积为v[i]。</span></span><br><span class="line"><span class="comment">// 牛牛想知道在总体积不超过背包容量的情况下,他一共有多少种零食放法(总体积为0也算一种放法)。</span></span><br><span class="line"><span class="comment">// 输入描述：</span></span><br><span class="line"><span class="comment">// 输入包括两行</span></span><br><span class="line"><span class="comment">// 第一行为两个正整数n和w(1 &lt;= n &lt;= 30, 1 &lt;= w &lt;= 2 * 10^9),表示零食的数量和背包的容量</span></span><br><span class="line"><span class="comment">// 第二行n个正整数v[i](0 &lt;= v[i] &lt;= 10^9),表示每袋零食的体积</span></span><br><span class="line"><span class="comment">// 输出描述：</span></span><br><span class="line"><span class="comment">// 输出一个正整数, 表示牛牛一共有多少种零食放法。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P4799</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下所有代码，把主类名改成Main，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SnacksWaysBuyTickets</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXM</span> <span class="operator">=</span> <span class="number">1</span> &lt;&lt; <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span>[] arr = <span class="keyword">new</span> <span class="title class_">long</span>[MAIN];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span>[] larr = <span class="keyword">new</span> <span class="title class_">long</span>[MAXM];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span>[] rarr = <span class="keyword">new</span> <span class="title class_">long</span>[MAXM];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> m;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//怎么保存某条路径的结果？ 递归？</span></span><br><span class="line">    <span class="comment">//这题注意数据量，要用long取值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(bf);</span><br><span class="line">        <span class="keyword">while</span> (st.nextToken() != StreamTokenizer.TT_EOF)&#123;</span><br><span class="line">            n = (<span class="type">int</span>) st.nval;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            m = (<span class="type">long</span>) st.nval;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                arr[i] = (<span class="type">long</span>) st.nval;</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(findLess());</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        bf.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">findLess</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//数组记录的是总花费</span></span><br><span class="line"><span class="comment">//        int llen = 1 &lt;&lt; (n / 2);</span></span><br><span class="line"><span class="comment">//        int rlen = 1 &lt;&lt; ((n + 1) / 2);</span></span><br><span class="line"><span class="comment">//        long[] larr = new long[llen];</span></span><br><span class="line"><span class="comment">//        long[] rarr = new long[rlen];</span></span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//左边递归 将结果填充到larr</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lsize</span> <span class="operator">=</span> f(<span class="number">0</span>, n &gt;&gt; <span class="number">1</span>, larr, <span class="number">0</span>);</span><br><span class="line">        cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//右边递归</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">rsize</span> <span class="operator">=</span> f(n &gt;&gt; <span class="number">1</span>, n, rarr, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//排序数组</span></span><br><span class="line">        Arrays.sort(larr, <span class="number">0</span>, lsize);</span><br><span class="line">        Arrays.sort(rarr, <span class="number">0</span>, rsize);</span><br><span class="line">        <span class="comment">//双指针对比larr和rarr</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将左右数组总花费和限制做对比，取所有符合条件的结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lsize - <span class="number">1</span>, j = <span class="number">0</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt; rsize &amp;&amp; rarr[j] + larr[i] &lt;= m)&#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//返回总结果</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end, <span class="type">long</span>[] cntArr, <span class="type">long</span> sum)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start == end)&#123;</span><br><span class="line">            cntArr[cnt++] = sum;</span><br><span class="line">            <span class="keyword">return</span> cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        f(start + <span class="number">1</span>, end, cntArr, sum + arr[start]);</span><br><span class="line">        <span class="keyword">return</span>  f(start + <span class="number">1</span>, end, cntArr,  sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 双向广搜 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双向广搜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LadderLength</title>
      <link href="/2024/07/30/LadderLength/"/>
      <url>/2024/07/30/LadderLength/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.双向广搜;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/30 23:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单词接龙</span></span><br><span class="line"><span class="comment">// 字典 wordList 中从单词 beginWord 和 endWord 的 转换序列</span></span><br><span class="line"><span class="comment">// 是一个按下述规格形成的序列 beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk ：</span></span><br><span class="line"><span class="comment">// 每一对相邻的单词只差一个字母。</span></span><br><span class="line"><span class="comment">// 对于 1 &lt;= i &lt;= k 时，每个 si 都在 wordList 中</span></span><br><span class="line"><span class="comment">// 注意， beginWord 不需要在 wordList 中。sk == endWord</span></span><br><span class="line"><span class="comment">// 给你两个单词 beginWord 和 endWord 和一个字典 wordList</span></span><br><span class="line"><span class="comment">// 返回 从 beginWord 到 endWord 的 最短转换序列 中的 单词数目</span></span><br><span class="line"><span class="comment">// 如果不存在这样的转换序列，返回 0 。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/word-ladder/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LadderLength</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashSet&lt;String&gt; bigSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashSet&lt;String&gt; nextSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashSet&lt;String&gt; smallSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashSet&lt;String&gt; dicSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//双向广搜</span></span><br><span class="line">    <span class="comment">//beginWord向end搜的同时，end也向begin展开</span></span><br><span class="line">    <span class="comment">//取数量最少的那层当下层展开节点</span></span><br><span class="line">    <span class="comment">//直到下层展开节点在begin展开 或者end展开中，结束，返回level</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//模板： smallSet, bigSet, nextSet</span></span><br><span class="line">    <span class="comment">//nextSet放smallSet展开的下一层，smallSet永远放最小层</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//展开：当前字符串，每个字母变换的节点</span></span><br><span class="line">    <span class="comment">//没看左神代码，完全根据思路自己写的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">ladderLength</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!wordList.contains(endWord))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bigSet.clear();</span><br><span class="line">        smallSet.clear();</span><br><span class="line">        nextSet.clear();</span><br><span class="line">        dicSet.clear();</span><br><span class="line"></span><br><span class="line">        dicSet.addAll(wordList);</span><br><span class="line">        bigSet.add(beginWord);</span><br><span class="line">        smallSet.add(endWord);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (!smallSet.isEmpty())&#123;</span><br><span class="line">            level++;</span><br><span class="line">            <span class="comment">//去除已处理字符串</span></span><br><span class="line">            dicSet.removeAll(smallSet);</span><br><span class="line">            <span class="comment">//展开next</span></span><br><span class="line">            <span class="keyword">for</span> (String cur : smallSet) &#123;</span><br><span class="line">                <span class="type">char</span>[] arr = cur.toCharArray();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">                    <span class="type">char</span> <span class="variable">old</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++) &#123;</span><br><span class="line">                        arr[i] = c;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> String.valueOf(arr);</span><br><span class="line">                        <span class="keyword">if</span> (!cur.equals(next))&#123;</span><br><span class="line">                            <span class="keyword">if</span> (bigSet.contains(next))&#123;</span><br><span class="line">                                <span class="keyword">return</span> level;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//如果在序列中</span></span><br><span class="line">                            <span class="keyword">if</span> (dicSet.contains(next))&#123;</span><br><span class="line">                                nextSet.add(next);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    arr[i] = old;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            HashSet&lt;String&gt; tmp = nextSet;</span><br><span class="line">            nextSet = smallSet;</span><br><span class="line">            smallSet = tmp;</span><br><span class="line">            nextSet.clear();</span><br><span class="line">            <span class="comment">//放最少那个</span></span><br><span class="line">            <span class="keyword">if</span> (bigSet.size() &lt; smallSet.size())&#123;</span><br><span class="line">                tmp = bigSet;</span><br><span class="line">                bigSet = smallSet;</span><br><span class="line">                smallSet = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 双向广搜 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双向广搜 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FindLadders</title>
      <link href="/2024/07/26/FindLadders/"/>
      <url>/2024/07/26/FindLadders/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.宽度优先遍历扩展;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>  赶紧这题只能记下来了，很多细节</span></span><br><span class="line"><span class="comment"> * bfs+反建图-》dfs</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/26 16:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单词接龙 II</span></span><br><span class="line"><span class="comment">// 按字典 wordList 完成从单词 beginWord 到单词 endWord 转化</span></span><br><span class="line"><span class="comment">// 一个表示此过程的 转换序列 是形式上像</span></span><br><span class="line"><span class="comment">// beginWord -&gt; s1 -&gt; s2 -&gt; ... -&gt; sk 这样的单词序列，并满足：</span></span><br><span class="line"><span class="comment">// 每对相邻的单词之间仅有单个字母不同</span></span><br><span class="line"><span class="comment">// 转换过程中的每个单词 si（1 &lt;= i &lt;= k）必须是字典 wordList 中的单词</span></span><br><span class="line"><span class="comment">// 注意，beginWord 不必是字典 wordList 中的单词</span></span><br><span class="line"><span class="comment">// sk == endWord</span></span><br><span class="line"><span class="comment">// 给你两个单词 beginWord 和 endWord ，以及一个字典 wordList</span></span><br><span class="line"><span class="comment">// 请你找出并返回所有从 beginWord 到 endWord 的 最短转换序列</span></span><br><span class="line"><span class="comment">// 如果不存在这样的转换序列，返回一个空列表</span></span><br><span class="line"><span class="comment">// 每个序列都应该以单词列表 [beginWord, s1, s2, ..., sk] 的形式返回</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindLadders</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashMap&lt;String, HashSet&lt;String&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> HashSet&lt;String&gt; dict;</span><br><span class="line">    <span class="comment">//展开的当前层</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashSet&lt;String&gt; curLevel = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//展开的下一层</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashSet&lt;String&gt; nextLevel = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LinkedList&lt;String&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这题就很猛了</span></span><br><span class="line">    <span class="comment">//好像很多单词类的题，a单词 -》z单词，都是一层层展开建图的解法</span></span><br><span class="line">    <span class="comment">//但这题因为要求所有的最短转换序列，所以在bfs展开后，还要建反图，方便dfs查找路径</span></span><br><span class="line">    <span class="comment">//其他的就是细节问题了，剪枝优化。</span></span><br><span class="line">    <span class="comment">// 这题还有个特殊点，展开的所有结果，都要建反图</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="title function_">findLadders</span><span class="params">(String beginWord, String endWord, List&lt;String&gt; wordList)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//边界，不存在直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (!wordList.contains(endWord)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="comment">//用hashSet去做，快10多倍。去重</span></span><br><span class="line">        dict = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(wordList);</span><br><span class="line">        curLevel.clear();</span><br><span class="line">        nextLevel.clear();</span><br><span class="line">        graph.clear();</span><br><span class="line">        ans.clear();</span><br><span class="line">        path.clear();</span><br><span class="line">        <span class="comment">//bfs建图、反图</span></span><br><span class="line">        <span class="keyword">if</span> (bfs(beginWord, endWord)) &#123;</span><br><span class="line">            <span class="comment">//dfs获取路径.反图获取路</span></span><br><span class="line">            dfs(endWord, beginWord);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">bfs</span><span class="params">(String beginWord, String endWord)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">find</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        curLevel.add(beginWord);</span><br><span class="line">        <span class="keyword">while</span> (!curLevel.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//避免重复展开同一字符，所以单词表去除当前展开的所有字符</span></span><br><span class="line">            dict.removeAll(curLevel);</span><br><span class="line">            <span class="keyword">for</span> (String cur : curLevel) &#123;</span><br><span class="line">                <span class="type">char</span>[] word = cur.toCharArray();</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length; i++) &#123;</span><br><span class="line">                    <span class="type">char</span> <span class="variable">old</span> <span class="operator">=</span> word[i];</span><br><span class="line">                    <span class="comment">//针对当前字符串，变换每个字符展开下一层</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> <span class="string">&#x27;a&#x27;</span>; c &lt;= <span class="string">&#x27;z&#x27;</span>; c++) &#123;</span><br><span class="line">                        word[i] = c;</span><br><span class="line">                        <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> String.valueOf(word);</span><br><span class="line">                        <span class="comment">//如果得到的字符在单词表里， 则建反图，同时加入下一层字符串</span></span><br><span class="line">                        <span class="keyword">if</span> (dict.contains(next) &amp;&amp; !next.equals(cur))&#123;</span><br><span class="line">                            <span class="comment">//如果得到了目标字符串，退出，返回结果</span></span><br><span class="line">                            <span class="keyword">if</span> (next.equals(endWord))&#123;</span><br><span class="line">                                find = <span class="literal">true</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            nextLevel.add(next);</span><br><span class="line">                            graph.putIfAbsent(next, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">                            <span class="comment">//反图</span></span><br><span class="line">                            graph.get(next).add(cur);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//恢复</span></span><br><span class="line">                    word[i] = old;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (find) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//交换当前层和下一层</span></span><br><span class="line">            HashSet&lt;String&gt; tmp = curLevel;</span><br><span class="line">            curLevel = nextLevel;</span><br><span class="line">            nextLevel = tmp;</span><br><span class="line">            nextLevel.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(String cur, String target)</span>&#123;</span><br><span class="line">        <span class="comment">//来到当前路径就加到最前</span></span><br><span class="line">        path.addFirst(cur);</span><br><span class="line">        <span class="keyword">if</span> (cur.equals(target))&#123;</span><br><span class="line">            ans.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(path));</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (graph.containsKey(cur))&#123;<span class="comment">//如果反图有这个，那就遍历图的下一层</span></span><br><span class="line">            <span class="keyword">for</span> (String next : graph.get(cur)) &#123;</span><br><span class="line">                dfs(next, target);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//恢复路径</span></span><br><span class="line">        path.removeFirst();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 宽度优先遍历扩展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 宽度优先遍历扩展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TrapRainWater</title>
      <link href="/2024/07/26/TrapRainWater/"/>
      <url>/2024/07/26/TrapRainWater/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.宽度优先遍历扩展;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 二维接雨水，知道思路就很简单。难点在于思路难想</span></span><br><span class="line"><span class="comment"> * bfs + 优先队列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/26 15:03</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维接雨水</span></span><br><span class="line"><span class="comment">// 给你一个 m * n 的矩阵，其中的值均为非负整数，代表二维高度图每个单元的高度</span></span><br><span class="line"><span class="comment">// 请计算图中形状最多能接多少体积的雨水。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/trapping-rain-water-ii/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrapRainWater</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] move = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有个想法，先找出边缘最低。然后就没了。。。</span></span><br><span class="line">    <span class="comment">//左神思路：很难想啊</span></span><br><span class="line">    <span class="comment">// bfs + 优先队列。每次都从最低水线往旁边扩</span></span><br><span class="line">    <span class="comment">//想到了bfs用最低最先来展开，但有个坎就是 扩到的格子的水线</span></span><br><span class="line">    <span class="comment">//扩到的格子的水线  = Max(自己水线，感染过来的水线），这一步就很难想到</span></span><br><span class="line">    <span class="comment">//当前格的储水量 = 当前格水线 - 当前格高度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trapRainWater</span><span class="params">(<span class="type">int</span>[][] heightMap)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> heightMap.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> heightMap[<span class="number">0</span>].length;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//小根堆，根据水线排序</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="number">2</span>] - b[<span class="number">2</span>]);</span><br><span class="line">        <span class="comment">//访问过的柱子不再扩</span></span><br><span class="line">        <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n][m];</span><br><span class="line">        <span class="comment">//先获取边缘的水线</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || i == n - <span class="number">1</span> || j == <span class="number">0</span> || j == m - <span class="number">1</span>) &#123;</span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;i, j, heightMap[i][j]&#125;);</span><br><span class="line">                    visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从最低水线往旁边扩</span></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] cur = queue.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cur[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> cur[<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">w</span> <span class="operator">=</span> cur[<span class="number">2</span>];</span><br><span class="line">            ans += w - heightMap[x][y];</span><br><span class="line">            <span class="comment">//上下左右四个方向扩</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, nx, ny; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                nx = x + move[i];</span><br><span class="line">                ny = y + move[i + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m &amp;&amp; !visited[nx][ny]) &#123;</span><br><span class="line">                    <span class="comment">//取当前水线 和感染水线的最大值</span></span><br><span class="line">                    queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nx, ny, Math.max(heightMap[nx][ny], w)&#125;);</span><br><span class="line">                    visited[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 宽度优先遍历扩展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 宽度优先遍历扩展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinCost</title>
      <link href="/2024/07/26/MinCost/"/>
      <url>/2024/07/26/MinCost/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.宽度优先遍历扩展;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 01bfs问题，不能用普通的bfs解。 直接上01bfs模板</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/26 10:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使网格图至少有一条有效路径的最小代价</span></span><br><span class="line"><span class="comment">// 给你一个 m * n 的网格图 grid 。 grid 中每个格子都有一个数字</span></span><br><span class="line"><span class="comment">// 对应着从该格子出发下一步走的方向。 grid[i][j] 中的数字可能为以下几种情况：</span></span><br><span class="line"><span class="comment">// 1 ，下一步往右走，也就是你会从 grid[i][j] 走到 grid[i][j + 1]</span></span><br><span class="line"><span class="comment">// 2 ，下一步往左走，也就是你会从 grid[i][j] 走到 grid[i][j - 1]</span></span><br><span class="line"><span class="comment">// 3 ，下一步往下走，也就是你会从 grid[i][j] 走到 grid[i + 1][j]</span></span><br><span class="line"><span class="comment">// 4 ，下一步往上走，也就是你会从 grid[i][j] 走到 grid[i - 1][j]</span></span><br><span class="line"><span class="comment">// 注意网格图中可能会有 无效数字 ，因为它们可能指向 grid 以外的区域</span></span><br><span class="line"><span class="comment">// 一开始，你会从最左上角的格子 (0,0) 出发</span></span><br><span class="line"><span class="comment">// 我们定义一条 有效路径 为从格子 (0,0) 出发，每一步都顺着数字对应方向走</span></span><br><span class="line"><span class="comment">// 最终在最右下角的格子 (m - 1, n - 1) 结束的路径</span></span><br><span class="line"><span class="comment">// 有效路径 不需要是最短路径</span></span><br><span class="line"><span class="comment">// 你可以花费1的代价修改一个格子中的数字，但每个格子中的数字 只能修改一次</span></span><br><span class="line"><span class="comment">// 请你返回让网格图至少有一条有效路径的最小代价</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/minimum-cost-to-make-at-least-one-valid-path-in-a-grid/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinCost</span> &#123;</span><br><span class="line">    <span class="comment">//什么时候必须改方向？ 走过的路 以及 越界时，必须改了</span></span><br><span class="line">    <span class="comment">//改的方向是 没走过的格子。即把没走过的格子入队</span></span><br><span class="line">    <span class="comment">//难点在于当有多个方向可选择时，怎么记录最终最少的改动呢？</span></span><br><span class="line">    <span class="comment">//也一样用前缀和记录？需要改的话就是1，不用改就是0</span></span><br><span class="line">    <span class="comment">//改动方向时，当前格子+1,只有当前格子 + 下一格子 的值 小于 下一格子时才走</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//嗯 好的。还是不会，越来越菜嘿嘿嘿</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCost0</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line"><span class="comment">//        int[] move = &#123;-1, 0, 1, 0, -1&#125;;</span></span><br><span class="line"><span class="comment">//        int n = grid.length;</span></span><br><span class="line"><span class="comment">//        int m = grid[0].length;</span></span><br><span class="line"><span class="comment">//        int[][] distance = new int[n][m];</span></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//            for (int j = 0; j &lt; m; j++) &#123;</span></span><br><span class="line"><span class="comment">//                distance[i][j] = Integer.MAX_VALUE;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//        ArrayDeque&lt;int[]&gt; deque = new ArrayDeque&lt;&gt;();</span></span><br><span class="line"><span class="comment">//        //只有走过，且该格子有改动过方向，才不走</span></span><br><span class="line"><span class="comment">//        boolean[][] visited = new boolean[n][m];</span></span><br><span class="line"><span class="comment">//        deque.addFirst(new int[]&#123;0, 0&#125;);</span></span><br><span class="line"><span class="comment">//        visited[0][0] = true;</span></span><br><span class="line"><span class="comment">//        distance[0][0] = 0;</span></span><br><span class="line"><span class="comment">//        while (!deque.isEmpty())&#123;</span></span><br><span class="line"><span class="comment">//            int[] cur = deque.pollFirst();</span></span><br><span class="line"><span class="comment">//            int x = cur[0];</span></span><br><span class="line"><span class="comment">//            int y = cur[0];</span></span><br><span class="line"><span class="comment">//            if (x == n - 1 &amp;&amp; y == m - 1)&#123;</span></span><br><span class="line"><span class="comment">//                return distance[x][y];</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//            for (int i = 0, nx, ny, weight; i &lt; move.length; i++) &#123;</span></span><br><span class="line"><span class="comment">//                nx = x + move[i];</span></span><br><span class="line"><span class="comment">//                ny = y + move[i + 1];</span></span><br><span class="line"><span class="comment">//                //只要改方向，那就+1</span></span><br><span class="line"><span class="comment">//                weight = grid[x][y] != i ? 1 : 0;</span></span><br><span class="line"><span class="comment">//                //没访问过，或者 有访问过但改动次数 大于当前</span></span><br><span class="line"><span class="comment">//                if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m)&#123;</span></span><br><span class="line"><span class="comment">//                    //没走过可以直接走，优先走不用改变方向的格子</span></span><br><span class="line"><span class="comment">//                    if(!visited[nx][ny])&#123;</span></span><br><span class="line"><span class="comment">//                        if (hr)&#123;</span></span><br><span class="line"><span class="comment">//                            deque.addFirst(new int[]&#123;nx,ny&#125;);</span></span><br><span class="line"><span class="comment">//                        &#125;else &#123;</span></span><br><span class="line"><span class="comment">//                            deque.addLast(new int[]&#123;nx,ny&#125;);</span></span><br><span class="line"><span class="comment">//                        &#125;</span></span><br><span class="line"><span class="comment">//                    &#125;else &#123;</span></span><br><span class="line"><span class="comment">//                        //是否要改变方向</span></span><br><span class="line"><span class="comment">//                        int ad = hr ? 0 : 1;</span></span><br><span class="line"><span class="comment">//                        //如果下一个格子大于当前格子路径</span></span><br><span class="line"><span class="comment">//                        //</span></span><br><span class="line"><span class="comment">//                        if (distance[nx][ny] &gt; distance[x][y] + ad)&#123;</span></span><br><span class="line"><span class="comment">//                            distance[nx][ny] = distance[x][y] + ad;</span></span><br><span class="line"><span class="comment">//                            visited[nx][ny] = true;</span></span><br><span class="line"><span class="comment">//                            deque.addFirst(new int[]&#123;nx,ny&#125;);</span></span><br><span class="line"><span class="comment">//                        &#125;</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//01bfs问题，直接上模板先</span></span><br><span class="line">    <span class="comment">//bfs + 双端队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minCost</span><span class="params">(<span class="type">int</span>[][] grid)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] distance = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按右左下上的顺序，好处理原方向</span></span><br><span class="line">        <span class="type">int</span>[][] move = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, -<span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;-<span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                distance[i][j] = Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArrayDeque&lt;<span class="type">int</span>[]&gt; deque = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        deque.addFirst(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        distance[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!deque.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] cur = deque.pollFirst();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cur[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> cur[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//到达目标了，返回权值</span></span><br><span class="line">            <span class="keyword">if</span> (x == n - <span class="number">1</span> &amp;&amp; y == m - <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> distance[x][y];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//四个方向走，当走的方向不同原点方向时，即权值为1</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, nx, ny, weight; i &lt;= <span class="number">4</span>; i++) &#123;</span><br><span class="line">                nx = x + move[i][<span class="number">0</span>];</span><br><span class="line">                ny = y + move[i][<span class="number">1</span>];</span><br><span class="line">                <span class="comment">//走的方向和当前格子原方向不同，则权值1</span></span><br><span class="line">                weight = i == grid[x][y] ? <span class="number">0</span> : <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m</span><br><span class="line">                        &amp;&amp; distance[nx][ny] &gt; distance[x][y] + weight)&#123;</span><br><span class="line">                    distance[nx][ny] = distance[x][y] + weight;</span><br><span class="line">                    <span class="comment">//不改方向队头进队</span></span><br><span class="line">                    <span class="keyword">if</span> (weight == <span class="number">0</span>) &#123;</span><br><span class="line">                        deque.addFirst(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nx, ny&#125;);</span><br><span class="line">                    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                        deque.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nx, ny&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">hasRoad</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">boolean</span>[][] visited)</span>&#123;</span><br><span class="line"><span class="comment">//        visited[x][y] = true;</span></span><br><span class="line"><span class="comment">//        for (int i = 0, nx, ny; i &lt; move.length; i++)&#123;</span></span><br><span class="line"><span class="comment">//            nx = x + move[i];</span></span><br><span class="line"><span class="comment">//            ny = y + move[i + 1];</span></span><br><span class="line"><span class="comment">//            if (nx &gt;= 0 &amp;&amp; ny &gt;= 0 &amp;&amp; nx &lt; n &amp;&amp; ny &lt; m &amp;&amp; visited[nx][ny])&#123;</span></span><br><span class="line"><span class="comment">//                return true;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//        visited[x][y] = false;</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 宽度优先遍历扩展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 宽度优先遍历扩展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinimumObstacles</title>
      <link href="/2024/07/24/MinimumObstacles/"/>
      <url>/2024/07/24/MinimumObstacles/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.宽度优先遍历扩展;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayDeque;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>  和bfs扩展模板完全不一样，bfs + 前缀和 + 贪心吧</span></span><br><span class="line"><span class="comment"> * // 原来这是 01bfs问题，不能用普通的bfs解。 直接上01bfs模板</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/24 17:19</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 到达角落需要移除障碍物的最小数目</span></span><br><span class="line"><span class="comment">// 给你一个下标从 0 开始的二维整数数组 grid ，数组大小为 m x n</span></span><br><span class="line"><span class="comment">// 每个单元格都是两个值之一：</span></span><br><span class="line"><span class="comment">// 0 表示一个 空 单元格，</span></span><br><span class="line"><span class="comment">// 1 表示一个可以移除的 障碍物</span></span><br><span class="line"><span class="comment">// 你可以向上、下、左、右移动，从一个空单元格移动到另一个空单元格。</span></span><br><span class="line"><span class="comment">// 现在你需要从左上角 (0, 0) 移动到右下角 (m - 1, n - 1)</span></span><br><span class="line"><span class="comment">// 返回需要移除的障碍物的最小数目</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/minimum-obstacle-removal-to-reach-corner/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinimumObstacles</span> &#123;</span><br><span class="line">    <span class="comment">//和基础的bfs模板不一样，这里走过的路径还能走，取最容易走的那条</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] move = &#123;-<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//bfs每一条路径都展开，取移除障碍物最小那条</span></span><br><span class="line">    <span class="comment">//难点在于怎么统计路径上移除了多少个障碍物？</span></span><br><span class="line">    <span class="comment">//无敌了，和前缀和结合，下一个格子路径 只取移除障碍物更小的路径值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumObstacles</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line"><span class="comment">//        LinkedList&lt;int[]&gt; queue = new LinkedList&lt;&gt;();</span></span><br><span class="line">        <span class="comment">//这个快了一半</span></span><br><span class="line">        ArrayDeque&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">ArrayDeque</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//和基础的bfs模板不一样，这里走过的路径还能走，取最容易走的那条</span></span><br><span class="line">        <span class="comment">//初始化每个格子的路，bfs和前缀和结合</span></span><br><span class="line">        <span class="type">int</span>[][] distance = <span class="keyword">new</span> <span class="title class_">int</span>[n][m];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                distance[i][j] = Integer.MAX_VALUE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//入队</span></span><br><span class="line">        queue.addFirst(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        distance[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">int</span>[] cur = queue.pollFirst();</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> cur[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> cur[<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//到最后一个格子了，不展开了，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (x == n - <span class="number">1</span> &amp;&amp; y == m - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> distance[x][y];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//四个方向走</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, nx, ny; j &lt; <span class="number">4</span>; j++) &#123;</span><br><span class="line">                nx = x + move[j];</span><br><span class="line">                ny = y + move[j + <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; m</span><br><span class="line">                        <span class="comment">//只有当前路总和 + 下一格子的路 比 下一格子更优时，才走这条路</span></span><br><span class="line">                        <span class="comment">//怎么赶紧还有点动态规划的思想</span></span><br><span class="line">                        &amp;&amp; distance[x][y] + grid[nx][ny] &lt; distance[nx][ny]) &#123;</span><br><span class="line">                    distance[nx][ny] = distance[x][y] + grid[nx][ny];</span><br><span class="line">                    <span class="comment">//优先走无障碍的格子</span></span><br><span class="line">                    <span class="keyword">if</span> (grid[nx][ny] == <span class="number">0</span>) &#123;</span><br><span class="line">                        queue.addFirst(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nx, ny&#125;);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        queue.addLast(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;nx, ny&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 宽度优先遍历扩展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 宽度优先遍历扩展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinStickers</title>
      <link href="/2024/07/23/MinStickers/"/>
      <url>/2024/07/23/MinStickers/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.宽度优先遍历扩展;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>  锻炼bfs模板，难点在于怎么想到路的展开</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/23 18:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 贴纸拼词</span></span><br><span class="line"><span class="comment">// 我们有 n 种不同的贴纸。每个贴纸上都有一个小写的英文单词。</span></span><br><span class="line"><span class="comment">// 您想要拼写出给定的字符串 target ，方法是从收集的贴纸中切割单个字母并重新排列它们</span></span><br><span class="line"><span class="comment">// 如果你愿意，你可以多次使用每个贴纸，每个贴纸的数量是无限的。</span></span><br><span class="line"><span class="comment">// 返回你需要拼出 target 的最小贴纸数量。如果任务不可能，则返回 -1</span></span><br><span class="line"><span class="comment">// 注意：在所有的测试用例中，所有的单词都是从 1000 个最常见的美国英语单词中随机选择的</span></span><br><span class="line"><span class="comment">// 并且 target 被选择为两个随机单词的连接。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/stickers-to-spell-word/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinStickers</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">401</span>;</span><br><span class="line">    <span class="comment">//用来剪枝加速的，记录每个包含该字母的贴纸</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ArrayList&lt;ArrayList&lt;String&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(<span class="number">26</span>);</span><br><span class="line">    <span class="comment">//bfs队列  用于每层贴纸展开</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] queue = <span class="keyword">new</span> <span class="title class_">String</span>[MAIN];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> l, r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//避免重复展开</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> HashSet&lt;String&gt; visited = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有个想法：</span></span><br><span class="line">    <span class="comment">// 1、统计tag每个字符个数，统计sti每个贴纸字符个数</span></span><br><span class="line">    <span class="comment">//2、每次都拿能最大减少tag字符的贴纸</span></span><br><span class="line">    <span class="comment">// 复杂度 = O(n * m)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//贪心的思路，错咯，因为有些字符是只有一个或者极少的</span></span><br><span class="line">    <span class="comment">//因为即使贴纸a能扣减字符比贴纸b多，但贴纸b有必不可少的原始，从而应该先拿贴纸b</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minStickers0</span><span class="params">(String[] stickers, String target)</span> &#123;</span><br><span class="line">        <span class="comment">//统计tar次数</span></span><br><span class="line">        <span class="type">char</span>[] tarChar = target.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] tarCnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">totalCnt</span> <span class="operator">=</span> tarChar.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : tarChar) &#123;</span><br><span class="line">            tarCnt[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计每个贴纸字符个数</span></span><br><span class="line">        ArrayList&lt;<span class="type">int</span>[]&gt; stickCntList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(stickers.length);</span><br><span class="line">        <span class="type">int</span>[] allC = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">for</span> (String sticker : stickers) &#123;</span><br><span class="line">            <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : sticker.toCharArray()) &#123;</span><br><span class="line">                cnt[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">                allC[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            &#125;</span><br><span class="line">            stickCntList.add(cnt);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断贴纸是否每种字符都有</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : tarChar) &#123;</span><br><span class="line">            <span class="keyword">if</span> (allC[c - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxCount</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxi</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历每个贴纸，看能减少</span></span><br><span class="line">        <span class="keyword">while</span> (totalCnt &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            ans++;</span><br><span class="line">            maxCount = <span class="number">0</span>;</span><br><span class="line">            maxi = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//取能最大扣减模板字符的贴纸</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; stickCntList.size(); i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="type">int</span>[] arr = stickCntList.get(i);</span><br><span class="line">                <span class="comment">//统计每个位置能扣减多少个字符</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tarCnt[j] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                        count += Math.min(tarCnt[j], arr[j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (count &gt; maxCount)&#123;</span><br><span class="line">                    maxCount = count;</span><br><span class="line">                    maxi = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//扣减字符</span></span><br><span class="line">            <span class="type">int</span>[] arr = stickCntList.get(maxi);</span><br><span class="line">            totalCnt -= maxCount;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (tarCnt[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    tarCnt[i] -= Math.min(tarCnt[i], arr[i]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左神思路：离谱，转化为从target到空字符串！！</span></span><br><span class="line">    <span class="comment">// 用bfs，每个贴纸进行展开</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minStickers</span><span class="params">(String[] stickers, String target)</span>&#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        graph.clear();</span><br><span class="line">        visited.clear();</span><br><span class="line">        l = r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//贴纸建图</span></span><br><span class="line">        <span class="comment">//记录每个字符对应的贴纸</span></span><br><span class="line">        <span class="keyword">for</span> (String sticker : stickers) &#123;</span><br><span class="line">            sticker = sort(sticker);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : sticker.toCharArray()) &#123;</span><br><span class="line">                graph.get(c - <span class="string">&#x27;a&#x27;</span>).add(sticker);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//target入队</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tar</span> <span class="operator">=</span> sort(target);</span><br><span class="line">        queue[r++] = tar;</span><br><span class="line">        visited.add(tar);</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            level++;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> r - l;</span><br><span class="line">            <span class="comment">//逐层遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">cur</span> <span class="operator">=</span> queue[l++];</span><br><span class="line">                <span class="comment">//剪枝 -》优先消除首字符 -&gt; 找首字符对应的所有贴纸展开</span></span><br><span class="line">                <span class="keyword">for</span> (String s : graph.get(cur.charAt(<span class="number">0</span>) - <span class="string">&#x27;a&#x27;</span>)) &#123;</span><br><span class="line">                    <span class="comment">//消除贴纸后的结果</span></span><br><span class="line">                    <span class="type">String</span> <span class="variable">next</span> <span class="operator">=</span> next(s, cur);</span><br><span class="line">                    <span class="comment">//如果展开过程中得到空字符串，返回展开层数</span></span><br><span class="line">                    <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(next))&#123;</span><br><span class="line">                        <span class="keyword">return</span> level;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (!visited.contains(next))&#123;</span><br><span class="line">                        <span class="comment">//将展开结果放入队列</span></span><br><span class="line">                        visited.add(next);</span><br><span class="line">                        queue[r++] = next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//展开所有结果都没有空字符串，所以直接返回-1</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//排序字符串，好处理</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">sort</span><span class="params">(String s)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] chars = s.toCharArray();</span><br><span class="line">        Arrays.sort(chars);</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(chars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//消除t的所有s</span></span><br><span class="line">    <span class="keyword">private</span> String <span class="title function_">next</span><span class="params">(String s, String t)</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        s = sort(s);</span><br><span class="line">        t = sort(t);</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//相同就跳过，不同就添加</span></span><br><span class="line">        <span class="keyword">while</span> (r &lt; t.length())&#123;</span><br><span class="line">            <span class="comment">//s退出了</span></span><br><span class="line">            <span class="keyword">if</span> (l == s.length())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(l) &lt; t.charAt(r))&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s.charAt(l) &gt; t.charAt(r))&#123;</span><br><span class="line">                bf.append(t.charAt(r++));</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                l++;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//l先退出 且 r没到结束，继续合剩下的</span></span><br><span class="line">        <span class="keyword">if</span> (r != t.length())&#123;</span><br><span class="line">            bf.append(t.substring(r));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bf.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        LinkedList&lt;String&gt; lk = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        lk.add(<span class="string">&quot;asf&quot;</span>);</span><br><span class="line">        lk.add(<span class="string">&quot;xxx&quot;</span>);</span><br><span class="line">        lk.add(<span class="string">&quot;aaa&quot;</span>);</span><br><span class="line">        lk.add(<span class="string">&quot;fff&quot;</span>);</span><br><span class="line">        ans.add(lk);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;String&gt; list : ans) &#123;</span><br><span class="line">            list.stream().forEach(System.out::println);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 宽度优先遍历扩展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 宽度优先遍历扩展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MaxDistance</title>
      <link href="/2024/07/22/MaxDistance/"/>
      <url>/2024/07/22/MaxDistance/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.宽度优先遍历扩展;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/22 17:48</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 地图分析</span></span><br><span class="line"><span class="comment">// 你现在手里有一份大小为 n x n 的 网格 grid</span></span><br><span class="line"><span class="comment">// 上面的每个 单元格 都用 0 和 1 标记好了其中 0 代表海洋，1 代表陆地。</span></span><br><span class="line"><span class="comment">// 请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的</span></span><br><span class="line"><span class="comment">// 并返回该距离。如果网格上只有陆地或者海洋，请返回 -1。</span></span><br><span class="line"><span class="comment">// 我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：</span></span><br><span class="line"><span class="comment">// (x0, y0) 和 (x1, y1) 这两个单元格之间的距离是 |x0 - x1| + |y0 - y1| 。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/as-far-from-land-as-possible/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxDistance</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[][] queue = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN * MAIN][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span>[][] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[MAIN][MAIN];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> l, r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 0:上，1:右，2:下，3:左</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] move = <span class="keyword">new</span> <span class="title class_">int</span>[] &#123; -<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, -<span class="number">1</span> &#125;;</span><br><span class="line">    <span class="comment">//额，那就针对每一个单元格1，进行展开，直到全图为1.用个boolean 记录访问记录</span></span><br><span class="line">    <span class="comment">//宽度优先遍历.和普通的bfs不同，多个节点同时进行。二维队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDistance</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        l = r = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sea</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//初始化，获取所有陆地，从所有陆地开始遍历，返回最大的层数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    queue[r][<span class="number">0</span>] = i;</span><br><span class="line">                    queue[r++][<span class="number">1</span>] = j;</span><br><span class="line">                    visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">                    sea++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//全是海或者全是陆地</span></span><br><span class="line">        <span class="keyword">if</span> (sea == <span class="number">0</span> || sea == n - <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">level</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历所有陆地</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="comment">//当前轮要遍历的次数</span></span><br><span class="line">            <span class="comment">//注意！！！bfs是按层遍历，所以要记录当层遍历次数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> r - l;</span><br><span class="line">            level++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>, x, y; k &lt; size; k++) &#123;</span><br><span class="line">                x = queue[l][<span class="number">0</span>];</span><br><span class="line">                y = queue[l++][<span class="number">1</span>];</span><br><span class="line">                <span class="comment">//往四个方向遍历</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, nx, ny; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">                    nx = x + move[i];</span><br><span class="line">                    ny = y + move[i + <span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (nx &gt;= <span class="number">0</span> &amp;&amp; nx &lt; n &amp;&amp; ny &gt;= <span class="number">0</span> &amp;&amp; ny &lt; n &amp;&amp; !visited[nx][ny])&#123;</span><br><span class="line">                        visited[nx][ny] = <span class="literal">true</span>;</span><br><span class="line">                        queue[r][<span class="number">0</span>] = nx;</span><br><span class="line">                        queue[r++][<span class="number">1</span>] = ny;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//这个结果是包括第0层的，所以要 - 1</span></span><br><span class="line">        <span class="keyword">return</span> level - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 宽度优先遍历扩展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 宽度优先遍历扩展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BusyCities</title>
      <link href="/2024/07/22/BusyCities/"/>
      <url>/2024/07/22/BusyCities/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.最小生成树;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/22 15:45</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 繁忙的都市</span></span><br><span class="line"><span class="comment">// 一个非常繁忙的大都市，城市中的道路十分的拥挤，于是市长决定对其中的道路进行改造</span></span><br><span class="line"><span class="comment">// 城市的道路是这样分布的：城市中有n个交叉路口，有些交叉路口之间有道路相连</span></span><br><span class="line"><span class="comment">// 两个交叉路口之间最多有一条道路相连接，这些道路是双向的</span></span><br><span class="line"><span class="comment">// 且把所有的交叉路口直接或间接的连接起来了</span></span><br><span class="line"><span class="comment">// 每条道路都有一个分值，分值越小表示这个道路越繁忙，越需要进行改造</span></span><br><span class="line"><span class="comment">// 但是市政府的资金有限，市长希望进行改造的道路越少越好，于是他提出下面的要求：</span></span><br><span class="line"><span class="comment">// 1. 改造的那些道路能够把所有的交叉路口直接或间接的连通起来</span></span><br><span class="line"><span class="comment">// 2. 在满足要求1的情况下，改造的道路尽量少</span></span><br><span class="line"><span class="comment">// 3. 在满足要求1、2的情况下，改造的那些道路中分值最大的道路分值尽量小</span></span><br><span class="line"><span class="comment">// 作为市规划局的你，应当作出最佳的决策，选择哪些道路应当被修建</span></span><br><span class="line"><span class="comment">// 返回选出了几条道路 以及 分值最大的那条道路的分值是多少</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P2330</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下所有代码，把主类名改成Main，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BusyCities</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span>  <span class="number">301</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIM</span> <span class="operator">=</span>  <span class="number">8001</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span>  <span class="type">int</span>[][] edge = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM][<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据题目描述，很容易得知：</span></span><br><span class="line">    <span class="comment">//1、求最小生成树。 2、优先拿权值最小的道路</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(bf);</span><br><span class="line">        <span class="keyword">while</span> (st.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            n = (<span class="type">int</span>) st.nval;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            m = (<span class="type">int</span>) st.nval;</span><br><span class="line">            st.nextToken();</span><br><span class="line">            build();</span><br><span class="line">            <span class="comment">//建图</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                edge[i][<span class="number">0</span>] = (<span class="type">int</span>) st.nval;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                edge[i][<span class="number">1</span>] = (<span class="type">int</span>) st.nval;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                edge[i][<span class="number">2</span>] = (<span class="type">int</span>) st.nval;</span><br><span class="line">                st.nextToken();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据权值排序</span></span><br><span class="line">            Arrays.sort(edge, <span class="number">0</span>, m, (e1,e2) -&gt; e1[<span class="number">2</span>] - e2[<span class="number">2</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (union(edge[i][<span class="number">0</span>], edge[i][<span class="number">1</span>]))&#123;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    max = Math.max(max, edge[i][<span class="number">2</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//有个小细节，点处理够了就退出了</span></span><br><span class="line">                <span class="keyword">if</span>(cnt == n - <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(cnt + <span class="string">&quot; &quot;</span> + max);</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        bf.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span> <span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i != father[i])&#123;</span><br><span class="line">            father[i] = find(father[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> father[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fx</span> <span class="operator">=</span> find(x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">fy</span> <span class="operator">=</span> find(y);</span><br><span class="line">        <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">            father[fx] = fy;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 最小生成树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DistanceLimitedPathsExist0</title>
      <link href="/2024/07/22/DistanceLimitedPathsExist0/"/>
      <url>/2024/07/22/DistanceLimitedPathsExist0/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.最小生成树;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/22 15:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查边长度限制的路径是否存在</span></span><br><span class="line"><span class="comment">// 给你一个 n 个点组成的无向图边集 edgeList</span></span><br><span class="line"><span class="comment">// 其中 edgeList[i] = [ui, vi, disi] 表示点 ui 和点 vi 之间有一条长度为 disi 的边</span></span><br><span class="line"><span class="comment">// 请注意，两个点之间可能有 超过一条边 。</span></span><br><span class="line"><span class="comment">// 给你一个查询数组queries ，其中 queries[j] = [pj, qj, limitj]</span></span><br><span class="line"><span class="comment">// 你的任务是对于每个查询 queries[j] ，判断是否存在从 pj 到 qj 的路径</span></span><br><span class="line"><span class="comment">// 且这条路径上的每一条边都 严格小于 limitj 。</span></span><br><span class="line"><span class="comment">// 请你返回一个 布尔数组 answer ，其中 answer.length == queries.length</span></span><br><span class="line"><span class="comment">// 当 queries[j] 的查询结果为 true 时， answer 第 j 个值为 true ，否则为 false</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/checking-existence-of-edge-length-limited-paths/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DistanceLimitedPathsExist0</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] father =  <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//题目说 且这条路径上的 “每一条边”都 严格小于 limitj</span></span><br><span class="line">    <span class="comment">//即两点间的每一条边的权值都拿最小去判断是否小于limitj</span></span><br><span class="line">    <span class="comment">//很明显最小生成树</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//思路错了，原本想着用数组保存路径上的最大值，后面发现很难实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span>[] distanceLimitedPathsExist0(<span class="type">int</span> n, <span class="type">int</span>[][] edgeList, <span class="type">int</span>[][] queries) &#123;</span><br><span class="line">        N = n;</span><br><span class="line">        build();</span><br><span class="line">        <span class="type">int</span>[][] power = <span class="keyword">new</span> <span class="title class_">int</span>[N][N];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成最小生成树，并保存路径中最大权值</span></span><br><span class="line">        Arrays.sort(edgeList, (a, b) -&gt; a[<span class="number">2</span>] - b[<span class="number">2</span>]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edgeList) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (union(from, to))&#123;</span><br><span class="line">                <span class="comment">//保存两点间的最大权值</span></span><br><span class="line">                <span class="comment">//此时的权值就是两点间的最小权值</span></span><br><span class="line">                power[from][to] = edge[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最大值数组</span></span><br><span class="line">        <span class="comment">//比较每行最大值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; N; j++) &#123;</span><br><span class="line">                power[i][j] = Math.max(power[i][j - <span class="number">1</span>], power[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历queries，判断两点间是否同一集合，判断路径最大权值是否符合</span></span><br><span class="line">        <span class="type">boolean</span>[] ans = <span class="keyword">new</span> <span class="title class_">boolean</span>[queries.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; queries.length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> queries[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> queries[i][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> queries[i][<span class="number">2</span>];</span><br><span class="line">            ans[i] = isSameSet(from, to) &amp;&amp; power[from][to] &lt; limit;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//参考左神思路: 针对每一个问题，去联合所有符合条件的边</span></span><br><span class="line">    <span class="comment">//从最小问题开始</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span>[] distanceLimitedPathsExist(<span class="type">int</span> n, <span class="type">int</span>[][] edgeList, <span class="type">int</span>[][] queries) &#123;</span><br><span class="line">        N = n;</span><br><span class="line">        build();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> queries.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> edgeList.length;</span><br><span class="line">        <span class="comment">//把问题加上索引</span></span><br><span class="line">        <span class="type">int</span>[][] questions = <span class="keyword">new</span> <span class="title class_">int</span>[m][<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            questions[i][<span class="number">0</span>] = queries[i][<span class="number">0</span>];</span><br><span class="line">            questions[i][<span class="number">1</span>] = queries[i][<span class="number">1</span>];</span><br><span class="line">            questions[i][<span class="number">2</span>] = queries[i][<span class="number">2</span>];</span><br><span class="line">            questions[i][<span class="number">3</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//排序问题</span></span><br><span class="line">        Arrays.sort(questions, (a,b) -&gt; a[<span class="number">2</span>] - b[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//排序权值</span></span><br><span class="line">        Arrays.sort(edgeList, (a, b) -&gt; a[<span class="number">2</span>] - b[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历每个问题</span></span><br><span class="line">        <span class="type">boolean</span>[] ans = <span class="keyword">new</span> <span class="title class_">boolean</span>[queries.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="comment">//j是不可回退的</span></span><br><span class="line">            <span class="comment">//直接比对问题权值和 边权值</span></span><br><span class="line">            <span class="keyword">for</span> (; j &lt; k &amp;&amp; edgeList[j][<span class="number">2</span>] &lt; questions[i][<span class="number">2</span>]; j++) &#123;</span><br><span class="line">                union(edgeList[j][<span class="number">0</span>], edgeList[j][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            ans[questions[i][<span class="number">3</span>]] = isSameSet(questions[i][<span class="number">0</span>], questions[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i != father[i])&#123;</span><br><span class="line">            father[i] = find(father[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> father[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fx</span> <span class="operator">=</span> find(x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">fy</span> <span class="operator">=</span> find(y);</span><br><span class="line">        <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">            father[fx] = fy;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSameSet</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(x) == find(y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 最小生成树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>OptimizeWaterDistribution</title>
      <link href="/2024/07/19/OptimizeWaterDistribution/"/>
      <url>/2024/07/19/OptimizeWaterDistribution/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.最小生成树;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/19 10:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 水资源分配优化</span></span><br><span class="line"><span class="comment">// 村里面一共有 n 栋房子。我们希望通过建造水井和铺设管道来为所有房子供水。</span></span><br><span class="line"><span class="comment">// 对于每个房子 i，我们有两种可选的供水方案：一种是直接在房子内建造水井</span></span><br><span class="line"><span class="comment">// 成本为 wells[i - 1] （注意 -1 ，因为 索引从0开始 ）</span></span><br><span class="line"><span class="comment">// 另一种是从另一口井铺设管道引水，数组 pipes 给出了在房子间铺设管道的成本，</span></span><br><span class="line"><span class="comment">// 其中每个 pipes[j] = [house1j, house2j, costj]</span></span><br><span class="line"><span class="comment">// 代表用管道将 house1j 和 house2j连接在一起的成本。连接是双向的。</span></span><br><span class="line"><span class="comment">// 请返回 为所有房子都供水的最低总成本</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/optimize-water-distribution-in-a-village/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OptimizeWaterDistribution</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">10010</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把房间内建水，也当成房子间引水，直接对每个房子也建路径</span></span><br><span class="line">    <span class="comment">//虚拟出一个0节点，所有房子内建水都当成从0过去</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minCostToSupplyWater</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] wells, <span class="type">int</span>[][] pipes)</span>&#123;</span><br><span class="line">        <span class="comment">//房子最大编号 (虚拟房编号为0）</span></span><br><span class="line">        N = n;</span><br><span class="line">        <span class="comment">//总路径数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> pipes.length + wells.length;</span><br><span class="line">        bulid();</span><br><span class="line">        <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[len][<span class="number">3</span>];</span><br><span class="line">        <span class="comment">//原本路径</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; pipes.length; i++) &#123;</span><br><span class="line">            arr[i] = pipes[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数组索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> pipes.length;</span><br><span class="line">        <span class="comment">//新增房子的开始编号</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= wells.length; i++, index++) &#123;</span><br><span class="line">            <span class="comment">//都设置为从0编号出发</span></span><br><span class="line">            arr[index] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>, i, wells[i - <span class="number">1</span>]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按权值排序</span></span><br><span class="line">        Arrays.sort(arr, (a1,a2) -&gt; a1[<span class="number">2</span>] - a2[<span class="number">2</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (union(arr[i][<span class="number">0</span>], arr[i][<span class="number">1</span>]))&#123;</span><br><span class="line">                ans += arr[i][<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">bulid</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i != father[i])&#123;</span><br><span class="line">            father[i] = find(father[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> father[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fx</span> <span class="operator">=</span> find(x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">fy</span> <span class="operator">=</span> find(y);</span><br><span class="line">        <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">            father[fx] = fy;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 最小生成树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PrimDynamic</title>
      <link href="/2024/07/19/PrimDynamic/"/>
      <url>/2024/07/19/PrimDynamic/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.最小生成树;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/19 10:25</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Prim算法模版（洛谷）</span></span><br><span class="line"><span class="comment">// 动态空间实现</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P3366</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下所有代码，把主类名改成Main，可以直接通过</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//利用小根堆，一个个加进堆里</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PrimDynamic</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            ArrayList&lt;ArrayList&lt;<span class="type">int</span>[]&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">int</span>) in.nval;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            in.nextToken();</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (<span class="type">int</span>) in.nval;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, u, v, w; i &lt; m; i++) &#123;</span><br><span class="line">                in.nextToken();</span><br><span class="line">                u = (<span class="type">int</span>) in.nval;</span><br><span class="line">                in.nextToken();</span><br><span class="line">                v = (<span class="type">int</span>) in.nval;</span><br><span class="line">                in.nextToken();</span><br><span class="line">                w = (<span class="type">int</span>) in.nval;</span><br><span class="line">                graph.get(u).add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;v, w&#125;);</span><br><span class="line">                graph.get(v).add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;u, w&#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//加入首个节点入堆</span></span><br><span class="line">            <span class="comment">//按权值排序</span></span><br><span class="line">            PriorityQueue&lt;<span class="type">int</span>[]&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; a[<span class="number">1</span>] - b[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] edge : graph.get(<span class="number">1</span>)) &#123;</span><br><span class="line">                heap.add(edge);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n + <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//把前面处理的1节点加上</span></span><br><span class="line">            visited[<span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!heap.isEmpty()) &#123;</span><br><span class="line">                <span class="type">int</span>[] edge = heap.poll();</span><br><span class="line">                <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> edge[<span class="number">0</span>];</span><br><span class="line">                <span class="type">int</span> <span class="variable">cost</span> <span class="operator">=</span> edge[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (!visited[next])&#123;</span><br><span class="line">                    size++;</span><br><span class="line">                    ans += cost;</span><br><span class="line">                    visited[next] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span>[] e : graph.get(next)) &#123;</span><br><span class="line">                        heap.add(e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(size == n ? ans : <span class="string">&quot;orz&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 最小生成树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kruskal</title>
      <link href="/2024/07/18/Kruskal/"/>
      <url>/2024/07/18/Kruskal/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.最小生成树;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 最小生成树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/18 17:39</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Kruskal算法模版（洛谷）</span></span><br><span class="line"><span class="comment">// 静态空间实现</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P3366</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下所有代码，把主类名改成Main，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Kruskal</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">5001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXM</span> <span class="operator">=</span> <span class="number">200001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// u, v, w</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] edges = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM][<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> N, M;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(bf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//最小生成树算法，用并查集联合，权值排序</span></span><br><span class="line">        <span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF)&#123;</span><br><span class="line">            N = (<span class="type">int</span>) in.nval;</span><br><span class="line">            in.nextToken();</span><br><span class="line">            M = (<span class="type">int</span>) in.nval;</span><br><span class="line">            build();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">                in.nextToken();</span><br><span class="line">                edges[i][<span class="number">0</span>] = (<span class="type">int</span>) in.nval;</span><br><span class="line">                in.nextToken();</span><br><span class="line">                edges[i][<span class="number">1</span>] = (<span class="type">int</span>) in.nval;</span><br><span class="line">                in.nextToken();</span><br><span class="line">                edges[i][<span class="number">2</span>] = (<span class="type">int</span>) in.nval;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Arrays.sort(edges,<span class="number">0</span>, M, (e1,e2) -&gt; e1[<span class="number">2</span>] - e2[<span class="number">2</span>]);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] e : edges) &#123;</span><br><span class="line">                <span class="keyword">if</span> (union(e[<span class="number">0</span>], e[<span class="number">1</span>])) &#123;</span><br><span class="line">                    ans += e[<span class="number">2</span>];</span><br><span class="line">                    size++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//处理的边是否等于点数量 - 1</span></span><br><span class="line">            out.println(size == N - <span class="number">1</span> ? ans : <span class="string">&quot;orz&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        bf.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i != father[i])&#123;</span><br><span class="line">            father[i] = find(father[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> father[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fx</span> <span class="operator">=</span> find(x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">fy</span> <span class="operator">=</span> find(y);</span><br><span class="line">        <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">            father[fx] = fy;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 最小生成树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MaximumInvitations</title>
      <link href="/2024/07/18/MaximumInvitations/"/>
      <url>/2024/07/18/MaximumInvitations/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.拓扑排序扩展;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 根据测试数据画图才可能想出来的算法···</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/18 17:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参加会议的最多员工数</span></span><br><span class="line"><span class="comment">// 一个公司准备组织一场会议，邀请名单上有 n 位员工</span></span><br><span class="line"><span class="comment">// 公司准备了一张 圆形 的桌子，可以坐下 任意数目 的员工</span></span><br><span class="line"><span class="comment">// 员工编号为 0 到 n - 1 。每位员工都有一位 喜欢 的员工</span></span><br><span class="line"><span class="comment">// 每位员工 当且仅当 他被安排在喜欢员工的旁边，他才会参加会议</span></span><br><span class="line"><span class="comment">// 每位员工喜欢的员工 不会 是他自己。给你一个下标从 0 开始的整数数组 favorite</span></span><br><span class="line"><span class="comment">// 其中 favorite[i] 表示第 i 位员工喜欢的员工。请你返回参加会议的 最多员工数目</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/maximum-employees-to-be-invited-to-a-meeting/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaximumInvitations</span> &#123;</span><br><span class="line">    <span class="comment">//根据左神思路写的：</span></span><br><span class="line">    <span class="comment">//根据题意，肯定有环（每个员工都有一个喜欢的员工，且不是自己）,可能有多个环同时存在，返回最多参会的环</span></span><br><span class="line">    <span class="comment">//结论：</span></span><br><span class="line">    <span class="comment">// 1、当环内员工大于2个时，参加会议的员工只能是环内（因为此时所有环内员工已经放不下其他员工了，环内都是必须的被喜欢的员工）</span></span><br><span class="line">    <span class="comment">// 2、当环内员工小于等于2个时，参与会议的员工可以是环内员工连接的各个节点</span></span><br><span class="line">    <span class="comment">// 总结: 2个以上的环 只能做一桌，2个的环能一起坐同一桌</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//入坑了，没想到有许多个2的环同时存在的情况，这时候不好统计为环的节点</span></span><br><span class="line">    <span class="comment">//求解思路错了！！！！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumInvitations0</span><span class="params">(<span class="type">int</span>[] favorite)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> favorite.length;</span><br><span class="line">        <span class="comment">//获取环内节点</span></span><br><span class="line">        <span class="comment">//获取入度</span></span><br><span class="line">        <span class="type">int</span>[] indegree = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fav : favorite) &#123;</span><br><span class="line">            indegree[fav]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取所有入度大于等于2的环内节点</span></span><br><span class="line">        <span class="type">int</span>[] queue = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//获取所有入度为0的节点</span></span><br><span class="line">        <span class="type">int</span>[] queue0 = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">l0</span> <span class="operator">=</span> <span class="number">0</span>, r0 = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; indegree.length; i++) &#123;</span><br><span class="line">            <span class="comment">//可能只有环内节点的情况</span></span><br><span class="line">            <span class="keyword">if</span> (indegree[i] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                queue[r++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue0[r0++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// deep[i] : 不包括i在内，i之前的最长链的长度</span></span><br><span class="line">        <span class="comment">//从入度为0的节点开始遍历</span></span><br><span class="line">        <span class="comment">//类似前缀和</span></span><br><span class="line">        <span class="type">int</span>[] deep = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">while</span> (l0 &lt; r0) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> queue0[l0++];</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> favorite[cur];</span><br><span class="line">            deep[next] = Math.max(deep[next], deep[cur] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (--indegree[next] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue0[r0++] = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans3</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//环内3个及以上</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//环内等于2</span></span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> queue[l++];</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//判断环内节点个数</span></span><br><span class="line">            <span class="keyword">while</span> (!visited[cur])&#123;</span><br><span class="line">                visited[cur] = <span class="literal">true</span>;</span><br><span class="line">                cnt++;</span><br><span class="line">                cur = favorite[cur];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//根据环内个数求解参会人数</span></span><br><span class="line">            <span class="comment">//只能坐一桌</span></span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; <span class="number">2</span>)&#123;</span><br><span class="line">                <span class="comment">//2个以上的环，参会人员只能是环内人员</span></span><br><span class="line"><span class="comment">//                ans = Math.max(ans, cnt);</span></span><br><span class="line">                ans3 = Math.max(ans3, cnt);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">2</span>)&#123;<span class="comment">//能同时做几个2环的</span></span><br><span class="line">                <span class="comment">//要加上两个环内节点连接的其他成员</span></span><br><span class="line"><span class="comment">//                ans = Math.max(ans, cnt + deep[cur] + deep[favorite[cur]]);</span></span><br><span class="line">                ans2 += cnt + deep[cur] + deep[favorite[cur]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r &gt; <span class="number">0</span> ?  Math.max(ans2, ans3) : n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//先消除环外节点，再来统计环节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximumInvitations</span><span class="params">(<span class="type">int</span>[] favorite)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> favorite.length;</span><br><span class="line">        <span class="comment">//获取环内节点</span></span><br><span class="line">        <span class="comment">//获取入度</span></span><br><span class="line">        <span class="type">int</span>[] indegree = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> fav : favorite) &#123;</span><br><span class="line">            indegree[fav]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取所有入度大于等于2的环内节点</span></span><br><span class="line">        <span class="type">int</span>[] queue = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; indegree.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue[r++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//消除环外节点，并统计入环前的节点数量</span></span><br><span class="line">        <span class="comment">// deep[i] : 不包括i在内，i之前的最长链的长度</span></span><br><span class="line">        <span class="comment">//从入度为0的节点开始遍历</span></span><br><span class="line">        <span class="comment">//类似前缀和</span></span><br><span class="line">        <span class="type">int</span>[] deep = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> queue[l++];</span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> favorite[cur];</span><br><span class="line">            deep[next] = Math.max(deep[next], deep[cur] + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (--indegree[next] == <span class="number">0</span>) &#123;</span><br><span class="line">                queue[r++] = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> findMax2(favorite, indegree, deep, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原思路上参考左神思路写的遍历</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findMax</span><span class="params">(<span class="type">int</span>[] favorite, <span class="type">int</span>[] indegree, <span class="type">int</span>[] deep, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="comment">//遍历所有环节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans3</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//环内3个及以上</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//环内等于2</span></span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegree[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> favorite[i];</span><br><span class="line">                <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//判断环内节点个数</span></span><br><span class="line">                <span class="keyword">while</span> (!visited[cur])&#123;</span><br><span class="line">                    visited[cur] = <span class="literal">true</span>;</span><br><span class="line">                    cnt++;</span><br><span class="line">                    cur = favorite[cur];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//根据环内个数求解参会人数</span></span><br><span class="line">                <span class="comment">//只能坐一桌</span></span><br><span class="line">                <span class="keyword">if</span> (cnt &gt; <span class="number">2</span>)&#123;</span><br><span class="line">                    <span class="comment">//2个以上的环，参会人员只能是环内人员</span></span><br><span class="line">                    ans3 = Math.max(ans3, cnt);</span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(cnt == <span class="number">2</span>)&#123;<span class="comment">//能同时做几个2环的</span></span><br><span class="line">                    <span class="comment">//要加上两个环内节点连接的其他成员</span></span><br><span class="line">                    ans2 += cnt + deep[cur] + deep[favorite[cur]];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(ans2, ans3);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左神思路代码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">findMax2</span><span class="params">(<span class="type">int</span>[] favorite, <span class="type">int</span>[] indegree, <span class="type">int</span>[] deep, <span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="comment">// 目前图中的点，不在环上的点，都删除了！ indegree[i] == 0</span></span><br><span class="line">        <span class="comment">// 可能性1 : 所有小环(中心个数 == 2)，算上中心点 + 延伸点，总个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sumOfSmallRings</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 可能性2 : 所有大环(中心个数 &gt; 2)，只算中心点，最大环的中心点个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">bigRings</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">// 只关心的环！</span></span><br><span class="line">            <span class="keyword">if</span> (indegree[i] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ringSize</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">                indegree[i] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> favorite[i]; j != i; j = favorite[j]) &#123;</span><br><span class="line">                    ringSize++;</span><br><span class="line">                    indegree[j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ringSize == <span class="number">2</span>) &#123;</span><br><span class="line">                    sumOfSmallRings += <span class="number">2</span> + deep[i] + deep[favorite[i]];</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    bigRings = Math.max(bigRings, ringSize);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(sumOfSmallRings, bigRings);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 拓扑排序扩展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓扑排序扩展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinimumTime</title>
      <link href="/2024/07/18/MinimumTime/"/>
      <url>/2024/07/18/MinimumTime/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.拓扑排序扩展;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/18 15:33</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并行课程 III</span></span><br><span class="line"><span class="comment">// 给你一个整数 n ，表示有 n 节课，课程编号从 1 到 n</span></span><br><span class="line"><span class="comment">// 同时给你一个二维整数数组 relations ，</span></span><br><span class="line"><span class="comment">// 其中 relations[j] = [prevCoursej, nextCoursej]</span></span><br><span class="line"><span class="comment">// 表示课程 prevCoursej 必须在课程 nextCoursej 之前 完成（先修课的关系）</span></span><br><span class="line"><span class="comment">// 同时给你一个下标从 0 开始的整数数组 time</span></span><br><span class="line"><span class="comment">// 其中 time[i] 表示完成第 (i+1) 门课程需要花费的 月份 数。</span></span><br><span class="line"><span class="comment">// 请你根据以下规则算出完成所有课程所需要的 最少 月份数：</span></span><br><span class="line"><span class="comment">// 如果一门课的所有先修课都已经完成，你可以在 任意 时间开始这门课程。</span></span><br><span class="line"><span class="comment">// 你可以 同时 上 任意门课程 。请你返回完成所有课程所需要的 最少 月份数。</span></span><br><span class="line"><span class="comment">// 注意：测试数据保证一定可以完成所有课程（也就是先修课的关系构成一个有向无环图）</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/parallel-courses-iii/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinimumTime</span> &#123;</span><br><span class="line">    <span class="comment">//拓扑排序，传递最大指到下一节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minimumTime</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] relations, <span class="type">int</span>[] time)</span> &#123;</span><br><span class="line">        <span class="comment">//用数组保存每个节点的前置课程花销的最大时间</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//建图</span></span><br><span class="line">        <span class="type">int</span>[] indegree = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] relation : relations) &#123;</span><br><span class="line">            graph.get(relation[<span class="number">0</span>]).add(relation[<span class="number">1</span>]);</span><br><span class="line">            indegree[relation[<span class="number">1</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] queue = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//注意下标从1开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; indegree.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue[r++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//保存每个节点花销时间</span></span><br><span class="line">        <span class="type">int</span>[] cost = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="comment">//        while (l &lt; r) &#123;</span></span><br><span class="line"><span class="comment">//            int cur = queue[l++];</span></span><br><span class="line"><span class="comment">//            if (graph.get(cur).isEmpty())&#123;</span></span><br><span class="line"><span class="comment">//                ans = Math.max(ans, cost[cur - 1] + time[cur - 1]);</span></span><br><span class="line"><span class="comment">//            &#125;else &#123;</span></span><br><span class="line"><span class="comment">//                for (int next : graph.get(cur)) &#123;</span></span><br><span class="line"><span class="comment">//                    if (--indegree[next] == 0)&#123;</span></span><br><span class="line"><span class="comment">//                        queue[r++] = next;</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line"><span class="comment">//                    //下一课程的花费只要前面最大花费的课程</span></span><br><span class="line"><span class="comment">//                    //这里记得要加上cost[cur - 1]，不然会丢失当前时间</span></span><br><span class="line"><span class="comment">//                    cost[next - 1] = Math.max(time[cur - 1] + cost[cur - 1], cost[next - 1]);</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//上面是先计算前面最大cost再加上当前time  上面是自己的原始思路，一开始next比对时没有加上cost[cur - 1]</span></span><br><span class="line">        <span class="comment">//下面是看了左神后的改进。上下都能通过测试，下面更简洁</span></span><br><span class="line">        <span class="comment">//这里是先加上当前time，再去对比next</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> queue[l++];</span><br><span class="line">            <span class="comment">//当次耗时</span></span><br><span class="line">            cost[cur - <span class="number">1</span>] += time[cur - <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (graph.get(cur).isEmpty()) &#123;</span><br><span class="line">                <span class="comment">//这里不用+= 是因为只需要求一条完整路径的值即可</span></span><br><span class="line">                <span class="comment">//若用+=则代表要求所有完整路径的值</span></span><br><span class="line">                <span class="comment">//这里用max是因为要确保完成所有课程，只能取多条路径下的最大值</span></span><br><span class="line">                <span class="comment">//而且题目规定了肯定有一条完整路径</span></span><br><span class="line">                <span class="comment">//多条路径的情况：多个不连通的 待完成的课程</span></span><br><span class="line">                ans = Math.max(ans, cost[cur - <span class="number">1</span>]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> next : graph.get(cur)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (--indegree[next] == <span class="number">0</span>) &#123;</span><br><span class="line">                        queue[r++] = next;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//下一课程的花费只要前面最大花费的课程</span></span><br><span class="line">                    cost[next - <span class="number">1</span>] = Math.max(cost[cur - <span class="number">1</span>], cost[next - <span class="number">1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 拓扑排序扩展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓扑排序扩展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LoudAndRich</title>
      <link href="/2024/07/18/LoudAndRich/"/>
      <url>/2024/07/18/LoudAndRich/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.拓扑排序扩展;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>  拓扑排序拓展运用题，链路传递信息</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/18 12:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 喧闹和富有</span></span><br><span class="line"><span class="comment">// 从 0 到 n - 1 编号，其中每个人都有不同数目的钱，以及不同程度的安静值</span></span><br><span class="line"><span class="comment">// 给你一个数组richer，其中richer[i] = [ai, bi] 表示</span></span><br><span class="line"><span class="comment">// person ai 比 person bi 更有钱</span></span><br><span class="line"><span class="comment">// 还有一个整数数组 quiet ，其中 quiet[i] 是 person i 的安静值</span></span><br><span class="line"><span class="comment">// richer 中所给出的数据 逻辑自洽</span></span><br><span class="line"><span class="comment">// 也就是说，在 person x 比 person y 更有钱的同时，不会出现</span></span><br><span class="line"><span class="comment">// person y 比 person x 更有钱的情况</span></span><br><span class="line"><span class="comment">// 现在，返回一个整数数组 answer 作为答案，其中 answer[x] = y 的前提是,</span></span><br><span class="line"><span class="comment">// 在所有拥有的钱肯定不少于 person x 的人中，</span></span><br><span class="line"><span class="comment">// person y 是最安静的人（也就是安静值 quiet[y] 最小的人）。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/loud-and-rich/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LoudAndRich</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//边的数量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIM</span> <span class="operator">=</span> <span class="number">500</span> * <span class="number">500</span> / <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//链式前向星建图</span></span><br><span class="line">    <span class="comment">//点对应的头部边</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] head = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line">    <span class="comment">//下一条边</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line">    <span class="comment">//边去往的点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] to = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] input = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] queue = <span class="keyword">new</span> <span class="title class_">int</span>[MAIM];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> l,r, cnt;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//求比他有钱 且最不安静的人的答案</span></span><br><span class="line">    <span class="comment">//拓扑排序，一条路径上来，每个点带上此前最不安静的人</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] loudAndRich(<span class="type">int</span>[][] richer, <span class="type">int</span>[] quiet) &#123;</span><br><span class="line">        <span class="comment">//点的数量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> quiet.length;</span><br><span class="line">        build(n);</span><br><span class="line">        <span class="comment">//建图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] arr : richer) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> arr[<span class="number">0</span>];<span class="comment">//更有钱</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> arr[<span class="number">1</span>];</span><br><span class="line">            addEdge(x, y);</span><br><span class="line">            <span class="comment">//节点入度</span></span><br><span class="line">            input[y]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有入度为0的点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (input[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue[r++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拓扑排序</span></span><br><span class="line">        <span class="comment">//答案要求返回的是点，而不是安静值</span></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> queue[l++];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">ei</span> <span class="operator">=</span> head[cur], nP; ei &gt; <span class="number">0</span>; ei = next[ei]) &#123;</span><br><span class="line">                nP  = to[ei];<span class="comment">//当前边去往的点</span></span><br><span class="line">                <span class="comment">//入度--</span></span><br><span class="line">                <span class="keyword">if</span> (--input[nP] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue[r++] = nP;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果下一点的安静值 大于当前点 更新下一点答案</span></span><br><span class="line">                <span class="keyword">if</span> (quiet[ans[nP]] &gt; quiet[ans[cur]])&#123;</span><br><span class="line">                    ans[nP] = ans[cur];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        Arrays.fill(head, <span class="number">0</span>, n, <span class="number">0</span>);</span><br><span class="line">        Arrays.fill(input, <span class="number">0</span>, n, <span class="number">0</span>);</span><br><span class="line">        l = r = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="comment">//当前边去往的点</span></span><br><span class="line">        to[cnt] = y;</span><br><span class="line">        <span class="comment">//当前边去往的下一条边</span></span><br><span class="line">        next[cnt] = head[x];</span><br><span class="line">        <span class="comment">//更新当前点的头部边</span></span><br><span class="line">        head[x] = cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] rich = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="type">int</span>[] quiet = &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>&#125;;</span><br><span class="line">        <span class="type">LoudAndRich</span> <span class="variable">loudAndRich</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LoudAndRich</span>();</span><br><span class="line">        <span class="type">int</span>[] arr = loudAndRich.loudAndRich(rich, quiet);</span><br><span class="line">        System.out.println(Arrays.stream(arr).toArray());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 拓扑排序扩展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓扑排序扩展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FoodLines</title>
      <link href="/2024/07/17/FoodLines/"/>
      <url>/2024/07/17/FoodLines/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.拓扑排序扩展;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 看原题目硬是没看懂，总结出来就是从最弱到最强动物，有多少条路走</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/17 17:30</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大食物链计数</span></span><br><span class="line"><span class="comment">// a -&gt; b，代表a在食物链中被b捕食</span></span><br><span class="line"><span class="comment">// 给定一个有向无环图，返回</span></span><br><span class="line"><span class="comment">// 这个图中从最初级动物到最顶级捕食者的食物链有几条</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P4017</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下所有代码，把主类名改成Main，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FoodLines</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> n, m;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">80112002</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//拓扑排序 消除入度时，将自身节点信息带给下一节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">in</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(bf);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF)&#123;</span><br><span class="line">            n = (<span class="type">int</span>) in.nval;</span><br><span class="line">            in.nextToken();</span><br><span class="line">            m = (<span class="type">int</span>) in.nval;</span><br><span class="line">            <span class="type">int</span>[] input = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">            ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">//初始化图</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//建图</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, x, y; i &lt; m; i++) &#123;</span><br><span class="line">                in.nextToken();</span><br><span class="line">                x = (<span class="type">int</span>) in.nval;</span><br><span class="line">                in.nextToken();</span><br><span class="line">                y = (<span class="type">int</span>) in.nval;</span><br><span class="line">                graph.get(x).add(y);</span><br><span class="line">                input[y]++;</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(findLines(graph, input));</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        bf.close();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findLines</span><span class="params">( ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph, <span class="type">int</span>[] input)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//找出所有入度为0的节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] queue = <span class="keyword">new</span> <span class="title class_">int</span>[input.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; input.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (input[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue[r++] = i;</span><br><span class="line">                <span class="comment">//初始路径</span></span><br><span class="line">                cnt[i]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> queue[l++];</span><br><span class="line">            <span class="comment">//出度为0的路径</span></span><br><span class="line">            <span class="comment">//每次到达出度为0时，才是一条完整的路径，统计答案</span></span><br><span class="line">            <span class="keyword">if</span> (graph.get(cur).isEmpty())&#123;</span><br><span class="line">                ans = (ans + cnt[cur]) % MOD;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> next : graph.get(cur)) &#123;</span><br><span class="line">                    <span class="comment">//加上之前能到达的路径条数</span></span><br><span class="line">                    cnt[next] = (cnt[next] + cnt[cur]) % MOD;</span><br><span class="line">                    <span class="keyword">if</span> (--input[next] == <span class="number">0</span>)&#123;</span><br><span class="line">                        queue[r++] = next;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最后到达的点</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 拓扑排序扩展 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓扑排序扩展 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MovesToStamp</title>
      <link href="/2024/07/15/MovesToStamp/"/>
      <url>/2024/07/15/MovesToStamp/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.拓扑排序;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>  很难想啊</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/15 17:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 戳印序列</span></span><br><span class="line"><span class="comment">// 你想最终得到&quot;abcbc&quot;，认为初始序列为&quot;?????&quot;。印章是&quot;abc&quot;</span></span><br><span class="line"><span class="comment">// 那么可以先用印章盖出&quot;??abc&quot;的状态，</span></span><br><span class="line"><span class="comment">// 然后用印章最左字符和序列的0位置对齐，就盖出了&quot;abcbc&quot;</span></span><br><span class="line"><span class="comment">// 这个过程中，&quot;??abc&quot;中的a字符，被印章中的c字符覆盖了</span></span><br><span class="line"><span class="comment">// 每次盖章的时候，印章必须完全盖在序列内</span></span><br><span class="line"><span class="comment">// 给定一个字符串target是最终的目标，长度为n，认为初始序列为n个&#x27;?&#x27;</span></span><br><span class="line"><span class="comment">// 给定一个印章字符串stamp，目标是最终盖出target</span></span><br><span class="line"><span class="comment">// 但是印章的使用次数必须在10*n次以内</span></span><br><span class="line"><span class="comment">// 返回一个数组，该数组由每个回合中被印下的最左边字母的索引组成</span></span><br><span class="line"><span class="comment">// 上面的例子返回[2,0]，表示印章最左字符依次和序列2位置、序列0位置对齐盖下去，就得到了target</span></span><br><span class="line"><span class="comment">// 如果不能在10*n次内印出序列，就返回一个空数组</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/stamping-the-sequence/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MovesToStamp</span> &#123;</span><br><span class="line">    <span class="comment">//想法：倒推，遍历每个字母，当前字母出发，以a开始，若被覆盖，则入度+1,否则入度为0</span></span><br><span class="line">    <span class="comment">//从0入度下标开始，拓扑排序</span></span><br><span class="line">    <span class="comment">//难点在于当入度为0排除后，怎么使得其他入度--呢？</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//思路错了！！！！！！ 错在入度赋值上。 当不同时赋值1并且能被其他入度为0的变为 入度0，这一步错了，不能保证1变为0的每个位置都能有相应作用</span></span><br><span class="line">    <span class="comment">//所以要知道哪些位置是有作用的，就要一个个对比字符，将错误的位置建图（其实就相当于用容器记录错误的 位置）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] movesToStamp0(String stamp, String target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> target.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> stamp.length();</span><br><span class="line">        <span class="comment">//初始化入度</span></span><br><span class="line">        <span class="type">int</span>[] input = <span class="keyword">new</span> <span class="title class_">int</span>[n - m + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> input.length;</span><br><span class="line"><span class="comment">//        Arrays.fill(input, -1);</span></span><br><span class="line">        <span class="comment">//遍历每个字母，对比stamp是否相同，不相同则赋值1，相同赋值0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!target.substring(i,  i + m).equals(stamp))&#123;</span><br><span class="line">                input[i] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历所有入度为0</span></span><br><span class="line">        <span class="type">int</span>[] queue =  <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (input[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue[r++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同一个位置取消错误不要重复统计</span></span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] stack = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> queue[l++];</span><br><span class="line">            <span class="comment">//保存答案</span></span><br><span class="line">            stack[size++] = cur;</span><br><span class="line">            visited[cur] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">//回复数组相邻的坐标，并入度为0的入队</span></span><br><span class="line">            <span class="comment">//当前坐标涉及的印章长度范围</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> cur - m + <span class="number">1</span> &lt; <span class="number">0</span> ? <span class="number">0</span> : cur - m + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> cur + m - <span class="number">1</span> &gt;= len ? len - <span class="number">1</span> : cur + m - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">                <span class="keyword">if</span> (--input[left] == <span class="number">0</span> &amp;&amp; visited[left] == <span class="literal">false</span>)&#123;</span><br><span class="line">                    input[r++] = left;</span><br><span class="line">                    visited[left]= <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (size != r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ans.length; i++) &#123;</span><br><span class="line">            ans[i] = stack[--size];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//修改后的思路，将错误位置建图，只将错误位置变为入度1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] movesToStamp(String stamp, String target) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> target.length();</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> stamp.length();</span><br><span class="line">        <span class="comment">//初始化入度</span></span><br><span class="line">        <span class="type">int</span>[] input = <span class="keyword">new</span> <span class="title class_">int</span>[n - m + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> input.length;</span><br><span class="line">        <span class="comment">//每个开头位置 对应的入度都是满的</span></span><br><span class="line">        Arrays.fill(input, m);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//初始化图  记录错误的位置对应的开头的位置   错误位置恢复时，开头位置入度--</span></span><br><span class="line">        ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历所有入度为0</span></span><br><span class="line">        <span class="type">int</span>[] queue =  <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历每个字母，对比stamp是否相同，</span></span><br><span class="line">        <span class="comment">// 相同则对应的开头位置入度--，  不相同则记录错误位置对应的开头位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;<span class="comment">//target开头位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;<span class="comment">//stamp每个位置</span></span><br><span class="line">                <span class="keyword">if</span> (target.charAt(i + j) == stamp.charAt(j))&#123;</span><br><span class="line">                    <span class="comment">//入度减少的同时判断是否能入队</span></span><br><span class="line">                    <span class="keyword">if</span> (--input[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                        queue[r++] = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//记录错误位置对应的开头位置</span></span><br><span class="line">                    graph.get(i + j).add(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 同一个位置取消错误不要重复统计</span></span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[n];</span><br><span class="line">        <span class="type">int</span>[] stack = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> queue[l++];</span><br><span class="line">            <span class="comment">//保存答案</span></span><br><span class="line">            stack[size++] = cur;</span><br><span class="line">            <span class="comment">//当前开头位置对应所有字符的位置</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!visited[cur + i])&#123;</span><br><span class="line">                    visited[cur + i] = <span class="literal">true</span>;</span><br><span class="line">                    <span class="comment">//恢复该错误位置对应的所有开头位置</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="type">int</span> next : graph.get(cur + i)) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (--input[next] == <span class="number">0</span>)&#123;</span><br><span class="line">                            queue[r++] = next;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理的结果不是入度长度的话</span></span><br><span class="line">        <span class="keyword">if</span> (size != len)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; ans.length; i++) &#123;</span><br><span class="line">            ans[i] = stack[--size];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 拓扑排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AlienOrder</title>
      <link href="/2024/07/15/AlienOrder/"/>
      <url>/2024/07/15/AlienOrder/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.拓扑排序;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/15 10:52</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 火星词典</span></span><br><span class="line"><span class="comment">// 现有一种使用英语字母的火星语言</span></span><br><span class="line"><span class="comment">// 这门语言的字母顺序对你来说是未知的。</span></span><br><span class="line"><span class="comment">// 给你一个来自这种外星语言字典的字符串列表 words</span></span><br><span class="line"><span class="comment">// words 中的字符串已经 按这门新语言的字母顺序进行了排序 。</span></span><br><span class="line"><span class="comment">// 如果这种说法是错误的，并且给出的 words 不能对应任何字母的顺序，则返回 &quot;&quot;</span></span><br><span class="line"><span class="comment">// 否则，返回一个按新语言规则的 字典递增顺序 排序的独特字符串</span></span><br><span class="line"><span class="comment">// 如果有多个解决方案，则返回其中任意一个</span></span><br><span class="line"><span class="comment">// words中的单词一定都是小写英文字母组成的</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/alien-dictionary/</span></span><br><span class="line"><span class="comment">// 测试链接(不需要会员) : https://leetcode.cn/problems/Jf1JuT/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AlienOrder</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ArrayList&lt;Set&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;Set&lt;Integer&gt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] input = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> l, r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历前后字符串，构建图</span></span><br><span class="line">    <span class="comment">//挺多细节问题的，包括入度的初始化，遍历时字符的种类和最后结果，字符下标，字符都相同时处理逻辑</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">alienOrder</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        build(words);</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> words.length;</span><br><span class="line">        <span class="comment">//先遍历每个字符串建图</span></span><br><span class="line"><span class="comment">//        for (int i = 0; i &lt; n; i++) &#123;</span></span><br><span class="line"><span class="comment">//            String word = words[i];</span></span><br><span class="line"><span class="comment">//            for (int j = 1; j &lt; word.length(); j++) &#123;</span></span><br><span class="line"><span class="comment">//                add(word.charAt(j - 1), word.charAt(j));</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//再遍历前后两个字符串建图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//对比两个字符，当遇到第一个不同的字符时，即可决定顺序。</span></span><br><span class="line">            <span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> words[i - <span class="number">1</span>];</span><br><span class="line">            <span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> words[i];</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> Math.min(s1.length(), s2.length());</span><br><span class="line">            <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (; r &lt; m; r++) &#123;</span><br><span class="line">                <span class="comment">//遇到第一个不同的就跳出 并建图</span></span><br><span class="line">                <span class="keyword">if</span> (s1.charAt(r) != s2.charAt(r))&#123;</span><br><span class="line">                    add(s1.charAt(r), s2.charAt(r));</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果都一样，但是第一个后续还有字符的话，不符合</span></span><br><span class="line">                <span class="comment">//eg: abcd abc</span></span><br><span class="line">                <span class="keyword">if</span> ( r == m - <span class="number">1</span> &amp;&amp; m != s1.length())&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取所有入度为0的节点</span></span><br><span class="line">        <span class="comment">//统计字符种类</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">kind</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] queue = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; MAIN; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (input[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue[r++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (input[i] != -<span class="number">1</span>)&#123;</span><br><span class="line">                kind++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从入度为0节点出发</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> queue[l++];</span><br><span class="line">            <span class="comment">//直接放入答案</span></span><br><span class="line">            ans.append(indexTo(cur));</span><br><span class="line">            <span class="keyword">for</span> (Integer i : graph.get(cur)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--input[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue[r++] = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//无法处理所有结果，直接返回“”</span></span><br><span class="line">        <span class="keyword">return</span> ans.length() == kind ? ans.toString() : <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">add</span><span class="params">(<span class="type">char</span> c1, <span class="type">char</span> c2)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">from</span> <span class="operator">=</span> toIndex(c1);</span><br><span class="line">        <span class="type">int</span> <span class="variable">to</span> <span class="operator">=</span> toIndex(c2);</span><br><span class="line">        <span class="keyword">if</span> (!graph.get(from).contains(to))&#123;</span><br><span class="line">            graph.get(from).add(to);</span><br><span class="line">            input[to]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(String[] words)</span>&#123;</span><br><span class="line">        l = r = <span class="number">0</span>;</span><br><span class="line">        graph.clear();</span><br><span class="line">        Arrays.fill(input, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, index; i &lt; MAIN; i++) &#123;</span><br><span class="line">            graph.add(<span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//初始化入度</span></span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">char</span> c : word.toCharArray()) &#123;</span><br><span class="line">                input[toIndex(c)] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">toIndex</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> c - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">char</span> <span class="title function_">indexTo</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">char</span>) (<span class="string">&#x27;a&#x27;</span> + i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 拓扑排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TopoSortDynamicNowcoder</title>
      <link href="/2024/07/12/TopoSortDynamicNowcoder/"/>
      <url>/2024/07/12/TopoSortDynamicNowcoder/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.拓扑排序;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/12 15:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓扑排序模版（牛客）</span></span><br><span class="line"><span class="comment">// 邻接表建图（动态方式）</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.nowcoder.com/practice/88f7e156ca7d43a1a535f619cd3f495c</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下所有代码，把主类名改成Main，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TopoSortDynamicNowcoder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">200001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拓扑排序，用到队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] queue = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> l, r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 拓扑排序，入度表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] indegree = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 收集拓扑排序的结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line"></span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(bf);</span><br><span class="line">        <span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF)&#123;</span><br><span class="line">            n = (<span class="type">int</span>) in.nval;</span><br><span class="line">            in.nextToken();</span><br><span class="line">            m = (<span class="type">int</span>) in.nval;</span><br><span class="line">            <span class="comment">//初始化</span></span><br><span class="line">            ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            Arrays.fill(indegree, <span class="number">0</span>, n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, from, to; i &lt; m; i++) &#123;</span><br><span class="line">                in.nextToken();</span><br><span class="line">                from = (<span class="type">int</span>) in.nval;</span><br><span class="line">                in.nextToken();</span><br><span class="line">                to = (<span class="type">int</span>) in.nval;</span><br><span class="line">                graph.get(from).add(to);</span><br><span class="line">                indegree[to]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!topoSort(graph)) &#123;</span><br><span class="line">                out.println(-<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">                    out.print(ans[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                out.println(ans[n - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        bf.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">topoSort</span><span class="params">(ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph)</span>&#123;</span><br><span class="line">        l = r = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//获取所有入度为0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (indegree[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue[r++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//从入度为0开始 遍历节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> queue[l++];</span><br><span class="line">            ans[cnt++] = cur;</span><br><span class="line">            <span class="keyword">for</span> (Integer next : graph.get(cur)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--indegree[next] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue[r++] = next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt == n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 拓扑排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FindOrder</title>
      <link href="/2024/07/12/FindOrder/"/>
      <url>/2024/07/12/FindOrder/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图.拓扑排序;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 拓扑排序模板</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/12 15:31</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 拓扑排序模版（Leetcode）</span></span><br><span class="line"><span class="comment">// 邻接表建图（动态方式）</span></span><br><span class="line"><span class="comment">// 课程表II</span></span><br><span class="line"><span class="comment">// 现在你总共有 numCourses 门课需要选，记为 0 到 numCourses - 1</span></span><br><span class="line"><span class="comment">// 给你一个数组 prerequisites ，其中 prerequisites[i] = [ai, bi]</span></span><br><span class="line"><span class="comment">// 表示在选修课程 ai 前 必须 先选修 bi</span></span><br><span class="line"><span class="comment">// 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示：[0,1]</span></span><br><span class="line"><span class="comment">// 返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序</span></span><br><span class="line"><span class="comment">// 你只要返回 任意一种 就可以了。如果不可能完成所有课程，返回 一个空数组</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/course-schedule-ii/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindOrder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">2001</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ArrayList&lt;ArrayList&lt;Integer&gt;&gt; graph = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//记录入度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] input = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//很明显拓扑排序</span></span><br><span class="line">    <span class="comment">//拓扑排序模板： 从入度为0的开始遍历</span></span><br><span class="line">    <span class="comment">//遍历过程中把入度为0的记录下来</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//知识点：拓扑排序、数组实现队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] findOrder(<span class="type">int</span> n, <span class="type">int</span>[][] prerequisites) &#123;</span><br><span class="line">        <span class="comment">//初始化</span></span><br><span class="line">        build(n);</span><br><span class="line">        <span class="comment">//邻接表建图</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] prerequisite : prerequisites) &#123;</span><br><span class="line">            graph.get(prerequisite[<span class="number">1</span>]).add(prerequisite[<span class="number">0</span>]);</span><br><span class="line">            input[prerequisite[<span class="number">0</span>]]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计所有入度为0的节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//用队列记录出队顺序</span></span><br><span class="line">        <span class="type">int</span>[] queue = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (input[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                queue[r++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用来统计遍历的节点个数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从入度为零的节点出发遍历，遍历过程中入度--，并保持入度为0的节点</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="comment">//队列出队 从当前节点遍历</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> queue[l++];</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="keyword">for</span> (Integer i : graph.get(cur)) &#123;</span><br><span class="line">                <span class="comment">//入度减1</span></span><br><span class="line">                <span class="keyword">if</span> (--input[i] == <span class="number">0</span>)&#123;</span><br><span class="line">                    queue[r++] = i;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果处理节点个数不等于总数，证明无法遍历全部节点</span></span><br><span class="line">        <span class="keyword">return</span> cnt == n ? queue : <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        graph.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            graph.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.fill(input, <span class="number">0</span>, n, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 拓扑排序 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 拓扑排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CreateGraph</title>
      <link href="/2024/07/10/CreateGraph/"/>
      <url>/2024/07/10/CreateGraph/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.图;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 建图的方式</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/10 16:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateGraph</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 点的最大数量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 边的最大数量</span></span><br><span class="line">    <span class="comment">// 只有链式前向星方式建图需要这个数量</span></span><br><span class="line">    <span class="comment">// 注意如果无向图的最大数量是m条边，数量要准备m*2</span></span><br><span class="line">    <span class="comment">// 因为一条无向边要加两条有向边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXM</span> <span class="operator">=</span> <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、邻接矩阵</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[][] graph1 = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN][MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2、邻接表</span></span><br><span class="line">    <span class="comment">//点a 出发 到达的点有集合A，集合内内放的是[点，权重]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ArrayList&lt;ArrayList&lt;<span class="type">int</span>[]&gt;&gt; graph2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、链式前向星  感觉像是链表的头插法</span></span><br><span class="line">    <span class="comment">//i点对应的头部边  点 （边） （头部节点)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] head = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line">    <span class="comment">//i边对应的下一条边 (下一节点）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] next = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line">    <span class="comment">//i边去往的点  边 -》 点 （记录边去往的点)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] to = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果有权重</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] weight = <span class="keyword">new</span> <span class="title class_">int</span>[MAXM];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//给边编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="comment">//邻接矩阵清空</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                graph1[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//邻接表清空</span></span><br><span class="line">        graph2.clear();</span><br><span class="line">        <span class="comment">//初始化集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            graph2.add(<span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//链式前向星清空</span></span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        Arrays.fill(head, <span class="number">1</span>, n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三种方式建立有向图带权图</span></span><br><span class="line">    <span class="comment">//有一条边从点edge[0] 到 点edge[1]，权重为 edge[2]</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">directGraph</span><span class="params">(<span class="type">int</span>[][] edges)</span>&#123;</span><br><span class="line">        <span class="comment">//邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            graph1[edge[<span class="number">0</span>]][edge[<span class="number">1</span>]] = edge[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//邻接表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            graph2.get(edge[<span class="number">0</span>]).add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;edge[<span class="number">1</span>], edge[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//链式前向星</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            addEdge(edge[<span class="number">0</span>], edge[<span class="number">1</span>], edge[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 三种方式建立无向图带权图</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">undirectGraph</span><span class="params">(<span class="type">int</span>[][] edges)</span>&#123;</span><br><span class="line">        <span class="comment">//邻接矩阵</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            <span class="comment">//两个方向都要连接</span></span><br><span class="line">            graph1[edge[<span class="number">0</span>]][edge[<span class="number">1</span>]] = edge[<span class="number">2</span>];</span><br><span class="line">            graph1[edge[<span class="number">1</span>]][edge[<span class="number">2</span>]] = edge[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//邻接表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            graph2.get(edge[<span class="number">0</span>]).add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;edge[<span class="number">1</span>], edge[<span class="number">2</span>]&#125;);</span><br><span class="line">            graph2.get(edge[<span class="number">1</span>]).add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;edge[<span class="number">0</span>], edge[<span class="number">2</span>]&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//链式前向星</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] edge : edges) &#123;</span><br><span class="line">            addEdge(edge[<span class="number">0</span>], edge[<span class="number">1</span>], edge[<span class="number">2</span>]);</span><br><span class="line">            addEdge(edge[<span class="number">1</span>], edge[<span class="number">0</span>], edge[<span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 链式前向星加边</span></span><br><span class="line">    <span class="comment">//边 从 u 到 v 权重为 w</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">addEdge</span><span class="params">(<span class="type">int</span> u, <span class="type">int</span> v, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">        <span class="comment">//当前边 去往的下一条边 是当前点的头部边</span></span><br><span class="line">        next[cnt] = head[u];</span><br><span class="line">        <span class="comment">//当前边去往的点</span></span><br><span class="line">        to[cnt] = v;</span><br><span class="line">        <span class="comment">//当前边的权重</span></span><br><span class="line">        weight[cnt] = w;</span><br><span class="line">        <span class="comment">//更新当前点的头部边 为当前边</span></span><br><span class="line">        <span class="comment">//更新编号</span></span><br><span class="line">        head[u] = cnt++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">traversal</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;邻接矩阵遍历 :&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">                System.out.print(graph1[i][j] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;邻接表遍历 :&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;(邻居、边权) : &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] edge : graph2.get(i)) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;(&quot;</span> + edge[<span class="number">0</span>] + <span class="string">&quot;,&quot;</span> + edge[<span class="number">1</span>] + <span class="string">&quot;) &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;链式前向星 :&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            System.out.print(i + <span class="string">&quot;(邻居、边权) : &quot;</span>);</span><br><span class="line">            <span class="comment">// 注意这个for循环，链式前向星的方式遍历</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">ei</span> <span class="operator">=</span> head[i]; ei &gt; <span class="number">0</span>; ei = next[ei]) &#123;</span><br><span class="line">                System.out.print(<span class="string">&quot;(&quot;</span> + to[ei] + <span class="string">&quot;,&quot;</span> + weight[ei] + <span class="string">&quot;) &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 理解了带权图的建立过程，也就理解了不带权图</span></span><br><span class="line">        <span class="comment">// 点的编号为1...n</span></span><br><span class="line">        <span class="comment">// 例子1自己画一下图，有向带权图，然后打印结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n1</span> <span class="operator">=</span> <span class="number">4</span>;</span><br><span class="line">        <span class="type">int</span>[][] edges1 = &#123; &#123; <span class="number">1</span>, <span class="number">3</span>, <span class="number">6</span> &#125;, &#123; <span class="number">4</span>, <span class="number">3</span>, <span class="number">4</span> &#125;, &#123; <span class="number">2</span>, <span class="number">4</span>, <span class="number">2</span> &#125;, &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">7</span> &#125;, &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span> &#125;, &#123; <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span> &#125; &#125;;</span><br><span class="line">        build(n1);</span><br><span class="line">        directGraph(edges1);</span><br><span class="line">        traversal(n1);</span><br><span class="line">        System.out.println(<span class="string">&quot;==============================&quot;</span>);</span><br><span class="line">        <span class="comment">// 例子2自己画一下图，无向带权图，然后打印结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">        <span class="type">int</span>[][] edges2 = &#123; &#123; <span class="number">3</span>, <span class="number">5</span>, <span class="number">4</span> &#125;, &#123; <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span> &#125;, &#123; <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span> &#125;, &#123; <span class="number">5</span>, <span class="number">2</span>, <span class="number">4</span> &#125;, &#123; <span class="number">2</span>, <span class="number">3</span>, <span class="number">7</span> &#125;, &#123; <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span> &#125;, &#123; <span class="number">4</span>, <span class="number">2</span>, <span class="number">6</span> &#125; &#125;;</span><br><span class="line">        build(n2);</span><br><span class="line">        undirectGraph(edges2);</span><br><span class="line">        traversal(n2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 图 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HitBricks</title>
      <link href="/2024/07/09/HitBricks/"/>
      <url>/2024/07/09/HitBricks/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.洪水填充;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/9 15:34</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HitBricks</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//好像有点想法，倒推</span></span><br><span class="line">    <span class="comment">//先消除击中数组中的所有砖块，然后倒推复原砖块</span></span><br><span class="line">    <span class="comment">//如果某次复原过程中，能连接两个岛屿，则掉落的是不稳定的孤岛，否则不掉落任何东西</span></span><br><span class="line">    <span class="comment">//复原后的砖块恢复原样，继续复原下一个砖块</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//所以</span></span><br><span class="line">    <span class="comment">//1、消除所有hits位置</span></span><br><span class="line">    <span class="comment">//2、先遍历所有和顶部连接的岛屿，编号-1代表稳定</span></span><br><span class="line">    <span class="comment">//3、遍历其他岛屿编号2+，代表不稳定</span></span><br><span class="line">    <span class="comment">//4、倒序复原hits砖块，四个方向看连接多少个2+砖块，并记录答案，用vister数组加速访问结果</span></span><br><span class="line">    <span class="comment">//唉，大体上是思路是差不多的，但细节不对。重写一遍吧</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] hitBricks0(<span class="type">int</span>[][] grid, <span class="type">int</span>[][] hits) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hits.length;</span><br><span class="line">        <span class="comment">//清除hits位置砖块</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, x,y; i &lt; h; i++) &#123;</span><br><span class="line">            x = hits[i][<span class="number">0</span>];</span><br><span class="line">            y = hits[i][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//如果那个位置有砖块，才变为-2</span></span><br><span class="line">            <span class="keyword">if</span> (grid[x][y] == <span class="number">1</span>)&#123;</span><br><span class="line">                grid[x][y] = -<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历所有和顶部连接的岛屿，编号-1代表稳定</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[<span class="number">0</span>][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                dfs(<span class="number">0</span>, j, grid, -<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">cnts</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//遍历其他岛屿编号2+，代表不稳定</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, size = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    size += dfs(i, j, grid, cnts);</span><br><span class="line">                    map.put(cnts, size);</span><br><span class="line">                    size = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//倒序复原hits砖块，四个方向看连接多少个2+砖块，并记录答案，用vister数组加速访问结果</span></span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[h];</span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[cnts];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            ans[i] = recover(i, grid, hits, map, visited);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据左神思路写的</span></span><br><span class="line">    <span class="comment">//大体思路上差不多，但处理步骤更优化</span></span><br><span class="line">    <span class="comment">//1、消除所有hits位置 编号--</span></span><br><span class="line">    <span class="comment">//2、感染所有顶部位置 编号2</span></span><br><span class="line">    <span class="comment">//3、倒序恢复感染节点，并从感染节点感染其他节点，返回感染数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] hitBricks(<span class="type">int</span>[][] grid, <span class="type">int</span>[][] hits)&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> hits.length;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[h];</span><br><span class="line">        <span class="comment">//当只有一行的时候，都是顶部，肯定没节点掉落</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清除 hits位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] hit : hits) &#123;</span><br><span class="line">            grid[hit[<span class="number">0</span>]][hit[<span class="number">1</span>]]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//感染顶部节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            dfs(<span class="number">0</span>, j, grid, <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//倒序恢复感染节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> h - <span class="number">1</span>, x, y; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            x = hits[i][<span class="number">0</span>];</span><br><span class="line">            y = hits[i][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//复原节点</span></span><br><span class="line">            grid[x][y]++;</span><br><span class="line">            <span class="comment">//判断当前节点是否至少有一个方向和顶部节点连接</span></span><br><span class="line">            <span class="keyword">if</span> (worth(x, y, grid))&#123;</span><br><span class="line">                <span class="comment">//从节点出发感染其他节点</span></span><br><span class="line">                ans[i] = dfs(x, y, grid, <span class="number">2</span>) - <span class="number">1</span>;<span class="comment">//记得要去除当个</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">recover</span><span class="params">(<span class="type">int</span> index, <span class="type">int</span>[][] grid, <span class="type">int</span>[][] hits, HashMap&lt;Integer, Integer&gt; map, <span class="type">boolean</span>[] visited)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> hits[index][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> hits[index][<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//原本那个位置没砖块，直接返回0</span></span><br><span class="line">        <span class="keyword">if</span> (grid[x][y] != -<span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[x][y] = worth(x, y, grid) ? -<span class="number">1</span> : <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//复原砖块，看四个方向， 如果有某个方向能连接稳定的砖块，则别的方向能连接多少个不稳定的砖块就掉落多少</span></span><br><span class="line">        <span class="comment">//判断四个方向是否能连接稳定的砖块</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//获取四个方向的砖块编号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">up</span> <span class="operator">=</span> x - <span class="number">1</span> &lt; <span class="number">0</span> ? <span class="number">0</span> : grid[x - <span class="number">1</span>][y];</span><br><span class="line">        <span class="type">int</span> <span class="variable">down</span> <span class="operator">=</span> x + <span class="number">1</span> &gt;= n ? <span class="number">0</span> : grid[x + <span class="number">1</span>][y];</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> y - <span class="number">1</span> &lt; <span class="number">0</span> ? <span class="number">0</span> : grid[x][y - <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> y + <span class="number">1</span> &gt;= m ? <span class="number">0</span> : grid[x][y + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//没有一个方向能连接稳定砖块</span></span><br><span class="line">        <span class="keyword">if</span> (up != -<span class="number">1</span> &amp;&amp; down != -<span class="number">1</span> &amp;&amp; left !=-<span class="number">1</span> &amp;&amp; right != -<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (up &gt; <span class="number">0</span> &amp;&amp; !visited[up])&#123;</span><br><span class="line">            ans += map.get(up);</span><br><span class="line">            visited[up] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (down &gt; <span class="number">0</span> &amp;&amp; !visited[down])&#123;</span><br><span class="line">            ans += map.get(down);</span><br><span class="line">            visited[down] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">0</span> &amp;&amp; !visited[left])&#123;</span><br><span class="line">            ans += map.get(left);</span><br><span class="line">            visited[left] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &gt; <span class="number">0</span> &amp;&amp; !visited[right])&#123;</span><br><span class="line">            ans += map.get(right);</span><br><span class="line">            visited[right] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (up &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            visited[up] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (down &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            visited[down] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (left &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            visited[left] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            visited[right] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断当前节点是否是与顶部相连的稳定节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">worth</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>  grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">return</span> grid[i][j] == <span class="number">1</span> &amp;&amp;</span><br><span class="line">                (i == <span class="number">0</span></span><br><span class="line">                        || (i &gt; <span class="number">0</span> &amp;&amp; grid[i - <span class="number">1</span>][j] == <span class="number">2</span>)</span><br><span class="line">                        || (i &lt; n - <span class="number">1</span> &amp;&amp; grid[i + <span class="number">1</span>][j] == <span class="number">2</span>)</span><br><span class="line">                        || (j &gt; <span class="number">0</span> &amp;&amp; grid[i][j - <span class="number">1</span>] == <span class="number">2</span>)</span><br><span class="line">                        || (j &lt; m - <span class="number">1</span> &amp;&amp; grid[i][j + <span class="number">1</span>] == <span class="number">2</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[][] grid, <span class="type">int</span> cnt)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == grid.length || j &lt; <span class="number">0</span> || j == grid[<span class="number">0</span>].length || grid[i][j] != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = cnt;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + dfs(i + <span class="number">1</span>, j, grid, cnt) + dfs(i - <span class="number">1</span>, j, grid, cnt) + dfs(i, j + <span class="number">1</span>, grid, cnt) + dfs(i, j - <span class="number">1</span>, grid, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 洪水填充 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洪水填充 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LargestIsland</title>
      <link href="/2024/07/09/LargestIsland/"/>
      <url>/2024/07/09/LargestIsland/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.洪水填充;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/9 13:44</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大人工岛</span></span><br><span class="line"><span class="comment">// 给你一个大小为 n * n 二进制矩阵 grid 。最多 只能将一格 0 变成 1 。</span></span><br><span class="line"><span class="comment">// 返回执行此操作后，grid 中最大的岛屿面积是多少？</span></span><br><span class="line"><span class="comment">// 岛屿 由一组上、下、左、右四个方向相连的 1 形成</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/making-a-large-island/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LargestIsland</span> &#123;</span><br><span class="line">    <span class="comment">//有想法，统计各个岛屿面积 -》 给岛屿编号 -》 记录岛屿编号，面积</span></span><br><span class="line">    <span class="comment">//遍历每个编号，将上下左右变为其他岛屿的话，能得到多少面积，记录最大面积</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestIsland</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//连接岛屿，并编号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//0编号直接0</span></span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//连接岛屿</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, size = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    size += dfs(i, j, grid, cnt);</span><br><span class="line">                    map.put(cnt++, size);</span><br><span class="line">                    size = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Integer value : map.values()) &#123;</span><br><span class="line">            ans = Math.max(ans, value);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历为0的节点，上下左右看看能连接多少岛屿</span></span><br><span class="line">        <span class="comment">//记录是否遇到过岛屿</span></span><br><span class="line">        <span class="type">boolean</span>[] visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[cnt];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    ans = Math.max(ans, connectCount(i, j, grid, map, visited));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[][] grid, <span class="type">int</span> cnt)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i == grid.length || j &lt; <span class="number">0</span> || j == grid[<span class="number">0</span>].length || grid[i][j] != <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        grid[i][j] = cnt;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> dfs(i, j + <span class="number">1</span>, grid, cnt);</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> dfs(i, j - <span class="number">1</span>, grid, cnt);</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> dfs(i + <span class="number">1</span>, j, grid, cnt);</span><br><span class="line">        <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> dfs(i - <span class="number">1</span>, j , grid, cnt);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + a + b + c + d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">connectCount</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[][] grid, HashMap&lt;Integer, Integer&gt; map, <span class="type">boolean</span>[] visited)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">up</span> <span class="operator">=</span> i + <span class="number">1</span> &lt; n ? grid[i + <span class="number">1</span>][j] : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">down</span> <span class="operator">=</span> i - <span class="number">1</span> &gt;= <span class="number">0</span> ? grid[i - <span class="number">1</span>][j] : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> j + <span class="number">1</span> &lt; m ? grid[i][j + <span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> j - <span class="number">1</span> &gt;= <span class="number">0</span> ? grid[i][j - <span class="number">1</span>] : <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> map.get(up) + <span class="number">1</span>;<span class="comment">//加上本身</span></span><br><span class="line">        visited[up] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//上下左右看看有没有能够连接的岛屿</span></span><br><span class="line">        <span class="keyword">if</span> (!visited[down])&#123;</span><br><span class="line">            ans += map.get(down);</span><br><span class="line">            visited[down] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!visited[left])&#123;</span><br><span class="line">            ans += map.get(left);</span><br><span class="line">            visited[left] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!visited[right])&#123;</span><br><span class="line">            ans += map.get(right);</span><br><span class="line">            visited[right] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[up] = <span class="literal">false</span>;</span><br><span class="line">        visited[down] = <span class="literal">false</span>;</span><br><span class="line">        visited[left] = <span class="literal">false</span>;</span><br><span class="line">        visited[right] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 洪水填充 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洪水填充 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Solve</title>
      <link href="/2024/07/08/Solve/"/>
      <url>/2024/07/08/Solve/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.洪水填充;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/8 16:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 被围绕的区域</span></span><br><span class="line"><span class="comment">// 给你一个 m x n 的矩阵 board ，由若干字符 &#x27;X&#x27; 和 &#x27;O&#x27; ，找到所有被 &#x27;X&#x27; 围绕的区域</span></span><br><span class="line"><span class="comment">// 并将这些区域里所有的 &#x27;O&#x27; 用 &#x27;X&#x27; 填充。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/surrounded-regions/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solve</span> &#123;</span><br><span class="line">    <span class="comment">//自己思路</span></span><br><span class="line">    <span class="comment">//有想法，因为边缘不能被捕获，所以先遍历边缘，将与边缘连接的元素变为F</span></span><br><span class="line">    <span class="comment">//再洪水填充内部区域，变为X</span></span><br><span class="line">    <span class="comment">//最后复原F 为O</span></span><br><span class="line">    <span class="comment">//可以根据左神思路再优化：遍历完边缘后，直接将内部的所有O 变为 X 即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve0</span><span class="params">(<span class="type">char</span>[][] board)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//遍历边缘</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || i == n - <span class="number">1</span> || j == <span class="number">0</span> || j == m - <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                        dfs(i, j, board, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;O&#x27;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历内部</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; m - <span class="number">1</span>; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                    dfs(i, j, board, <span class="string">&#x27;X&#x27;</span>, <span class="string">&#x27;O&#x27;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//还原</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> || i == n - <span class="number">1</span> || j == <span class="number">0</span> || j == m - <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(board[i][j] == <span class="string">&#x27;F&#x27;</span>)&#123;</span><br><span class="line">                        dfs(i, j, board, <span class="string">&#x27;O&#x27;</span>, <span class="string">&#x27;F&#x27;</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是左神的遍历思路</span></span><br><span class="line">    <span class="comment">//先将边缘变为F</span></span><br><span class="line">    <span class="comment">//后面直接全遍历，遇到X就是O,遇到F就复原</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">solve</span><span class="params">(<span class="type">char</span>[][] board)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> board.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> board[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//遍历边缘</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[<span class="number">0</span>][j] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                dfs(<span class="number">0</span>, j, board);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (board[n - <span class="number">1</span>][j] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                dfs(n-<span class="number">1</span>, j, board);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][<span class="number">0</span>] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                dfs(i, <span class="number">0</span>, board);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (board[i][m - <span class="number">1</span>] == <span class="string">&#x27;O&#x27;</span>) &#123;</span><br><span class="line">                dfs(i, m - <span class="number">1</span>, board);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接全遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (board[i][j] == <span class="string">&#x27;F&#x27;</span>)&#123;</span><br><span class="line">                    board[i][j] = <span class="string">&#x27;O&#x27;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span>[][] board)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || board[i][j] != <span class="string">&#x27;O&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = <span class="string">&#x27;F&#x27;</span>;</span><br><span class="line">        dfs(i + <span class="number">1</span>, j, board);</span><br><span class="line">        dfs(i - <span class="number">1</span>, j, board);</span><br><span class="line">        dfs(i, j + <span class="number">1</span>, board);</span><br><span class="line">        dfs(i, j - <span class="number">1</span>, board);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span>[][] board, <span class="type">char</span> t, <span class="type">char</span> s)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || board[i][j] != s)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        board[i][j] = t;</span><br><span class="line">        dfs(i + <span class="number">1</span>, j, board, t, s);</span><br><span class="line">        dfs(i - <span class="number">1</span>, j, board, t, s);</span><br><span class="line">        dfs(i, j + <span class="number">1</span>, board, t, s);</span><br><span class="line">        dfs(i, j - <span class="number">1</span>, board, t, s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 洪水填充 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洪水填充 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NumIslands</title>
      <link href="/2024/07/08/NumIslands/"/>
      <url>/2024/07/08/NumIslands/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.洪水填充;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/8 16:12</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 岛屿数量</span></span><br><span class="line"><span class="comment">// 给你一个由 &#x27;1&#x27;（陆地）和 &#x27;0&#x27;（水）组成的的二维网格，请你计算网格中岛屿的数量</span></span><br><span class="line"><span class="comment">// 岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成</span></span><br><span class="line"><span class="comment">// 此外，你可以假设该网格的四条边均被水包围</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/number-of-islands/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumIslands</span> &#123;</span><br><span class="line">    <span class="comment">//洪水填充做法</span></span><br><span class="line">    <span class="comment">//上下左右方向递归</span></span><br><span class="line">    <span class="comment">//递归过的改成2</span></span><br><span class="line">    <span class="comment">//核心思想在于感染，遇到的第一个未被感染的节点就可以增加一个岛屿数量了，剩下的都是感染操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numIslands</span><span class="params">(<span class="type">char</span>[][] grid)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                ans += dfs(i,j, grid);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">char</span>[][] grid)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || j &lt; <span class="number">0</span> || i &gt;= grid.length ||</span><br><span class="line">                j &gt;= grid[<span class="number">0</span>].length || grid[i][j] != <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//感染本节点</span></span><br><span class="line">        grid[i][j] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">        <span class="comment">//上下左右感染</span></span><br><span class="line">        dfs(i - <span class="number">1</span>, j, grid);</span><br><span class="line">        dfs(i + <span class="number">1</span>, j, grid);</span><br><span class="line">        dfs(i, j - <span class="number">1</span>, grid);</span><br><span class="line">        dfs(i, j + <span class="number">1</span>, grid);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 洪水填充 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 洪水填充 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinMalwareSpread</title>
      <link href="/2024/07/05/MinMalwareSpread/"/>
      <url>/2024/07/05/MinMalwareSpread/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.并查集下;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>  困难，更多是考察coding能力</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/5 11:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 尽量减少恶意软件的传播 II</span></span><br><span class="line"><span class="comment">// 给定一个由 n 个节点组成的网络，用 n x n 个邻接矩阵 graph 表示</span></span><br><span class="line"><span class="comment">// 在节点网络中，只有当 graph[i][j] = 1 时，节点 i 能够直接连接到另一个节点 j。</span></span><br><span class="line"><span class="comment">// 一些节点 initial 最初被恶意软件感染。只要两个节点直接连接，</span></span><br><span class="line"><span class="comment">// 且其中至少一个节点受到恶意软件的感染，那么两个节点都将被恶意软件感染。</span></span><br><span class="line"><span class="comment">// 这种恶意软件的传播将继续，直到没有更多的节点可以被这种方式感染。</span></span><br><span class="line"><span class="comment">// 假设 M(initial) 是在恶意软件停止传播之后，整个网络中感染恶意软件的最终节点数。</span></span><br><span class="line"><span class="comment">// 我们可以从 initial 中删除一个节点，</span></span><br><span class="line"><span class="comment">// 并完全移除该节点以及从该节点到任何其他节点的任何连接。</span></span><br><span class="line"><span class="comment">// 请返回移除后能够使 M(initial) 最小化的节点。</span></span><br><span class="line"><span class="comment">// 如果有多个节点满足条件，返回索引 最小的节点 。</span></span><br><span class="line"><span class="comment">// initial 中每个整数都不同</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/minimize-malware-spread-ii/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinMalwareSpread</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">301</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] maxC = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//思路错了！！！ 某个节点断开的时候，会影响相连节点的路径</span></span><br><span class="line">    <span class="comment">//有个想法，联合时记录每个节点的连接数，联合时，让最大连接数的当爸爸</span></span><br><span class="line">    <span class="comment">//判断要去掉哪个病毒时，比较爸爸的最大连接数即可</span></span><br><span class="line">    <span class="comment">//去掉连接数大的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMalwareSpread1</span><span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span>[] initial)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span>  graph.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> graph[<span class="number">0</span>].length;</span><br><span class="line">        build(n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先统计连接数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                maxC[i]++;</span><br><span class="line">                maxC[j]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="comment">//如果有路通，则连接</span></span><br><span class="line">                <span class="keyword">if</span> (graph[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    union(i,j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; initial.length; i++) &#123;</span><br><span class="line">            <span class="comment">//对比谁的爸爸牵扯的连接数多，就删谁</span></span><br><span class="line">            ans = maxC[find(ans)] &gt;= maxC[find(i)] ? ans : i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//左神思路： 将普通节点标记所属源头感染节点，最后看哪个感染节点多即去除哪个</span></span><br><span class="line">    <span class="comment">//1、先连接普通节点，用数组统计代表节点的集合节点个数</span></span><br><span class="line">    <span class="comment">//2、标记普通节点所属源头，用数组标记代表节点的源头节点 感染</span></span><br><span class="line">    <span class="comment">//3、用数组统计源头节点感染个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] size = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="comment">// &gt;= 0代表具体感染的节点</span></span><br><span class="line">    <span class="comment">// -1 代表没有感染的节点</span></span><br><span class="line">    <span class="comment">// -2 代表感染多个节点</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] source = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] cnts = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//方便查询 病毒</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span>[] virus  = <span class="keyword">new</span> <span class="title class_">boolean</span>[MAIN];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minMalwareSpread</span><span class="params">(<span class="type">int</span>[][] graph, <span class="type">int</span>[] initial)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> graph.length;</span><br><span class="line">        build(n, initial);</span><br><span class="line">        <span class="comment">//连接普通节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">//如果有连接，且是普通节点</span></span><br><span class="line">                <span class="keyword">if</span> (graph[i][j] == <span class="number">1</span> &amp;&amp; !virus[i] &amp;&amp; !virus[j])&#123;</span><br><span class="line">                    union(i, j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//标记所感染的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>, i; k &lt; initial.length; k++) &#123;</span><br><span class="line">            <span class="comment">//遍历每行</span></span><br><span class="line">            i = initial[k];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>, fj; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="comment">//有连接，且连接节点是普通节点</span></span><br><span class="line">                <span class="keyword">if</span> (graph[i][j] == <span class="number">1</span> &amp;&amp; !virus[j])&#123;</span><br><span class="line">                    <span class="comment">//有感染节点且不是自己，则多个感染节点</span></span><br><span class="line">                    fj = find(j);</span><br><span class="line">                    <span class="keyword">if</span> (source[fj] &gt;= <span class="number">0</span> &amp;&amp; source[fj] != i)&#123;</span><br><span class="line">                        source[fj] = -<span class="number">2</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (source[fj] == -<span class="number">1</span>)&#123;<span class="comment">//否则赋值自己</span></span><br><span class="line">                        source[fj] = i;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计感染节点个数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="comment">//只看代表节点</span></span><br><span class="line">            <span class="keyword">if</span> (i == find(i) &amp;&amp; source[i] &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                cnts[source[i]] += size[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//要返回节点，不是坐标</span></span><br><span class="line">        Arrays.sort(initial);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> initial[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> cnts[ans];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : initial) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnts[i] &gt; max)&#123;</span><br><span class="line">                ans = i;</span><br><span class="line">                max = cnts[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fx</span> <span class="operator">=</span> find(x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">fy</span> <span class="operator">=</span> find(y);</span><br><span class="line">        <span class="keyword">if</span> (fx != fy)&#123;</span><br><span class="line">            father[fx] = fy;</span><br><span class="line">            size[fy] += size[fx];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] initial)</span>&#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">            virus[i] = <span class="literal">false</span>;</span><br><span class="line">            size[i] = <span class="number">1</span>;</span><br><span class="line">            cnts[i] = <span class="number">0</span>;</span><br><span class="line">            source[i] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//标记源头节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : initial) &#123;</span><br><span class="line">            virus[i] = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i != father[i])&#123;</span><br><span class="line">            father[i] = find(father[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> father[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下是原思路代码</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">            maxC[i] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//    private void union(int x, int y)&#123;</span></span><br><span class="line"><span class="comment">//        int fx = find(x);</span></span><br><span class="line"><span class="comment">//        int fy = find(y);</span></span><br><span class="line"><span class="comment">//        //连接数大的做爸爸</span></span><br><span class="line"><span class="comment">//        if (fx != fy)&#123;</span></span><br><span class="line"><span class="comment">//            if (maxC[fx] &gt;= maxC[fy])&#123;</span></span><br><span class="line"><span class="comment">//                father[fy] = fx;</span></span><br><span class="line"><span class="comment">//            &#125;else &#123;</span></span><br><span class="line"><span class="comment">//                father[fx] = fy;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line"><span class="comment">//    &#125;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 并查集下 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集下 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NumberOfGoodPaths</title>
      <link href="/2024/07/04/NumberOfGoodPaths/"/>
      <url>/2024/07/04/NumberOfGoodPaths/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.并查集下;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span> 困难</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/4 15:46</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 好路径的数目</span></span><br><span class="line"><span class="comment">// 给你一棵 n 个节点的树（连通无向无环的图）</span></span><br><span class="line"><span class="comment">// 节点编号从0到n-1，且恰好有n-1条边</span></span><br><span class="line"><span class="comment">// 给你一个长度为 n 下标从 0 开始的整数数组 vals</span></span><br><span class="line"><span class="comment">// 分别表示每个节点的值。同时给你一个二维整数数组 edges</span></span><br><span class="line"><span class="comment">// 其中 edges[i] = [ai, bi] 表示节点 ai 和 bi 之间有一条 无向 边</span></span><br><span class="line"><span class="comment">// 好路径需要满足以下条件：开始和结束节点的值相同、 路径中所有值都小于等于开始的值</span></span><br><span class="line"><span class="comment">// 请你返回不同好路径的数目</span></span><br><span class="line"><span class="comment">// 注意，一条路径和它反向的路径算作 同一 路径</span></span><br><span class="line"><span class="comment">// 比方说， 0 -&gt; 1 与 1 -&gt; 0 视为同一条路径。单个节点也视为一条合法路径</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/number-of-good-paths/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumberOfGoodPaths</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">30001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录点的坐标（编号），最大值当爸爸</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="comment">//记录代表节点（最大值）的节点个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] maxC = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有点思路，但想不出，不会</span></span><br><span class="line">    <span class="comment">//看了左神思路，妙妙脆脆鲨都没那么妙，感觉就是一个绝妙的算法设计</span></span><br><span class="line">    <span class="comment">//将边按照连接的两个点的最大值排序，然后从最小边开始处理，这种做法隔绝了其他边的影响</span></span><br><span class="line">    <span class="comment">//father数组谁大谁当爸爸，为了下面的节点个数数组</span></span><br><span class="line">    <span class="comment">//用数组维护代表节点的最大值个数</span></span><br><span class="line">    <span class="comment">//总个思路就是，联合并查集的时候，当代表节点的值相同，则可以生成最好路径</span></span><br><span class="line">    <span class="comment">//生成路径的条数 = 集合A代表节点的个数 * 集合B代表节点的个数</span></span><br><span class="line">    <span class="comment">//union时维护代表节点的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numberOfGoodPaths</span><span class="params">(<span class="type">int</span>[] vals, <span class="type">int</span>[][] edges)</span> &#123;</span><br><span class="line">        build(vals.length);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> vals.length;</span><br><span class="line">        <span class="comment">//核心排序，按边对接的点的最大值排序</span></span><br><span class="line">        Arrays.sort(edges, (e1, e2) -&gt; Math.max(vals[e1[<span class="number">0</span>]], vals[e1[<span class="number">1</span>]]) - Math.max(vals[e2[<span class="number">0</span>]], vals[e2[<span class="number">1</span>]]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; edges.length; i++) &#123;</span><br><span class="line">            <span class="comment">//联合边连接的两个点</span></span><br><span class="line">            ans += union(edges[i][<span class="number">0</span>], edges[i][<span class="number">1</span>], vals);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//核心代码</span></span><br><span class="line">    <span class="comment">//谁大谁是爸爸</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y, <span class="type">int</span>[] vals)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fx</span> <span class="operator">=</span> find(x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">fy</span> <span class="operator">=</span> find(y);</span><br><span class="line">        <span class="type">int</span> <span class="variable">path</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (vals[fx] &gt; vals[fy])&#123;</span><br><span class="line">            father[fy] = fx;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (vals[fy] &gt; vals[fx]) &#123;</span><br><span class="line">            father[fx] = fy;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//相同时计算路径结果</span></span><br><span class="line">            path = maxC[fx] * maxC[fy];</span><br><span class="line">            father[fx] = fy;</span><br><span class="line">            maxC[fy] += maxC[fx];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">            maxC[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i != father[i])&#123;</span><br><span class="line">            father[i] = find(father[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> father[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 并查集下 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集下 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FindAllPeople</title>
      <link href="/2024/07/04/FindAllPeople/"/>
      <url>/2024/07/04/FindAllPeople/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.并查集下;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/4 11:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 找出知晓秘密的所有专家</span></span><br><span class="line"><span class="comment">// 给你一个整数 n ，表示有 n 个专家从 0 到 n - 1 编号</span></span><br><span class="line"><span class="comment">// 另外给你一个下标从 0 开始的二维整数数组 meetings</span></span><br><span class="line"><span class="comment">// 其中 meetings[i] = [xi, yi, timei] 表示专家 xi 和专家 yi 在时间 timei 要开一场会</span></span><br><span class="line"><span class="comment">// 一个专家可以同时参加 多场会议 。最后，给你一个整数 firstPerson</span></span><br><span class="line"><span class="comment">// 专家 0 有一个 秘密 ，最初，他在时间 0 将这个秘密分享给了专家 firstPerson</span></span><br><span class="line"><span class="comment">// 接着，这个秘密会在每次有知晓这个秘密的专家参加会议时进行传播</span></span><br><span class="line"><span class="comment">// 更正式的表达是，每次会议，如果专家 xi 在时间 timei 时知晓这个秘密</span></span><br><span class="line"><span class="comment">// 那么他将会与专家 yi 分享这个秘密，反之亦然。秘密共享是 瞬时发生 的</span></span><br><span class="line"><span class="comment">// 也就是说，在同一时间，一个专家不光可以接收到秘密，还能在其他会议上与其他专家分享</span></span><br><span class="line"><span class="comment">// 在所有会议都结束之后，返回所有知晓这个秘密的专家列表</span></span><br><span class="line"><span class="comment">// 你可以按 任何顺序 返回答案</span></span><br><span class="line"><span class="comment">// 链接测试 : https://leetcode.cn/problems/find-all-people-with-secret/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindAllPeople</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">100001</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">boolean</span>[] secret = <span class="keyword">new</span> <span class="title class_">boolean</span>[MAIN];<span class="comment">//用来保存答案</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个没通过测试！！</span></span><br><span class="line">    <span class="comment">//怎么感觉很简单？ 用个set保存直到秘密的专家，两个专家开会，其中有个专家直到秘密，那就将另外一个专家放进来</span></span><br><span class="line">    <span class="comment">//专家会议，时间排序，遍历会议</span></span><br><span class="line">    <span class="comment">//凉凉，这不行，因为同一时间的情况下，先后知道秘密的顺序，排序不了，集合获取不了</span></span><br><span class="line">    <span class="comment">//感觉思路没问题，不知道为啥通不过</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAllPeople1</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] meetings, <span class="type">int</span> firstPerson)</span> &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        HashSet&lt;Integer&gt; curSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        ans.add(<span class="number">0</span>);</span><br><span class="line">        ans.add(firstPerson);</span><br><span class="line">        Arrays.sort(meetings, (m1, m2) -&gt; m1[<span class="number">2</span>]- m2[<span class="number">2</span>]);</span><br><span class="line">        <span class="type">int</span> <span class="variable">preT</span> <span class="operator">=</span> meetings[<span class="number">0</span>][<span class="number">2</span>];<span class="comment">//上一个会议的时间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; meetings.length; i++) &#123;</span><br><span class="line">            <span class="comment">//会议轮不同，则清空之前未连接的并查集</span></span><br><span class="line">            <span class="keyword">if</span> ( preT != meetings[i][<span class="number">2</span>])&#123;</span><br><span class="line">                clear(curSet);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ans.contains(meetings[i][<span class="number">0</span>]) || ans.contains(meetings[i][<span class="number">1</span>]))&#123;</span><br><span class="line">                ans.add(meetings[i][<span class="number">1</span>]);</span><br><span class="line">                ans.add(meetings[i][<span class="number">0</span>]);</span><br><span class="line">                <span class="comment">//把同一轮 其他未知密码的加上</span></span><br><span class="line">                <span class="keyword">if</span> (curSet.contains(meetings[i][<span class="number">0</span>]) || curSet.contains(meetings[i][<span class="number">1</span>]))&#123;</span><br><span class="line">                    <span class="keyword">for</span> (Integer integer : curSet) &#123;</span><br><span class="line">                        ans.add(integer);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                curSet.add(meetings[i][<span class="number">1</span>]);</span><br><span class="line">                curSet.add(meetings[i][<span class="number">0</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            preT = meetings[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(ans);</span><br><span class="line">        list.sort((i1, i2) -&gt; i1 - i2);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左神的思路</span></span><br><span class="line">    <span class="comment">//巧妙的地方在于用secret保存答案的结果，每个专家的结果都要去找father拿结果</span></span><br><span class="line">    <span class="comment">//为什么secret要用father去查？ 因为可能某次联合时，两个都是false，</span></span><br><span class="line">    <span class="comment">// 但下次联合时命中了，直接用sercet判断，那就漏了之前没命中轮的人了</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">findAllPeople</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[][] meetings, <span class="type">int</span> firstPerson)</span>&#123;</span><br><span class="line">        Arrays.sort(meetings, (m1,m2) -&gt; m1[<span class="number">2</span>] - m2[<span class="number">2</span>]);</span><br><span class="line">        build(n, firstPerson);</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> meetings.length;</span><br><span class="line">        <span class="comment">//遍历会议</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r; l &lt; m;) &#123;</span><br><span class="line">            r = l;</span><br><span class="line">            <span class="comment">//对同时间的会议构建并查集</span></span><br><span class="line">            <span class="keyword">while</span> (r + <span class="number">1</span> &lt; m &amp;&amp; meetings[l][<span class="number">2</span>] == meetings[r + <span class="number">1</span>][<span class="number">2</span>])&#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//为什么没写到上面一起呢？ 因为上面最后一个r没联合到，还不如直接在这里处理</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt;= r; i++) &#123;</span><br><span class="line">                <span class="comment">//联合当前会议的两人</span></span><br><span class="line">                union(meetings[i][<span class="number">0</span>], meetings[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//撤销l,r范围的不知道秘密的并查集，这一步才是全局的关键代码</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l, x, y; i &lt;= r; i++) &#123;</span><br><span class="line">                x = meetings[i][<span class="number">0</span>];</span><br><span class="line">                y = meetings[i][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (!secret[find(x)])&#123;</span><br><span class="line">                    father[x] = x;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!secret[find(y)])&#123;</span><br><span class="line">                    father[y] = y;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            l = r + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(n);</span><br><span class="line">        <span class="comment">//遍历获取答案</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (secret[find(i)])&#123;</span><br><span class="line">                ans.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">fx</span> <span class="operator">=</span> find(x);</span><br><span class="line">        <span class="type">int</span> <span class="variable">fy</span> <span class="operator">=</span> find(y);</span><br><span class="line">        <span class="keyword">if</span> (fx != fy) &#123;</span><br><span class="line">            father[fx] = fy;</span><br><span class="line">            secret[fy] |= secret[fx];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> firstPerson)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">            secret[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        father[firstPerson] = <span class="number">0</span>;</span><br><span class="line">        secret[<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        secret[firstPerson] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i != father[i])&#123;</span><br><span class="line">            father[i] = find(father[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> father[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">            secret[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">(HashSet&lt;Integer&gt; curSet)</span>&#123;</span><br><span class="line"><span class="comment">//        for (Integer i : curSet) &#123;</span></span><br><span class="line"><span class="comment">//            father[i] = i;</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">        curSet.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 并查集下 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集下 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RemoveStones</title>
      <link href="/2024/07/03/RemoveStones/"/>
      <url>/2024/07/03/RemoveStones/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.并查集下;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/3 15:47</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 移除最多的同行或同列石头</span></span><br><span class="line"><span class="comment">// n 块石头放置在二维平面中的一些整数坐标点上。每个坐标点上最多只能有一块石头</span></span><br><span class="line"><span class="comment">// 如果一块石头的 同行或者同列 上有其他石头存在，那么就可以移除这块石头</span></span><br><span class="line"><span class="comment">// 给你一个长度为 n 的数组 stones ，其中 stones[i] = [xi, yi] 表示第 i 块石头的位置</span></span><br><span class="line"><span class="comment">// 返回 可以移除的石子 的最大数量。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/most-stones-removed-with-same-row-or-column/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoveStones</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">int</span> sets;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//存储之前出现过的坐标 以及对应石头集合</span></span><br><span class="line">    <span class="comment">// 加速是否同列的判断，坐标 -》 石头编号</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Integer,Integer&gt; colMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;Integer,Integer&gt; rowMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer,Integer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个是自己的思路，复杂度O(n2)</span></span><br><span class="line">    <span class="comment">//第一感觉好像图的根据入度消除，从入度小的开始删除，但好像有点复杂</span></span><br><span class="line">    <span class="comment">//又根据题意例子，想了下并查集，如果都是同一个集合的话，总能消除到只剩一个石头</span></span><br><span class="line">    <span class="comment">//那这题就简单了，遍历所有石头，构建并查集</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeStones1</span><span class="params">(<span class="type">int</span>[][] stones)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> stones.length;</span><br><span class="line">        sets = n;</span><br><span class="line">        build(n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历每个石头对比是否同一集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (find(i) != find(j))&#123;</span><br><span class="line">                    <span class="comment">//判断是否同行 或 同列</span></span><br><span class="line">                    <span class="keyword">if</span> (isSame(i,j,stones))&#123;</span><br><span class="line">                        union(i, j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - sets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左神的思路，复杂度O(n)</span></span><br><span class="line">    <span class="comment">//用集合保存了遍历过的行、列，不用再搞for循环一一对比</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">removeStones</span><span class="params">(<span class="type">int</span>[][] stones)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> stones.length;</span><br><span class="line">        sets = n;</span><br><span class="line">        build(n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历每个石头对比是否同一集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">row</span> <span class="operator">=</span> stones[i][<span class="number">1</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">col</span> <span class="operator">=</span> stones[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (!rowMap.containsKey(row))&#123;</span><br><span class="line">                rowMap.put(row, i);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                union(i, rowMap.get(row));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!colMap.containsKey(col))&#123;</span><br><span class="line">                colMap.put(col, i);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                union(i, colMap.get(col));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - sets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSame</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[][] stones)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] stone1 = stones[i];</span><br><span class="line">        <span class="type">int</span>[] stone2 = stones[j];</span><br><span class="line">        <span class="comment">//同行或同列</span></span><br><span class="line">        <span class="keyword">return</span> stone2[<span class="number">0</span>] == stone1[<span class="number">0</span>] || stone2[<span class="number">1</span>] == stone1[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        rowMap.clear();</span><br><span class="line">        colMap.clear();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i != father[i])&#123;</span><br><span class="line">            father[i] = find(father[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> father[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> find(i);</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> find(j);</span><br><span class="line">        <span class="keyword">if</span> (x != y)&#123;</span><br><span class="line">            father[x] = y;</span><br><span class="line">            sets--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 并查集下 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集下 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NumSimilarGroups</title>
      <link href="/2024/07/02/NumSimilarGroups/"/>
      <url>/2024/07/02/NumSimilarGroups/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.并查集;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * 相似字符串组</span></span><br><span class="line"><span class="comment"> * 如果交换字符串 X 中的两个不同位置的字母，使得它和字符串 Y 相等</span></span><br><span class="line"><span class="comment"> * 那么称 X 和 Y 两个字符串相似</span></span><br><span class="line"><span class="comment"> * 如果这两个字符串本身是相等的，那它们也是相似的</span></span><br><span class="line"><span class="comment"> * 例如，&quot;tars&quot; 和 &quot;rats&quot; 是相似的 (交换 0 与 2 的位置)；</span></span><br><span class="line"><span class="comment"> * &quot;rats&quot; 和 &quot;arts&quot; 也是相似的，但是 &quot;star&quot; 不与 &quot;tars&quot;，&quot;rats&quot;，或 &quot;arts&quot; 相似</span></span><br><span class="line"><span class="comment"> * 总之，它们通过相似性形成了两个关联组：&#123;&quot;tars&quot;, &quot;rats&quot;, &quot;arts&quot;&#125; 和 &#123;&quot;star&quot;&#125;</span></span><br><span class="line"><span class="comment"> * 注意，&quot;tars&quot; 和 &quot;arts&quot; 是在同一组中，即使它们并不相似</span></span><br><span class="line"><span class="comment"> * 形式上，对每个组而言，要确定一个单词在组中，只需要这个词和该组中至少一个单词相似。</span></span><br><span class="line"><span class="comment"> * 给你一个字符串列表 strs列表中的每个字符串都是 strs 中其它所有字符串的一个字母异位词。</span></span><br><span class="line"><span class="comment"> * 返回 strs 中有多少字符串组</span></span><br><span class="line"><span class="comment"> * 测试链接 : https://leetcode.cn/problems/similar-string-groups/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/2 16:08</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumSimilarGroups</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">301</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> sets;<span class="comment">//并查集数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//没思路啊，感觉直接暴力for循环就可以了</span></span><br><span class="line">    <span class="comment">//和并查集有啥关系啊··</span></span><br><span class="line">    <span class="comment">//怎么加速字符串对比？ 算法用在加速哪个地方？完全没思路</span></span><br><span class="line">    <span class="comment">//看了左神思路，也一样是暴力遍历，虽然用到了并查集，但感觉没啥用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//原来我理解错题意了，原本以为是要求有多少个相似字符串对，题目是求多少个相似字符串组。。</span></span><br><span class="line">    <span class="comment">//那就很简单了，直接遍历+并查集</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSimilarGroups</span><span class="params">(String[] strs)</span> &#123;</span><br><span class="line">        <span class="comment">//直接暴力遍历，相似就联合进组，最后还剩几个并查集组就是答案</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> strs.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> strs[<span class="number">0</span>].length();</span><br><span class="line">        build(n);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (find(i) != find(j))&#123;<span class="comment">//不在同一个集合才进行</span></span><br><span class="line">                    <span class="comment">//相似就进组</span></span><br><span class="line">                    <span class="keyword">if</span> (isSimilar(strs[i], strs[j]))&#123;</span><br><span class="line">                        union(i,j);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        sets = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i != father[i])&#123;</span><br><span class="line">            father[i] = find(father[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> father[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> find(i);</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> find(j);</span><br><span class="line">        <span class="keyword">if</span> (x != y)&#123;</span><br><span class="line">            father[x] = father[y];</span><br><span class="line">            sets--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">isSimilar</span><span class="params">(String s1, String s2)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s2.length() &amp;&amp; diff &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.charAt(i) != s2.charAt(i))&#123;</span><br><span class="line">                diff++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> diff == <span class="number">0</span> || diff == <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 并查集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinSwapsCouples</title>
      <link href="/2024/07/02/MinSwapsCouples/"/>
      <url>/2024/07/02/MinSwapsCouples/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.并查集;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/7/2 14:11</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 情侣牵手</span></span><br><span class="line"><span class="comment">// n对情侣坐在连续排列的 2n 个座位上，想要牵到对方的手</span></span><br><span class="line"><span class="comment">// 人和座位由一个整数数组 row 表示，其中 row[i] 是坐在第 i 个座位上的人的ID</span></span><br><span class="line"><span class="comment">// 情侣们按顺序编号，第一对是 (0, 1)，第二对是 (2, 3)，以此类推，最后一对是 (2n-2, 2n-1)</span></span><br><span class="line"><span class="comment">// 返回 最少交换座位的次数，以便每对情侣可以并肩坐在一起</span></span><br><span class="line"><span class="comment">// 每次交换可选择任意两人，让他们站起来交换座位</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/couples-holding-hands/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinSwapsCouples</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">61</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> sets;<span class="comment">//并查集集合个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这题没啥思路，目前很难把并查集和实际应用起来</span></span><br><span class="line">    <span class="comment">//看了左神思路 》 把情侣编号，每对情侣对应每个编号 -》 每个编号即是一对情侣 对应并查集的一个元素</span></span><br><span class="line">    <span class="comment">//遍历时 将情侣都放进并查集中，每一个不同编号的情侣进来集合，就代表要交换一次</span></span><br><span class="line">    <span class="comment">//这个交换发生在 不同集合的联合过程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSwapsCouples</span><span class="params">(<span class="type">int</span>[] row)</span> &#123;</span><br><span class="line">        <span class="comment">//初始化并查集</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> row.length;</span><br><span class="line">        build(n / <span class="number">2</span>);</span><br><span class="line">        <span class="comment">//遍历联合集合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i+=<span class="number">2</span>) &#123;</span><br><span class="line">            union(row[i - <span class="number">1</span>] / <span class="number">2</span>, row[i] / <span class="number">2</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//答案怎么的来？</span></span><br><span class="line">        <span class="comment">//原本集合数量 - 剩余集合数量 = 交换次数</span></span><br><span class="line">        <span class="comment">//剩余集合数量？每次联合的时候 sets都会-1，</span></span><br><span class="line">        <span class="comment">//每次联合的时候即是不同编号情侣进来集合， sets--也可以理解为交换次数+1</span></span><br><span class="line">        <span class="keyword">return</span> n / <span class="number">2</span> - sets;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        sets = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> find(i);</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> find(j);</span><br><span class="line">        <span class="keyword">if</span> (x != y)&#123;</span><br><span class="line">            father[x] = y;</span><br><span class="line">            sets--;<span class="comment">//每次联合 集合数量都减少</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i != father[i])&#123;</span><br><span class="line">            father[i] = find(father[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> father[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 并查集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UnionFind</title>
      <link href="/2024/06/27/UnionFind/"/>
      <url>/2024/06/27/UnionFind/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.并查集;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/6/27 16:06</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 并查集模版(牛客)</span></span><br><span class="line"><span class="comment">// 路径压缩 + 小挂大</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.nowcoder.com/practice/e7ed657974934a30b2010046536a5372</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UnionFind</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">1000001</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] father = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> N;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        N = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">String</span> <span class="variable">line</span>  <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> ((line = in.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            String[] s = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            N = Integer.parseInt(s[<span class="number">0</span>]);</span><br><span class="line">            M = Integer.parseInt(s[<span class="number">1</span>]);</span><br><span class="line">            build();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; M; i++) &#123;</span><br><span class="line">                line = in.readLine();</span><br><span class="line">                s = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">option</span> <span class="operator">=</span> Integer.parseInt(s[<span class="number">0</span>]);</span><br><span class="line">                <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> Integer.parseInt(s[<span class="number">1</span>]);</span><br><span class="line">                <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> Integer.parseInt(s[<span class="number">2</span>]);</span><br><span class="line">                <span class="keyword">if</span> (option == <span class="number">1</span>)&#123;</span><br><span class="line">                    out.println(isSameSet(x,y)?<span class="string">&quot;Yes&quot;</span>:<span class="string">&quot;No&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    union(x,y);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            father[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查某个数的代表节点</span></span><br><span class="line">    <span class="comment">//递归调用 找最上节点</span></span><br><span class="line">    <span class="comment">//路径扁平化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span>  <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="comment">//不对就找爸爸</span></span><br><span class="line">        <span class="keyword">if</span> (i != father[i])&#123;</span><br><span class="line">            father[i] = find(father[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> father[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询a和b这两个数是否属于一个集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSameSet</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> find(a) == find(b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//把a所在的集合与b所在的集合合并在一起，原本两个集合各自的元素以后都算作同一个集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">union</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        father[find(a)] = find(b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 并查集 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 并查集 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MaxTaskAssign</title>
      <link href="/2024/06/21/MaxTaskAssign/"/>
      <url>/2024/06/21/MaxTaskAssign/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.单调队列II;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/6/21 12:17</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 你可以安排的最多任务数目</span></span><br><span class="line"><span class="comment">// 给你 n 个任务和 m 个工人。每个任务需要一定的力量值才能完成</span></span><br><span class="line"><span class="comment">// 需要的力量值保存在下标从 0 开始的整数数组 tasks 中，</span></span><br><span class="line"><span class="comment">// 第i个任务需要 tasks[i] 的力量才能完成</span></span><br><span class="line"><span class="comment">// 每个工人的力量值保存在下标从 0 开始的整数数组workers中，</span></span><br><span class="line"><span class="comment">// 第j个工人的力量值为 workers[j]</span></span><br><span class="line"><span class="comment">// 每个工人只能完成一个任务，且力量值需要大于等于该任务的力量要求值，即workers[j]&gt;=tasks[i]</span></span><br><span class="line"><span class="comment">// 除此以外，你还有 pills 个神奇药丸，可以给 一个工人的力量值 增加 strength</span></span><br><span class="line"><span class="comment">// 你可以决定给哪些工人使用药丸，但每个工人 最多 只能使用 一片 药丸</span></span><br><span class="line"><span class="comment">// 给你下标从 0 开始的整数数组tasks 和 workers 以及两个整数 pills 和 strength</span></span><br><span class="line"><span class="comment">// 请你返回 最多 有多少个任务可以被完成。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/maximum-number-of-tasks-you-can-assign/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxTaskAssign</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">50001</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] deque = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> h, t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//二分答案 + 贪心 + 单调队列</span></span><br><span class="line">    <span class="comment">//题目很明显，总有答案（完成的任务为 0 - 数组长度），需要完成的任务越多，工人需要越多  即答案和题目条件之间符合单调性</span></span><br><span class="line">    <span class="comment">// 贪心策略完成任务： 在给定的任务数量下， 在力量值大于最小任务的工人里， 优先用力量小的工人完成能量小的任务</span></span><br><span class="line">    <span class="comment">//当给工人吃药时，优先完成能量大的任务</span></span><br><span class="line">    <span class="comment">//队列从小到大  队列何时入队呢？</span></span><br><span class="line">    <span class="comment">//工人力量值 大于 当前数值值，队列尾入队</span></span><br><span class="line">    <span class="comment">//工人不吃药能完成队头任务，则队头出队</span></span><br><span class="line">    <span class="comment">//工人吃药后，任务要再次入队，工人优先完成队尾任务</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxTaskAssign</span><span class="params">(<span class="type">int</span>[] tasks, <span class="type">int</span>[] workers, <span class="type">int</span> pills, <span class="type">int</span> strength)</span> &#123;</span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        Arrays.sort(tasks);</span><br><span class="line">        Arrays.sort(workers);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//二分答案</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> Math.min(tasks.length, workers.length);</span><br><span class="line">        <span class="type">int</span> m;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            m = l +  ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (ok(m, tasks, workers, pills, strength))&#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">                ans = m;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">ok</span><span class="params">(<span class="type">int</span> len, <span class="type">int</span>[] tasks, <span class="type">int</span>[] workers, <span class="type">int</span> pills, <span class="type">int</span> strength)</span>&#123;</span><br><span class="line">        <span class="comment">//工人数量小于任务数量</span></span><br><span class="line">        <span class="keyword">if</span> (workers.length &lt; len)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        h = t = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//工人开始位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">wl</span> <span class="operator">=</span> workers.length - len;</span><br><span class="line">        <span class="comment">//针对每个任务，用工人去完成</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> wl, i = <span class="number">0</span>; r &lt; workers.length; r++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//所有小于当前工人能力值的任务入队</span></span><br><span class="line">            <span class="comment">//因为后续工人能力值肯定大于这些任务</span></span><br><span class="line">            <span class="keyword">while</span> (i &lt; len &amp;&amp; tasks[i] &lt;= workers[r])&#123;</span><br><span class="line">                deque[t++] = tasks[i++];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不吃药的情况下，能否完成任务</span></span><br><span class="line">            <span class="keyword">if</span> (h &lt; t &amp;&amp; workers[r] &gt;= deque[h])&#123;</span><br><span class="line">                h++;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//没药吃了</span></span><br><span class="line">                <span class="keyword">if</span> (pills &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//吃药了 重新入队</span></span><br><span class="line">                pills--;</span><br><span class="line">                <span class="comment">//把所有小于当前吃药工人能力值的任务都入队</span></span><br><span class="line">                <span class="comment">//因为后续所有吃药的工人肯定大于这些任务</span></span><br><span class="line">                <span class="keyword">while</span> (i &lt; len &amp;&amp; tasks[i] &lt;= workers[r] + strength)&#123;</span><br><span class="line">                    deque[t++] = tasks[i++];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//看当前工人能否完成任务</span></span><br><span class="line">                <span class="comment">//吃了药，从队尾拿任务做</span></span><br><span class="line">                <span class="keyword">if</span> (h &lt; t &amp;&amp; workers[r] + strength &gt;= deque[t - <span class="number">1</span>])&#123;</span><br><span class="line">                    t--;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">// 吃了药都完成不了任务，那就完不成目标任务数量了</span></span><br><span class="line">                    <span class="comment">// 那更前面的工人肯定都完不成任务了</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] task = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] works = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">3</span>, <span class="number">3</span>&#125;;</span><br><span class="line">        System.out.println(maxTaskAssign(task, works, <span class="number">1</span>, <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 单调队列II </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列II </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FindMaxValueOfEquation</title>
      <link href="/2024/06/20/FindMaxValueOfEquation/"/>
      <url>/2024/06/20/FindMaxValueOfEquation/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.单调队列II;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>  困难</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/6/20 14:54</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 满足不等式的最大值</span></span><br><span class="line"><span class="comment">// 给你一个数组 points 和一个整数 k</span></span><br><span class="line"><span class="comment">// 数组中每个元素都表示二维平面上的点的坐标，并按照横坐标 x 的值从小到大排序</span></span><br><span class="line"><span class="comment">// 也就是说 points[i] = [xi, yi]</span></span><br><span class="line"><span class="comment">// 并且在 1 &lt;= i &lt; j &lt;= points.length 的前提下，xi &lt; xj 总成立</span></span><br><span class="line"><span class="comment">// 请你找出 yi + yj + |xi - xj| 的 最大值，</span></span><br><span class="line"><span class="comment">// 其中 |xi - xj| &lt;= k 且 1 &lt;= i &lt; j &lt;= points.length</span></span><br><span class="line"><span class="comment">// 题目测试数据保证至少存在一对能够满足 |xi - xj| &lt;= k 的点。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/max-value-of-equation/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindMaxValueOfEquation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">100001</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] deque1 = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] deque2 = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> h1,t1,h2,t2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//思路错了</span></span><br><span class="line">    <span class="comment">//大体想法：在滑动指针的框架下，保持窗口内的 yi-xi 最大值</span></span><br><span class="line">    <span class="comment">//滑动指针单调性分析： (xj - xi) 一定大于0，对于某点xi 来说，xj越往后，xj - xi的结果越大，所以符合单调递增</span></span><br><span class="line">    <span class="comment">// 转为分析 yi-xi + yj+xj最大值，可见yj+xj 是固定的后一个点的值。</span></span><br><span class="line">    <span class="comment">//如果保持 在符合条件下 保持窗口内yi-xi 和 yj+xj的最大值，那答案一定是两队头部相加</span></span><br><span class="line">    <span class="comment">//我感觉思路是对的，但做不出来呜呜呜。下面题解是错的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findMaxValueOfEquation1</span><span class="params">(<span class="type">int</span>[][] arr, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"></span><br><span class="line">        t1 = t2 = h2 = h1 = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//先让首个差值入队</span></span><br><span class="line">        deque1[t1++] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//y1-x1大到小入队</span></span><br><span class="line">        <span class="comment">//y2+x2 大到小入队</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">1</span>, l = <span class="number">0</span>, diff, sum, pre = -<span class="number">1</span>; r &lt; arr.length; r++) &#123;</span><br><span class="line">            diff = arr[r][<span class="number">1</span>] - arr[r][<span class="number">0</span>];</span><br><span class="line">            sum = arr[r][<span class="number">1</span>]  +  arr[r][<span class="number">0</span>];</span><br><span class="line">            <span class="comment">//右扩</span></span><br><span class="line">            <span class="comment">// 更新队尾</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; h1 &lt; t1 &amp;&amp; arr[deque1[t1 - <span class="number">1</span>]][<span class="number">1</span>] - arr[deque1[t1 - <span class="number">1</span>]][<span class="number">0</span>]  &lt; diff)&#123;</span><br><span class="line">                t1--;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            while (l &lt; r &amp;&amp; h2 &lt; t2 &amp;&amp; arr[deque2[t2 - 1]][1] + arr[deque2[t2 - 1]][0]  &lt; sum)&#123;</span></span><br><span class="line"><span class="comment">//                t2--;</span></span><br><span class="line"><span class="comment">//            &#125;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//入队</span></span><br><span class="line">            deque1[t1++] = r;</span><br><span class="line"><span class="comment">//            deque2[t2++] = r;</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 不符合条件左缩</span></span><br><span class="line">            <span class="comment">// 更新队头</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[r][<span class="number">0</span>] - arr[l][<span class="number">0</span>] &gt; k)&#123;</span><br><span class="line">                <span class="keyword">if</span> (l == deque1[h1])&#123;</span><br><span class="line">                    h1++;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                if (l == deque2[h2])&#123;</span></span><br><span class="line"><span class="comment">//                    h2++;</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            pre = pre == deque1[t1 - 1] ? pre : deque1[h1];</span></span><br><span class="line">            <span class="keyword">if</span> (l &gt; pre)&#123;</span><br><span class="line">                pre = deque1[h1];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//更新答案</span></span><br><span class="line">            <span class="keyword">if</span> (l &lt; r )&#123;</span><br><span class="line">                diff = arr[pre][<span class="number">1</span>] - arr[pre][<span class="number">0</span>];</span><br><span class="line"><span class="comment">//                sum = arr[deque2[h2]][1] + arr[deque2[h2]][0] : 0;</span></span><br><span class="line">                ans = Math.max(ans, sum + diff);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//保留符合条件的窗口下的上一个最大值</span></span><br><span class="line">            pre = deque1[h1];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//思维固化了，总是想用滑动窗口 + 单调队列来解题</span></span><br><span class="line">    <span class="comment">//以下思路是：</span></span><br><span class="line">    <span class="comment">//针对某点j，j前面的点i拿符合条件下 最大的 y-x,则是点j这一点的最优值</span></span><br><span class="line">    <span class="comment">//所以用单调队列记录 符合条件的范围内[....j） 中y-x的单调性</span></span><br><span class="line">    <span class="comment">//当队头和当前点j 不符合条件时， 队头出队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findMaxValueOfEquation</span><span class="params">(<span class="type">int</span>[][] arr, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        h1 = t1 = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>, diff, sum; r &lt; arr.length; r++) &#123;</span><br><span class="line">            sum = arr[r][<span class="number">0</span>] + arr[r][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">//不符合条件 队头出队</span></span><br><span class="line">            <span class="keyword">while</span> (h1 &lt; t1 &amp;&amp; arr[r][<span class="number">0</span>] - arr[deque1[h1]][<span class="number">0</span>] &gt; k)&#123;</span><br><span class="line">                h1++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//要在当前位置更新队列前  否则队头可能会被更掉</span></span><br><span class="line">            <span class="comment">//更新答案</span></span><br><span class="line">            <span class="keyword">if</span> (h1 &lt; t1)&#123;</span><br><span class="line">                diff = arr[deque1[h1]][<span class="number">1</span>] - arr[deque1[h1]][<span class="number">0</span>];</span><br><span class="line">                ans = Math.max(ans, sum + diff);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//入队</span></span><br><span class="line">            diff = arr[r][<span class="number">1</span>] -  arr[r][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">while</span> (h1 &lt; t1 &amp;&amp; diff &gt;= arr[deque1[t1 - <span class="number">1</span>]][<span class="number">1</span>] - arr[deque1[t1 - <span class="number">1</span>]][<span class="number">0</span>])&#123;</span><br><span class="line">                t1--;</span><br><span class="line">            &#125;</span><br><span class="line">            deque1[t1++] = r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">5</span>][<span class="number">2</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">17</span>,<span class="number">5</span>&#125;;</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">10</span>,-<span class="number">8</span>&#125;;</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">5</span>,-<span class="number">13</span>&#125;;</span><br><span class="line">        arr[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">2</span>,<span class="number">7</span>&#125;;</span><br><span class="line">        arr[<span class="number">4</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">8</span>,-<span class="number">14</span>&#125;;</span><br><span class="line">        System.out.println(findMaxValueOfEquation(arr, <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 单调队列II </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列II </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ShortestSubarray</title>
      <link href="/2024/06/19/ShortestSubarray/"/>
      <url>/2024/06/19/ShortestSubarray/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.单调队列II;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span>  困难</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/6/19 17:00</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 和至少为K的最短子数组</span></span><br><span class="line"><span class="comment">// 给定一个数组arr，其中的值有可能正、负、0</span></span><br><span class="line"><span class="comment">// 给定一个正数k</span></span><br><span class="line"><span class="comment">// 返回累加和&gt;=k的所有子数组中，最短的子数组长度</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/shortest-subarray-with-sum-at-least-k/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ShortestSubarray</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这题好难</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">100001</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] deque = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> h, t;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span>[] sum = <span class="keyword">new</span> <span class="title class_">long</span>[MAIN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原思路：</span></span><br><span class="line">    <span class="comment">//思路错了~~~   这里不能用滑动窗口，不符合单调性</span></span><br><span class="line">    <span class="comment">//题目关键字，数组和 -》很容易想到前缀和解法。</span></span><br><span class="line">    <span class="comment">//再根据题意，滑动窗口也得用上。</span></span><br><span class="line">    <span class="comment">//由于要保留答案的可能性，而窗口右扩又不能回退，所以再加上单调队列</span></span><br><span class="line">    <span class="comment">//分析单调队列：</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//看了左神讲解的思路：</span></span><br><span class="line">    <span class="comment">//对于某个数i，往前多长的子数组和 能否符合条件。   这思路是真没到</span></span><br><span class="line">    <span class="comment">//前缀和是用来加速求和的</span></span><br><span class="line">    <span class="comment">//即 （0...k...x...) 若对于某数x，往前到k的位置的子数组符合条件，即sum(x) - sum(k) &gt; limit</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//简单来说就是在已经符合条件的前缀和X中，尽可能缩短子数组长度，</span></span><br><span class="line">    <span class="comment">// 而缩短长度的方法是判断 sum(x) - sum(k) &gt; limit ?</span></span><br><span class="line">    <span class="comment">//即求的是k的位置，即k位置越靠近x，则答案越小</span></span><br><span class="line">    <span class="comment">//单调队列就是用来增大k位置的。  单调队列 按照从 小 到 大 的前缀和排序</span></span><br><span class="line">    <span class="comment">//让sum(x) 逐渐 扣减 队头，再符合条件的答案中，缩小答案</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//好难想啊，有想到要用前缀和，但没想到单调队列怎么用上前缀和。主要是解题的大思路没想到</span></span><br><span class="line">    <span class="comment">//按照普通思维，也想到要在符合条件的前缀和中，尽可能的缩小答案，但没想到做法··</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">shortestSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        h = t = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//前缀和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum[i + <span class="number">1</span>] = sum[i] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//单调队列 按照从 小 到 大 的前缀和排序</span></span><br><span class="line">        <span class="comment">//这里前缀和序号是比原数组小1的，所以注意这里要遍历到数组长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt;= nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//判断当前前缀和 减去队头  是否符合限制</span></span><br><span class="line">            <span class="keyword">while</span> (h &lt; t &amp;&amp; sum[i] - sum[deque[h]] &gt;= k)&#123;</span><br><span class="line">                <span class="comment">//逐渐缩短答案范围</span></span><br><span class="line">                <span class="comment">//更新队列头</span></span><br><span class="line">                ans = Math.min(ans, i - deque[h++]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新队尾 当前前缀和入队</span></span><br><span class="line">            <span class="keyword">while</span> (h &lt; t &amp;&amp; sum[i] &lt;= sum[deque[t - <span class="number">1</span>]])&#123;</span><br><span class="line">                t--;</span><br><span class="line">            &#125;</span><br><span class="line">            deque[t++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 单调队列II </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列II </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LongestSubarray</title>
      <link href="/2024/06/19/LongestSubarray/"/>
      <url>/2024/06/19/LongestSubarray/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.单调队列;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/6/19 15:09</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongestSubarray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">100001</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] minDeque = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] maxDeque = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> minH;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> minT;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> maxH;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> maxT;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有个想法</span></span><br><span class="line">    <span class="comment">//滑动窗口，用单调队列维持窗口内的最大值和最小值。</span></span><br><span class="line">    <span class="comment">// 当两值差值大于 limit，窗口左缩，队列头部是否要出队，取决于当前窗口左区间坐标是否大于队列头部值</span></span><br><span class="line">    <span class="comment">//窗口右扩滑动时，按照单调性正常入队</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubarray1</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        minH = minT = maxT = maxH = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//滑动窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>; r &lt; arr.length; r++) &#123;</span><br><span class="line">            <span class="comment">//先入队，更新队列</span></span><br><span class="line">            <span class="comment">//更新队列  当前数小于队列尾  队尾出队</span></span><br><span class="line">            <span class="keyword">while</span> (minH &lt; minT &amp;&amp; arr[r] &lt; arr[minDeque[minT - <span class="number">1</span>]])&#123;</span><br><span class="line">                minT--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当前数大于队列尾 队尾出队</span></span><br><span class="line">            <span class="keyword">while</span> (maxH &lt; maxT &amp;&amp; arr[r] &gt; arr[maxDeque[maxT - <span class="number">1</span>]])&#123;</span><br><span class="line">                maxT--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//入队</span></span><br><span class="line">            maxDeque[maxT++] = r;</span><br><span class="line">            minDeque[minT++] = r;</span><br><span class="line">            <span class="comment">//看队头，是否需要左缩</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r &amp;&amp; minH &lt; minT &amp;&amp; maxH &lt; maxT</span><br><span class="line">                    &amp;&amp; arr[maxDeque[maxH]] - arr[minDeque[minH]] &gt; limit)&#123;</span><br><span class="line">                <span class="comment">//左缩的同时，判断出去的是否是队列头。同时更新队列头</span></span><br><span class="line">                <span class="keyword">if</span> (l == minDeque[minH])&#123;</span><br><span class="line">                    minH++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (l == maxDeque[maxH])&#123;</span><br><span class="line">                    maxH++;</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新答案</span></span><br><span class="line">            ans = Math.max(ans, r - l + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//在右扩</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubarray</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        minH = minT = maxT = maxH = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//滑动窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>; r &lt; arr.length; l++) &#123;</span><br><span class="line">            <span class="comment">//右扩</span></span><br><span class="line">            <span class="comment">//原本我的想法是定左右扩的，但是右扩这里有个坑</span></span><br><span class="line">            <span class="comment">//因为右扩的前提是队列头满足限制，但是不右扩又不能入队</span></span><br><span class="line">            <span class="comment">//所以这里只能定右左缩 (看了左神代码后，修正为以下）</span></span><br><span class="line">            <span class="comment">//右扩的条件：将队头和即将要进来的数字做对比，看谁大并判断是否满足条件</span></span><br><span class="line">            <span class="keyword">while</span> (r &lt; arr.length &amp;&amp; ok(arr, limit, arr[r]))&#123;</span><br><span class="line">                <span class="comment">//更新队列  当前数小于队列尾  队尾出队</span></span><br><span class="line">                <span class="keyword">while</span> (minH &lt; minT &amp;&amp; arr[r] &lt; arr[minDeque[minT - <span class="number">1</span>]])&#123;</span><br><span class="line">                    minT--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//当前数大于队列尾 队尾出队</span></span><br><span class="line">                <span class="keyword">while</span> (maxH &lt; maxT &amp;&amp; arr[r] &gt; arr[maxDeque[maxT - <span class="number">1</span>]])&#123;</span><br><span class="line">                    maxT--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//入队</span></span><br><span class="line">                maxDeque[maxT++] = r;</span><br><span class="line">                minDeque[minT++] = r;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//记录答案</span></span><br><span class="line">            ans = Math.max(ans, r - l);</span><br><span class="line">            <span class="comment">//左缩  经过上面，这里肯定不满足条件</span></span><br><span class="line">            <span class="comment">//更新队列头</span></span><br><span class="line">            <span class="keyword">if</span> (l == minDeque[minH])&#123;</span><br><span class="line">                minH++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (l == maxDeque[maxH])&#123;</span><br><span class="line">                maxH++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">ok</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> limit, <span class="type">int</span> number)</span>&#123;</span><br><span class="line">        <span class="comment">//将队头和即将要进来的数字做对比，看谁大并判断是否满足条件</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(minH &lt; minT ? arr[minDeque[minH]] : number, number);</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.max(maxH &lt; maxT ? arr[maxDeque[maxH]] : number, number);</span><br><span class="line">        <span class="keyword">return</span> max - min &lt;= limit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 单调队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FallingWaterSmallestFlowerPot</title>
      <link href="/2024/06/19/FallingWaterSmallestFlowerPot/"/>
      <url>/2024/06/19/FallingWaterSmallestFlowerPot/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.单调队列;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/6/19 11:22</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接取落水的最小花盆</span></span><br><span class="line"><span class="comment">// 老板需要你帮忙浇花。给出 N 滴水的坐标，y 表示水滴的高度，x 表示它下落到 x 轴的位置</span></span><br><span class="line"><span class="comment">// 每滴水以每秒1个单位长度的速度下落。你需要把花盆放在 x 轴上的某个位置</span></span><br><span class="line"><span class="comment">// 使得从被花盆接着的第 1 滴水开始，到被花盆接着的最后 1 滴水结束，之间的时间差至少为 D</span></span><br><span class="line"><span class="comment">// 我们认为，只要水滴落到 x 轴上，与花盆的边沿对齐，就认为被接住</span></span><br><span class="line"><span class="comment">// 给出 N 滴水的坐标和 D 的大小，请算出最小的花盆的宽度 W</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P2698</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FallingWaterSmallestFlowerPot</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//看了8分钟才看懂题目·····</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">1000001</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span>  <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] minDeque = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] maxDeque = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> minH, minT, maxH, maxT;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="type">int</span> N, D;</span><br><span class="line">        <span class="keyword">while</span> ((line = bf.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            String[] sarr = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            N = Integer.parseInt(sarr[<span class="number">0</span>]);</span><br><span class="line">            D = Integer.parseInt(sarr[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                line = bf.readLine();</span><br><span class="line">                sarr = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                arr[i][<span class="number">0</span>] = Integer.parseInt(sarr[<span class="number">0</span>]);</span><br><span class="line">                arr[i][<span class="number">1</span>] = Integer.parseInt(sarr[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(compute(N, D));</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        bf.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//滑动窗口单调性的讨论；</span></span><br><span class="line">    <span class="comment">//对x排序，对答案进行单调性讨论</span></span><br><span class="line">    <span class="comment">//很容易得知，x越往后的答案，越大。题目要的是最小的宽度，所以对x从小到大排序</span></span><br><span class="line">    <span class="comment">//这里为啥不对y进行单调性分析呢？ 因为题目要求的答案是和x直接关联，所以直接对答案x进行单调性讨论</span></span><br><span class="line">    <span class="comment">//策略：定右缩左。 满足条件则缩，不满足则扩</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//为啥要用上单调队列保留答案的可能性呢？</span></span><br><span class="line">    <span class="comment">//因为答案求的是最小的花盆宽度，且没要求雨滴高度的极值，</span></span><br><span class="line">    <span class="comment">// 所以当对某个x来说，右扩时满足条件的话，此时一定是最小宽度</span></span><br><span class="line">    <span class="comment">//但针对下一个点x1来说，右扩不可退回，即失去了右扩点y到当前点x1之间的答案的可能性</span></span><br><span class="line">    <span class="comment">//所以需要用单调队列保留这些答案的可能性</span></span><br><span class="line">    <span class="comment">//单调队列要存什么值呢？  依据题意，单调队列中高度y要满足窗口内的最大值 - 最小值 要符合限制D.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//由此可见，思路很清晰了：</span></span><br><span class="line">    <span class="comment">//滑动窗口 + 单调队列</span></span><br><span class="line">    <span class="comment">//满足条件则缩，不满足则扩</span></span><br><span class="line">    <span class="comment">//两个单调队列存储窗口内最大最小值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">(<span class="type">int</span> N, <span class="type">int</span> D)</span> &#123;</span><br><span class="line">        Arrays.sort(arr,<span class="number">0</span>, N, (a, b) -&gt; a[<span class="number">0</span>] - b[<span class="number">0</span>]);</span><br><span class="line">        minH = minT = maxH = maxT = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>, l = <span class="number">0</span>; r &lt; N; r++) &#123;</span><br><span class="line">            <span class="comment">//更新队尾</span></span><br><span class="line">            <span class="keyword">while</span> (minH &lt; minT &amp;&amp; arr[r][<span class="number">1</span>] &lt; arr[minDeque[minT - <span class="number">1</span>]][<span class="number">1</span>])&#123;</span><br><span class="line">                minT--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (maxH &lt; maxT &amp;&amp; arr[r][<span class="number">1</span>] &gt; arr[maxDeque[maxT - <span class="number">1</span>]][<span class="number">1</span>])&#123;</span><br><span class="line">                maxT--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//入队</span></span><br><span class="line">            minDeque[minT++] = r;</span><br><span class="line">            maxDeque[maxT++] = r;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//左缩 判断当前窗口是否符合条件</span></span><br><span class="line">            <span class="keyword">while</span> (l &lt; r &amp;&amp; arr[maxDeque[maxH]][<span class="number">1</span>] - arr[minDeque[minH]][<span class="number">1</span>] &gt;= D)&#123;</span><br><span class="line">                <span class="comment">//更新队头</span></span><br><span class="line">                <span class="keyword">if</span> (l == maxDeque[maxH])&#123;</span><br><span class="line">                    maxH++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (l == minDeque[minH])&#123;</span><br><span class="line">                    minH++;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//更新答案</span></span><br><span class="line">                ans = Math.min(arr[r][<span class="number">0</span>] - arr[l][<span class="number">0</span>], ans);</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main1</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>][<span class="number">2</span>];</span><br><span class="line">        arr[<span class="number">0</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">6</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        arr[<span class="number">1</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>,<span class="number">4</span>&#125;;</span><br><span class="line">        arr[<span class="number">2</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">4</span>,<span class="number">10</span>&#125;;</span><br><span class="line">        arr[<span class="number">3</span>] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">12</span>,<span class="number">15</span>&#125;;</span><br><span class="line"></span><br><span class="line">        System.out.println(compute(<span class="number">4</span>, <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 单调队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MaxSlidingWindow</title>
      <link href="/2024/06/18/MaxSlidingWindow/"/>
      <url>/2024/06/18/MaxSlidingWindow/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.单调队列;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/6/18 17:35</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 滑动窗口最大值（单调队列经典用法模版）</span></span><br><span class="line"><span class="comment">// 给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧</span></span><br><span class="line"><span class="comment">// 你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</span></span><br><span class="line"><span class="comment">// 返回 滑动窗口中的最大值 。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/sliding-window-maximum/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxSlidingWindow</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">100001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] deque = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> ql, qr;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> h, t;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//思考：这题为什么能用单调队列呢？</span></span><br><span class="line">    <span class="comment">//根据题意，</span></span><br><span class="line">    <span class="comment">// 1、要的是所有窗口的最大值，即保持答案的单调性</span></span><br><span class="line">    <span class="comment">//2、被淘汰掉的元素，对后续求解没有帮助</span></span><br><span class="line">    <span class="comment">//例如；nums = [1,3,-1,-3,5,3,6,7], k = 3</span></span><br><span class="line">    <span class="comment">//  入队时，淘汰掉的1，不是最大值 且 &lt;靠前&gt;， 所以对后续答案求解没帮助</span></span><br><span class="line">    <span class="comment">// 即 符合单调队列中淘汰掉的元素对 后续答案求解没用，符合单调队列的特性</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//总结：</span></span><br><span class="line">    <span class="comment">//1、根据题意，先写个滑动窗口大体模板。</span></span><br><span class="line">    <span class="comment">//2、再此基础上，配合 窗口的左缩右扩，写出队、入队的逻辑</span></span><br><span class="line">    <span class="comment">//左缩：头部出队</span></span><br><span class="line">    <span class="comment">//右扩：保持队列单调性尾部出队、再入队</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//自己写的，感觉太多冗余代码，不够模板化</span></span><br><span class="line">    <span class="comment">//但没想到和左神的差不多嘿嘿嘿</span></span><br><span class="line">    <span class="comment">//思路：利用单调队列的特性，保留答案的可能性</span></span><br><span class="line">    <span class="comment">//从大到小，尾进，两头出。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        ql = qr = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//先加入队列吧</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">            <span class="comment">//出队列</span></span><br><span class="line">            <span class="comment">//当前数大于队列尾</span></span><br><span class="line">            <span class="keyword">while</span> (qr &gt; ql &amp;&amp; nums[i] &gt; deque[qr - <span class="number">1</span>])&#123;</span><br><span class="line">                qr--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//入队</span></span><br><span class="line">            deque[qr++] = nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        ans[cur++] = deque[ql];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = k; r &lt; nums.length; r++,l++) &#123;</span><br><span class="line">            <span class="comment">//左缩</span></span><br><span class="line">            <span class="comment">//如果出队的是队列头，出队</span></span><br><span class="line">            <span class="keyword">if</span> (nums[l] == deque[ql])&#123;</span><br><span class="line">                ql++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//右扩</span></span><br><span class="line">            <span class="keyword">while</span> (qr &gt; ql &amp;&amp; nums[r] &gt; deque[qr - <span class="number">1</span>])&#123;</span><br><span class="line">                qr--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//入队</span></span><br><span class="line">            deque[qr++] = nums[r];</span><br><span class="line">            <span class="comment">//更新答案</span></span><br><span class="line">            ans[cur++] = deque[ql];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左神的代码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] maxSlidingWindow2(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">        h = t = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="comment">// 先形成长度为k-1的窗口</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// 大 -&gt; 小</span></span><br><span class="line">            <span class="keyword">while</span> (h &lt; t &amp;&amp; arr[deque[t - <span class="number">1</span>]] &lt;= arr[i]) &#123;</span><br><span class="line">                t--;</span><br><span class="line">            &#125;</span><br><span class="line">            deque[t++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> n - k + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[m];</span><br><span class="line">        <span class="comment">// 当前窗口k-1长度</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = k - <span class="number">1</span>; l &lt; m; l++, r++) &#123;</span><br><span class="line">            <span class="comment">// 少一个，要让r位置的数进来</span></span><br><span class="line">            <span class="keyword">while</span> (h &lt; t &amp;&amp; arr[deque[t - <span class="number">1</span>]] &lt;= arr[r]) &#123;</span><br><span class="line">                t--;</span><br><span class="line">            &#125;</span><br><span class="line">            deque[t++] = r;</span><br><span class="line">            <span class="comment">// 收集答案</span></span><br><span class="line">            ans[l] = arr[deque[h]];</span><br><span class="line">            <span class="comment">// l位置的数出去</span></span><br><span class="line">            <span class="keyword">if</span> (deque[h] == l) &#123;</span><br><span class="line">                h++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 单调队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MaximalRectangle</title>
      <link href="/2024/06/17/MaximalRectangle/"/>
      <url>/2024/06/17/MaximalRectangle/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.单调栈;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/6/17 18:13</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最大矩形</span></span><br><span class="line"><span class="comment">// 给定一个仅包含 0 和 1 、大小为 rows * cols 的二维二进制矩阵</span></span><br><span class="line"><span class="comment">// 找出只包含 1 的最大矩形，并返回其面积</span></span><br><span class="line"><span class="comment">// 测试链接：https://leetcode.cn/problems/maximal-rectangle/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaximalRectangle</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">201</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] stack = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将矩阵处理下，转为单调栈求矩形面积题目</span></span><br><span class="line">    <span class="comment">//处理每一列的1，当前列是0则为0，当前列是1则加上前面的值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maximalRectangle</span><span class="params">(<span class="type">char</span>[][] matrix)</span> &#123;</span><br><span class="line">        <span class="comment">//处理矩阵</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> matrix[<span class="number">0</span>].length;</span><br><span class="line">        Arrays.fill(arr, <span class="number">0</span>, m, <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//每一层求一次面积</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; matrix.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line"><span class="comment">//                arr[j] = (matrix[i][j] - &#x27;0&#x27;) == 0 ? 0 : arr[j] + (matrix[i][j] - &#x27;0&#x27;);</span></span><br><span class="line">                arr[j] = matrix[i][j]== <span class="string">&#x27;0&#x27;</span> ? <span class="number">0</span> : arr[j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans = Math.max(ans, compute(m));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">(<span class="type">int</span> len)</span>&#123;</span><br><span class="line">        <span class="comment">//单调栈求矩形面积</span></span><br><span class="line">        <span class="comment">//找最近、小，得出左右边界，面积 = 边界宽度 * 矩高</span></span><br><span class="line">        r = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">//出栈  大压小</span></span><br><span class="line">            <span class="keyword">while</span> (r &gt; <span class="number">0</span> &amp;&amp; arr[i] &lt; arr[stack[r - <span class="number">1</span>]])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> stack[--r];</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> r &gt; <span class="number">0</span> ? stack[r - <span class="number">1</span>] + <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">                ans = Math.max(ans, (i - left) * arr[cur]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//入栈</span></span><br><span class="line">            stack[r++] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清算阶段</span></span><br><span class="line">        <span class="keyword">while</span> (r &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> stack[--r];</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> r &gt; <span class="number">0</span> ? stack[r - <span class="number">1</span>] + <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">            ans = Math.max(ans, (len - left) * arr[cur]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 单调栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LargestRectangleArea</title>
      <link href="/2024/06/17/LargestRectangleArea/"/>
      <url>/2024/06/17/LargestRectangleArea/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.单调栈;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/6/17 18:10</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 柱状图中最大的矩形</span></span><br><span class="line"><span class="comment">// 给定 n 个非负整数，用来表示柱状图中各个柱子的高度</span></span><br><span class="line"><span class="comment">// 每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积</span></span><br><span class="line"><span class="comment">// 测试链接：https://leetcode.cn/problems/largest-rectangle-in-histogram</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LargestRectangleArea</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 柱状图中最大的矩形</span></span><br><span class="line">    <span class="comment">// 给定 n 个非负整数，用来表示柱状图中各个柱子的高度</span></span><br><span class="line">    <span class="comment">// 每个柱子彼此相邻，且宽度为 1 。求在该柱状图中，能够勾勒出来的矩形的最大面积</span></span><br><span class="line">    <span class="comment">// 测试链接：https://leetcode.cn/problems/largest-rectangle-in-histogram</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">100001</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] stack = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> r;</span><br><span class="line">    <span class="comment">//有个想法：求当前柱子能达到的最优面积</span></span><br><span class="line">    <span class="comment">//用单调栈求出当前柱子 离最近最小的左右边界，</span></span><br><span class="line">    <span class="comment">// 则边界内的面积等于 宽度乘以当前柱子长度</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largestRectangleArea</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        r = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//出栈 大压小</span></span><br><span class="line">            <span class="keyword">while</span> (r &gt; <span class="number">0</span> &amp;&amp; arr[i] &lt; arr[stack[r - <span class="number">1</span>]]) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> stack[--r];</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> r &gt; <span class="number">0</span> ? stack[r - <span class="number">1</span>] + <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">                ans = Math.max(ans, (i - left) * arr[cur] );</span><br><span class="line">            &#125;</span><br><span class="line">            stack[r++] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清算阶段</span></span><br><span class="line">        <span class="keyword">while</span> (r &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> stack[--r];</span><br><span class="line">            <span class="comment">//因为这里是从cur位置往左算，所以不用加一</span></span><br><span class="line">            <span class="comment">//清算阶段，要加上相等高度位置的宽度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> r &gt; <span class="number">0</span> ? stack[r - <span class="number">1</span>] + <span class="number">1</span>: <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//右边都比当前数大，所以用数组边界 减去 左边界</span></span><br><span class="line">            ans = Math.max(ans, (arr.length - left) * arr[cur] );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 单调栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NumSubmat</title>
      <link href="/2024/06/17/NumSubmat/"/>
      <url>/2024/06/17/NumSubmat/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.单调栈II;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/6/17 17:59</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计全1子矩形的数量</span></span><br><span class="line"><span class="comment">// 给你一个 m * n 的矩阵 mat，其中只有0和1两种值</span></span><br><span class="line"><span class="comment">// 请你返回有多少个 子矩形 的元素全部都是1</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/count-submatrices-with-all-ones/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumSubmat</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">159</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] stack = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//说白了就是划定所有比当前柱子高的区域，然后统计这片区域内，所有大于Max(lmin, rmin)高度的所有矩形数量</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将二维变成1维数组</span></span><br><span class="line">    <span class="comment">//单调栈作用为：找左右两边的比当前数小的数</span></span><br><span class="line">    <span class="comment">//统计当前柱子高度 到 Max(lmin, rmin)高度的所有矩形， 长度为  左右两边两柱子距离n。</span></span><br><span class="line">    <span class="comment">//每个高度的矩形数量计算公式为等差数列求和，n * (首项加尾项) 除以2： n* (n + 1) /2   -&gt; Sn</span></span><br><span class="line">    <span class="comment">//范围内的所有高度x矩形求和公式 = x * Sn</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numSubmat</span><span class="params">(<span class="type">int</span>[][] mat)</span> &#123;</span><br><span class="line">        <span class="comment">//转为1维数组</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> mat.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> mat[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记得要初始化</span></span><br><span class="line">        Arrays.fill(arr, <span class="number">0</span>, m, <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//对每一行进行统计</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                arr[j] = mat[i][j] == <span class="number">0</span> ? <span class="number">0</span> : arr[j] + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += compute(m);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//大压小</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">(<span class="type">int</span> len)</span>&#123;</span><br><span class="line">        r = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, left, target, cur; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">//出栈</span></span><br><span class="line">            <span class="keyword">while</span> (r &gt; <span class="number">0</span> &amp;&amp; arr[i] &lt;= arr[stack[r - <span class="number">1</span>]])&#123;</span><br><span class="line">                cur = stack[--r];</span><br><span class="line">                <span class="comment">//处理相等的情况，弹不弹出都可以，这里是交给相同元素的最后一次取处理</span></span><br><span class="line">                <span class="keyword">if</span> (arr[i] &lt; arr[cur])&#123;</span><br><span class="line">                    left = r &gt; <span class="number">0</span> ? stack[r - <span class="number">1</span>] : -<span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">dis</span> <span class="operator">=</span> i - left - <span class="number">1</span>;<span class="comment">//距离</span></span><br><span class="line">                    <span class="comment">//如果左边没有比它小的数，那就拿右边的柱子</span></span><br><span class="line">                    target = r &gt; <span class="number">0</span> ? Math.max(arr[left], arr[i]) : arr[i];</span><br><span class="line">                    <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> arr[cur] - target;<span class="comment">//柱子高度差</span></span><br><span class="line">                    sum += h * dis * (dis+<span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//入栈</span></span><br><span class="line">            stack[r++] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清算阶段</span></span><br><span class="line">        <span class="keyword">while</span> (r &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> stack[--r];</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> r &gt; <span class="number">0</span> ? stack[r - <span class="number">1</span>] : -<span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">dis</span> <span class="operator">=</span>  len - left - <span class="number">1</span>;;<span class="comment">//距离</span></span><br><span class="line">            <span class="comment">//目标柱子高度</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">target</span> <span class="operator">=</span> left == -<span class="number">1</span> ? <span class="number">0</span> : arr[left];</span><br><span class="line">            <span class="type">int</span> <span class="variable">h</span> <span class="operator">=</span> arr[cur] - target;<span class="comment">//柱子高度差</span></span><br><span class="line">            sum += h * dis * (dis+<span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 单调栈II </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈II </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TotalSteps</title>
      <link href="/2024/06/17/TotalSteps/"/>
      <url>/2024/06/17/TotalSteps/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.单调栈II;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/6/17 16:40</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 大鱼吃小鱼问题</span></span><br><span class="line"><span class="comment">// 给定一个数组arr，每个值代表鱼的体重</span></span><br><span class="line"><span class="comment">// 每一轮每条鱼都会吃掉右边离自己最近比自己体重小的鱼，每条鱼向右找只吃一条</span></span><br><span class="line"><span class="comment">// 但是吃鱼这件事是同时发生的，也就是同一轮在A吃掉B的同时，A也可能被别的鱼吃掉</span></span><br><span class="line"><span class="comment">// 如果有多条鱼在当前轮找到的是同一条小鱼，那么在这一轮，这条小鱼同时被这些大鱼吃</span></span><br><span class="line"><span class="comment">// 请问多少轮后，鱼的数量就固定了</span></span><br><span class="line"><span class="comment">// 比如 : 8 3 1 5 6 7 2 4</span></span><br><span class="line"><span class="comment">// 第一轮 : 8吃3；3吃1；5、6、7吃2；4没有被吃。数组剩下 8 5 6 7 4</span></span><br><span class="line"><span class="comment">// 第二轮 : 8吃5；5、6、7吃4。数组剩下 8 6 7</span></span><br><span class="line"><span class="comment">// 第三轮 : 8吃6。数组剩下 8 7</span></span><br><span class="line"><span class="comment">// 第四轮 : 8吃7。数组剩下 8。</span></span><br><span class="line"><span class="comment">// 过程结束，返回4</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.nowcoder.com/practice/77199defc4b74b24b8ebf6244e1793de</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/steps-to-make-array-non-decreasing/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TotalSteps</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">100001</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] stack = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[][] stack2 = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//此方法无解······。思路错了</span></span><br><span class="line">    <span class="comment">//测试用例:[10,1,2,3,4,5,6,1,2,3]</span></span><br><span class="line">    <span class="comment">//测试结果:8</span></span><br><span class="line">    <span class="comment">//期望结果:6</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//很神奇，观察用力得出，为啥要用单调栈？</span></span><br><span class="line">    <span class="comment">//输出的结果就是单调栈 大压小的结果，只是要统计经过几轮操作？</span></span><br><span class="line">    <span class="comment">//观察用例得出，操作轮的增加是再每一次入栈前，淘汰掉的数字</span></span><br><span class="line">    <span class="comment">//当前数的操作轮 = 上一个淘汰掉数字的操作轮 + 1</span></span><br><span class="line">    <span class="comment">//何时操作轮数 会增加呢？ 当前数大于等于 上次淘汰掉数时</span></span><br><span class="line">    <span class="comment">//答案：记录每次入栈前，淘汰掉元素的轮数的最大值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalSteps1</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//答案</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//上个被淘汰掉的数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">lun</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//pre的操作轮数</span></span><br><span class="line"></span><br><span class="line">        r = <span class="number">1</span>;<span class="comment">//首个数字入栈</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            <span class="comment">//判断是否要入栈</span></span><br><span class="line">            <span class="keyword">if</span> (nums[stack[r - <span class="number">1</span>]] &lt;= nums[i])&#123;</span><br><span class="line">                <span class="comment">//入栈  统计答案 同时所有参数归零</span></span><br><span class="line">                stack[r++] = i;</span><br><span class="line">                ans = Math.max(ans, lun);</span><br><span class="line">                pre = lun = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//不入栈，处理操作数</span></span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt;= pre)&#123;<span class="comment">//因为原题数组最小值为1，所以这个操作包含了初始化</span></span><br><span class="line">                    lun++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//更新操作数</span></span><br><span class="line">                pre = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(ans, lun);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这解法好难想， 根据左神的思路来解的  todo 标记</span></span><br><span class="line">    <span class="comment">//从后往前遍历</span></span><br><span class="line">    <span class="comment">//小到大压栈</span></span><br><span class="line">    <span class="comment">//每个数字入栈，带上当前数字的操作轮数</span></span><br><span class="line">    <span class="comment">//出栈时，更新最大的操作轮数。 Math.max(当前数轮数, 栈顶元素的轮数) + 1</span></span><br><span class="line">    <span class="comment">//每个数进栈时都是0轮</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalSteps</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        r = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>, cur; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//出栈</span></span><br><span class="line">            cur = <span class="number">0</span>;<span class="comment">//当前数字经历的轮数</span></span><br><span class="line">            <span class="keyword">while</span> (r &gt; <span class="number">0</span> &amp;&amp; arr[i] &gt; stack2[r - <span class="number">1</span>][<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="comment">//当前数字轮数 + 1后 和栈顶轮数 取最大</span></span><br><span class="line">                <span class="comment">//当前数字 将栈顶弹出需要1轮，所以这里要+1</span></span><br><span class="line">                cur = Math.max(cur + <span class="number">1</span>, stack2[--r][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"><span class="comment">//            stack2[r++] = new int[]&#123;arr[i], cur&#125;;</span></span><br><span class="line">            stack2[r][<span class="number">0</span>] = arr[i];</span><br><span class="line">            stack2[r++][<span class="number">1</span>] = cur;</span><br><span class="line">            <span class="comment">//统计每个数字弹出其他数字时的最大轮数</span></span><br><span class="line">            ans = Math.max(ans, cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 单调栈II </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈II </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RemoveDuplicateLetters2</title>
      <link href="/2024/06/17/RemoveDuplicateLetters2/"/>
      <url>/2024/06/17/RemoveDuplicateLetters2/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.单调栈II;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/6/17 14:20</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除重复字母保证剩余字符串的字典序最小</span></span><br><span class="line"><span class="comment">// 给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次</span></span><br><span class="line"><span class="comment">// 需保证 返回结果的字典序最小</span></span><br><span class="line"><span class="comment">// 要求不能打乱其他字符的相对位置</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/remove-duplicate-letters/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoveDuplicateLetters2</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">26</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每种字符词频</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] cnts = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 每种字符目前有没有进栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span>[] enter = <span class="keyword">new</span> <span class="title class_">boolean</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 单调栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">char</span>[] stack = <span class="keyword">new</span> <span class="title class_">char</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是左神的解法，意思上差不多，但比较方便。</span></span><br><span class="line">    <span class="comment">//栈内放的是字符，统计数组记录的是 剩余的字符的个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">removeDuplicateLetters</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        r = <span class="number">0</span>;</span><br><span class="line">        Arrays.fill(cnts, <span class="number">0</span>);</span><br><span class="line">        Arrays.fill(enter, <span class="literal">false</span>);</span><br><span class="line">        <span class="type">char</span>[] s = str.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> cha : s) &#123;</span><br><span class="line">            cnts[cha - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> cur : s) &#123;</span><br><span class="line">            <span class="comment">// 从左往右依次遍历字符，a -&gt; 0 b -&gt; 1 ... z -&gt; 25</span></span><br><span class="line">            <span class="comment">// cur -&gt; cur - &#x27;a&#x27;</span></span><br><span class="line">            <span class="keyword">if</span> (!enter[cur - <span class="string">&#x27;a&#x27;</span>]) &#123;</span><br><span class="line">                <span class="keyword">while</span> (r &gt; <span class="number">0</span> &amp;&amp; stack[r - <span class="number">1</span>] &gt; cur &amp;&amp; cnts[stack[r - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    enter[stack[r - <span class="number">1</span>] - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">false</span>;</span><br><span class="line">                    r--;</span><br><span class="line">                &#125;</span><br><span class="line">                stack[r++] = cur;</span><br><span class="line">                enter[cur - <span class="string">&#x27;a&#x27;</span>] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cnts[cur - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> String.valueOf(stack, <span class="number">0</span>, r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 单调栈II </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈II </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RemoveDuplicateLetters</title>
      <link href="/2024/06/17/RemoveDuplicateLetters/"/>
      <url>/2024/06/17/RemoveDuplicateLetters/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.单调栈II;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/6/17 14:15</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 去除重复字母保证剩余字符串的字典序最小</span></span><br><span class="line"><span class="comment">// 给你一个字符串 s ，请你去除字符串中重复的字母，使得每个字母只出现一次</span></span><br><span class="line"><span class="comment">// 需保证 返回结果的字典序最小</span></span><br><span class="line"><span class="comment">// 要求不能打乱其他字符的相对位置</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/remove-duplicate-letters/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoveDuplicateLetters</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span>  <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] stack = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个解法是自己写的，栈内放的是字符下标，不太方便。</span></span><br><span class="line">    <span class="comment">//统计字符数组记录的是  栈内 + 未遍历字符个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//为什么需要单调栈呢？ 因为根据题目要求，需要返回结果的字典序最小，</span></span><br><span class="line">    <span class="comment">// 所以才要用单调栈对 答案的字符有个先后顺序，即要求答案的首个字符要尽可能小</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">removeDuplicateLetters</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">//栈 大压小</span></span><br><span class="line">        <span class="comment">//1、栈内已有该元素，跳过该元素，元素次数 - 1</span></span><br><span class="line">        <span class="comment">// 2、 栈内无该元素</span></span><br><span class="line">        <span class="comment">//是否要出栈 -》</span></span><br><span class="line">        <span class="comment">// 1、当前字符比栈顶字符小  &amp;&amp; 栈顶元素后续还会出现</span></span><br><span class="line">        <span class="comment">//入栈 ？  栈内字符没出现过</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计各个字符次数 ： 表示栈内 以及还未遍历的字符的个数</span></span><br><span class="line">        <span class="type">int</span>[] sCount = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="comment">//记录栈内字符</span></span><br><span class="line">        <span class="type">int</span>[] sArr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line">        <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : arr) &#123;</span><br><span class="line">            sCount[c - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//没出现过</span></span><br><span class="line">            <span class="keyword">if</span> (sArr[arr[i] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//出栈  当前元素 未出现过 且小于栈顶 且 栈顶元素 后面还会出现</span></span><br><span class="line">                <span class="keyword">while</span> (r &gt; <span class="number">0</span> &amp;&amp; arr[i] &lt; arr[stack[r - <span class="number">1</span>]] &amp;&amp; sCount[arr[stack[r - <span class="number">1</span>]] - <span class="string">&#x27;a&#x27;</span>] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                    sCount[arr[stack[r - <span class="number">1</span>]] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                    sArr[arr[stack[--r]] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//入栈</span></span><br><span class="line">                sArr[arr[i] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">                stack[r++] = i;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;<span class="comment">//栈内有该元素，不入栈跳过，元素 -1</span></span><br><span class="line">                sCount[arr[i] - <span class="string">&#x27;a&#x27;</span>]--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; r; i++) &#123;</span><br><span class="line">            sb.append(arr[stack[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 单调栈II </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈II </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MaxWidthRamp</title>
      <link href="/2024/06/14/MaxWidthRamp/"/>
      <url>/2024/06/14/MaxWidthRamp/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.单调栈II;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/6/14 18:14</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxWidthRamp</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">50001</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] stack = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> r;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//想明白对于某个点来说，必须大于这个点的位置叫坡</span></span><br><span class="line">    <span class="comment">//再结合点贪心思想，对于某个点A,如果后续有点大于A,那离这个点越远的、大于这个A的点答案越优</span></span><br><span class="line">    <span class="comment">//即使后续有坡，但后续数字比A小，那也不是最优点，因为已经有A点比后续的点更低了</span></span><br><span class="line">    <span class="comment">//所以单调栈维持位置越低的点的单调性 -》 小压大</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxWidthRamp</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="comment">//第一个点入栈</span></span><br><span class="line">        r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//维持低点位置的单调性</span></span><br><span class="line">            <span class="keyword">if</span> (arr[stack[r - <span class="number">1</span>]] &gt; arr[i])&#123;</span><br><span class="line">                stack[r++] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//从最后一个位置遍历过来  最远就是最优</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> arr.length - <span class="number">1</span>; j &gt;= <span class="number">0</span> ; j--) &#123;</span><br><span class="line">            <span class="comment">//出栈</span></span><br><span class="line">            <span class="comment">//有个坑，当栈顶和当前位置相同时，也要进循环，为了能让它出栈 往前找更靠前的位置</span></span><br><span class="line">            <span class="keyword">while</span> (r &gt; <span class="number">0</span> &amp;&amp; j &gt; stack[r - <span class="number">1</span>] &amp;&amp; arr[j] &gt;= arr[stack[r - <span class="number">1</span>]])&#123;</span><br><span class="line">                ans = Math.max(ans, j - stack[--r]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(maxWidthRamp(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>&#125;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 单调栈II </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈II </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SumSubarrayMins</title>
      <link href="/2024/06/12/SumSubarrayMins/"/>
      <url>/2024/06/12/SumSubarrayMins/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.单调栈;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: HIM</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@description</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: 2024/6/12 15:02</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SumSubarrayMins</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">30001</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] stack = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用单调栈的性质 界定某个区间内自己最小</span></span><br><span class="line">    <span class="comment">// 左边离最近比自己小a,左边离最近比自己小b,</span></span><br><span class="line">    <span class="comment">// 则(a,b)区间内，自己最小，这个区间内的所有包含自己的子数组的最小值min都是自己</span></span><br><span class="line">    <span class="comment">//即 和为 min * ((a,mini)区间内子数组个数 + (mini,b)区间内子数组个数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumSubarrayMins</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//大压小</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//出栈</span></span><br><span class="line">            <span class="comment">//这里用不用=都可以</span></span><br><span class="line">            <span class="comment">//即使相等也出栈，后面的结果会把前面没算的补上去的</span></span><br><span class="line">            <span class="keyword">while</span> (r &gt; <span class="number">0</span> &amp;&amp; arr[i] &lt; arr[stack[r - <span class="number">1</span>]])&#123;</span><br><span class="line">                <span class="comment">//拿下左右区间</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> stack[--r];</span><br><span class="line">                <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> r &gt; <span class="number">0</span> ? stack[r - <span class="number">1</span>]: -<span class="number">1</span>;</span><br><span class="line">                <span class="comment">//计算 左右区间内包含当前数的所有子数组的个数 * 当前数值</span></span><br><span class="line">                <span class="comment">// e.g；[11,81,94,43,3] -》 以94为例</span></span><br><span class="line">                <span class="comment">// 左边：[94]的所有子数组个数 -》 2- 1 = 1</span></span><br><span class="line">                <span class="comment">// 右边，[94]的所有子数组个数 -》 3 - 2 = 1</span></span><br><span class="line">                <span class="comment">//这里用乘法是因为要加上 左-》右跨区间的子数组个数，所以总的子数组个数就是 左边个数 * 右边个数（全组合）</span></span><br><span class="line">                ans = (ans + (<span class="type">long</span>) (cur - left) * (i - cur) * arr[cur]) % MOD;</span><br><span class="line">            &#125;</span><br><span class="line">            stack[r++] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清算阶段</span></span><br><span class="line">        <span class="comment">//只剩左区间了</span></span><br><span class="line">        <span class="keyword">while</span> (r &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> stack[--r];</span><br><span class="line">            <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> r &gt; <span class="number">0</span> ? stack[r - <span class="number">1</span>]: -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//这里的有区间就是数组长度，别忘了计算</span></span><br><span class="line">            ans = (ans + (<span class="type">long</span>) (cur - left) * (arr.length - cur) * arr[cur]) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span>  (<span class="type">int</span>)ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//总结：</span></span><br><span class="line">    <span class="comment">//这题我觉得难点在于子数组个数的计算上，需要关注这情况</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 单调栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DailyTemperatures</title>
      <link href="/2024/06/12/DailyTemperatures/"/>
      <url>/2024/06/12/DailyTemperatures/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.单调栈;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.time.LocalDate;</span><br><span class="line"><span class="keyword">import</span> java.time.Period;</span><br><span class="line"><span class="keyword">import</span> java.time.ZoneId;</span><br><span class="line"><span class="keyword">import</span> java.time.temporal.ChronoUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Objects;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 每日温度</span></span><br><span class="line"><span class="comment">// 给定一个整数数组 temperatures ，表示每天的温度，返回一个数组 answer</span></span><br><span class="line"><span class="comment">// 其中 answer[i] 是指对于第 i 天，下一个更高温度出现在几天后</span></span><br><span class="line"><span class="comment">// 如果气温在这之后都不会升高，请在该位置用 0 来代替。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/daily-temperatures/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DailyTemperatures</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">100001</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] stack = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//题目即为找右边最近的比自己大的数字</span></span><br><span class="line">    <span class="comment">//即用单调栈解决 -》 小压大  出栈时，右边最近大的数字就是当前数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] dailyTemperatures(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[arr.length];</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//出栈 当前数就是比自己大的</span></span><br><span class="line">            <span class="keyword">while</span> (r &gt; <span class="number">0</span> &amp;&amp; arr[i] &gt; arr[stack[r - <span class="number">1</span>]])&#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> i - stack[--r];</span><br><span class="line">                ans[stack[r]] = len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//入栈</span></span><br><span class="line">            stack[r++] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//总结：</span></span><br><span class="line">    <span class="comment">//要小压大 还是  大压小，得看你要求右边的数是怎样的</span></span><br><span class="line">    <span class="comment">// 小压大  出栈时右边的数就是比自己大， 左边的数比自己大</span></span><br><span class="line">    <span class="comment">// 大压小  出栈时右边的数就是比自己小， 左边的数比自己小</span></span><br><span class="line">    <span class="comment">// A 压 B， 出栈时左右都是B</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 单调栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeftRightLess1</title>
      <link href="/2024/06/07/LeftRightLess1/"/>
      <url>/2024/06/07/LeftRightLess1/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.单调栈;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> LeftRightLess1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 用数组实现版本</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/6/7 23:40</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeftRightLess1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">1000001</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN][<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用数组实现栈</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] stack = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = bf.readLine()) !=  <span class="literal">null</span>)&#123;</span><br><span class="line">            N = Integer.valueOf(line);</span><br><span class="line">            line = bf.readLine();</span><br><span class="line">            String[] split = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                arr[i] = Integer.valueOf(split[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            findNum();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                out.println(ans[i][<span class="number">0</span>] + <span class="string">&quot; &quot;</span> + ans[i][<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        bf.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用单调栈的性质</span></span><br><span class="line">    <span class="comment">//大压小，弹出时即是答案</span></span><br><span class="line">    <span class="comment">//求的是位置信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">findNum</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//压栈阶段</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="comment">//判断如果小压大 就弹出，并记录坐标</span></span><br><span class="line">            <span class="keyword">while</span> (r &gt; <span class="number">0</span> &amp;&amp; arr[i] &lt;= arr[stack[r - <span class="number">1</span>]])&#123;</span><br><span class="line">                <span class="comment">//当前位置</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> stack[--r];</span><br><span class="line">                <span class="comment">//左边比它小的就是栈顶，右边比他小的就是当前遍历的数</span></span><br><span class="line">                ans[index] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;r == <span class="number">0</span> ? -<span class="number">1</span> : stack[r - <span class="number">1</span>], i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            stack[r++] = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清算阶段</span></span><br><span class="line">        <span class="keyword">while</span> (r &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">index</span> <span class="operator">=</span> stack[--r];</span><br><span class="line">            <span class="comment">//如果数组空了，那就都是负1</span></span><br><span class="line">            <span class="keyword">if</span> (r  == <span class="number">0</span>)&#123;</span><br><span class="line">                ans[index] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//否则左边比它小的就是栈顶</span></span><br><span class="line">                ans[index] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;stack[r - <span class="number">1</span>], -<span class="number">1</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为有重复数字</span></span><br><span class="line">        <span class="comment">//校准阶段</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ans.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//左边的数都是对的，校准右边的数</span></span><br><span class="line">            <span class="comment">//如果右边离最近且小的数和自己相等，找这个位置的数的右边位置</span></span><br><span class="line">            <span class="keyword">if</span> (ans[i][<span class="number">1</span>] != -<span class="number">1</span> &amp;&amp; arr[ans[i][<span class="number">1</span>]] == arr[i])&#123;</span><br><span class="line">                ans[i][<span class="number">1</span>] = ans[ans[i][<span class="number">1</span>]][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 单调栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LeftRightLess</title>
      <link href="/2024/06/06/LeftRightLess/"/>
      <url>/2024/06/06/LeftRightLess/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.单调栈;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> LeftRightLess</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/6/6 14:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单调栈求每个位置左右两侧，离当前位置最近、且值严格小于的位置</span></span><br><span class="line"><span class="comment">// 给定一个可能含有重复值的数组 arr</span></span><br><span class="line"><span class="comment">// 找到每一个 i 位置左边和右边离 i 位置最近且值比 arr[i] 小的位置</span></span><br><span class="line"><span class="comment">// 返回所有位置相应的信息。</span></span><br><span class="line"><span class="comment">// 输入描述：</span></span><br><span class="line"><span class="comment">// 第一行输入一个数字 n，表示数组 arr 的长度。</span></span><br><span class="line"><span class="comment">// 以下一行输入 n 个数字，表示数组的值</span></span><br><span class="line"><span class="comment">// 输出描述：</span></span><br><span class="line"><span class="comment">// 输出n行，每行两个数字 L 和 R，如果不存在，则值为 -1，下标从 0 开始。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.nowcoder.com/practice/2a2c00e7a88a498693568cef63a4b7bb</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下的code，提交时请把类名改成&quot;Main&quot;，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LeftRightLess</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用容器实现版本</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">1000001</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = bf.readLine()) !=  <span class="literal">null</span>)&#123;</span><br><span class="line">            N = Integer.valueOf(line);</span><br><span class="line">            line = bf.readLine();</span><br><span class="line">            String[] split = line.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">                arr[i] = Integer.valueOf(split[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span>[][] ans = findNum();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span>[] an : ans) &#123;</span><br><span class="line">                out.print(an[<span class="number">0</span>]);</span><br><span class="line">                out.print(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                out.println(an[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        bf.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用单调栈的性质</span></span><br><span class="line">    <span class="comment">//大压小，弹出时即是答案</span></span><br><span class="line">    <span class="comment">//求的是位置信息</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] findNum()&#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span>[][] ans = <span class="keyword">new</span> <span class="title class_">int</span>[N][<span class="number">2</span>];</span><br><span class="line">        <span class="comment">//压栈阶段</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="comment">//判断如果小压大 就弹出，并记录坐标</span></span><br><span class="line">            <span class="keyword">while</span> (!stack.isEmpty() &amp;&amp; arr[i] &lt;= arr[stack.peek()])&#123;</span><br><span class="line">                <span class="comment">//当前位置</span></span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">                <span class="comment">//左边比它小的就是栈顶，右边比他小的就是当前遍历的数</span></span><br><span class="line">                ans[index] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;stack.isEmpty() ? -<span class="number">1</span> : stack.peek(), i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            stack.push(i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//清算阶段</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty())&#123;</span><br><span class="line">            <span class="type">Integer</span> <span class="variable">index</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">            <span class="comment">//如果数组空了，那就都是负1</span></span><br><span class="line">            <span class="keyword">if</span> (stack.isEmpty())&#123;</span><br><span class="line">                ans[index] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//否则左边比它小的就是栈顶</span></span><br><span class="line">                ans[index] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;stack.peek(), -<span class="number">1</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为有重复数字</span></span><br><span class="line">        <span class="comment">//校准阶段</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> ans.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">//左边的数都是对的，校准右边的数</span></span><br><span class="line">            <span class="comment">//如果右边离最近且小的数和自己相等，找这个位置的数的右边位置</span></span><br><span class="line">            <span class="keyword">if</span> (ans[i][<span class="number">1</span>] != -<span class="number">1</span> &amp;&amp; arr[ans[i][<span class="number">1</span>]] == arr[i])&#123;</span><br><span class="line">                ans[i][<span class="number">1</span>] = ans[ans[i][<span class="number">1</span>]][<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 单调栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 单调栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FirstMissingPositive</title>
      <link href="/2024/06/06/FirstMissingPositive/"/>
      <url>/2024/06/06/FirstMissingPositive/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.双指针;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> FirstMissingPositive</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/6/6 11:04</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 缺失的第一个正数</span></span><br><span class="line"><span class="comment">// 给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。</span></span><br><span class="line"><span class="comment">// 请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/first-missing-positive/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FirstMissingPositive</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有个想法，定义一个垃圾区域r 和有效区域l，数组长度len。</span></span><br><span class="line">    <span class="comment">//当数字大于len或小于1时，为垃圾，放置垃圾区域</span></span><br><span class="line">    <span class="comment">//当数字小于l + 1时，即已经出现过，也放垃圾区域</span></span><br><span class="line">    <span class="comment">//当数字不等于l + 1时，</span></span><br><span class="line">    <span class="comment">//遍历后，答案即为l+1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive1</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//边界左边都是有效数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;<span class="comment">//边界右边都是垃圾</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="comment">//若出现过 或者 超出垃圾区域，也得当垃圾</span></span><br><span class="line">            <span class="keyword">if</span> (nums[l] &lt; l + <span class="number">1</span> || nums[l] &gt; r + <span class="number">1</span>)&#123;</span><br><span class="line">                swap(l, r--, nums);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(nums[l] != l + <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//否则放到对应位置上</span></span><br><span class="line">                <span class="comment">//如果对应位置上和当前位置数字一样，那这个就是多余的垃圾</span></span><br><span class="line">                <span class="keyword">if</span> (nums[nums[l] - <span class="number">1</span>] == nums[l])&#123;</span><br><span class="line">                    swap(l, r--, nums);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    swap(l, nums[l] - <span class="number">1</span>, nums);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//原分析在上面，这是代码简洁版</span></span><br><span class="line">    <span class="comment">//宗旨：相应数值的数放到相应位置</span></span><br><span class="line">    <span class="comment">//定义有效区域l和垃圾区域r</span></span><br><span class="line">    <span class="comment">//条件：</span></span><br><span class="line">    <span class="comment">// 1、当数值符合预期位置，l++</span></span><br><span class="line">    <span class="comment">// 2、当数子大于垃圾区域r，或重复出现 -&gt; 数字小于有效区域l 或 即将要换的位置和当前数字一样， 即都是重复出现的垃圾</span></span><br><span class="line">    <span class="comment">// 3、将数字放到对应位置上</span></span><br><span class="line">    <span class="comment">// 答案即为l+1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">firstMissingPositive</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">//边界左边都是有效数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nums.length - <span class="number">1</span>;<span class="comment">//边界右边都是垃圾</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;<span class="comment">//这里是否要相等，取决于r的定义，这里定义的当前r是未被遍历过的，所以取相等r</span></span><br><span class="line">            <span class="comment">//如果位置和值符合预期，左边界+1</span></span><br><span class="line">            <span class="keyword">if</span> (nums[l] == l + <span class="number">1</span>)&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//若出现过 或者 超出垃圾区域，也得当垃圾</span></span><br><span class="line">            <span class="comment">//对应位置上和当前位置数字一样，那这个就是多余的垃圾</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[l] &lt; l + <span class="number">1</span> || nums[l] &gt; r + <span class="number">1</span> || nums[nums[l] - <span class="number">1</span>] == nums[l])&#123;</span><br><span class="line">                swap(l, r--, nums);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//放到对应位置上</span></span><br><span class="line">                swap(l, nums[l] - <span class="number">1</span>, nums);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == j)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i] = nums[i] ^ nums[j];</span><br><span class="line">        nums[j] = nums[i] ^ nums[j];</span><br><span class="line">        nums[i] = nums[i] ^ nums[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总结：</span></span><br><span class="line"><span class="comment">     * 双指针对于这题来说，是一个边界的概念，用于得到不同的界限</span></span><br><span class="line"><span class="comment">     * 有很多题目都有划分不同边界的做法，用双指针划分不同边界</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FindRadius</title>
      <link href="/2024/06/05/FindRadius/"/>
      <url>/2024/06/05/FindRadius/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.双指针;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> FindRadius</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/6/5 17:48</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 供暖器</span></span><br><span class="line"><span class="comment">// 冬季已经来临。 你的任务是设计一个有固定加热半径的供暖器向所有房屋供暖。</span></span><br><span class="line"><span class="comment">// 在加热器的加热半径范围内的每个房屋都可以获得供暖。</span></span><br><span class="line"><span class="comment">// 现在，给出位于一条水平线上的房屋 houses 和供暖器 heaters 的位置</span></span><br><span class="line"><span class="comment">// 请你找出并返回可以覆盖所有房屋的最小加热半径。</span></span><br><span class="line"><span class="comment">// 说明：所有供暖器都遵循你的半径标准，加热的半径也一样。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/heaters/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindRadius</span> &#123;</span><br><span class="line">    <span class="comment">//先搞个二分答案法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRadius1</span><span class="params">(<span class="type">int</span>[] houses, <span class="type">int</span>[] heaters)</span> &#123;</span><br><span class="line">        Arrays.sort(houses);</span><br><span class="line">        Arrays.sort(heaters);</span><br><span class="line">        <span class="comment">//求答案最大范围</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> Math.max(houses[houses.length - <span class="number">1</span>], heaters[heaters.length - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>,  r = max;</span><br><span class="line">        <span class="type">long</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (f(mid, houses, heaters))&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">f</span><span class="params">(<span class="type">long</span> mid,<span class="type">int</span>[] houses, <span class="type">int</span>[] heaters)</span>&#123;</span><br><span class="line">        <span class="comment">//最左边界和最右边界</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">lmin</span> <span class="operator">=</span> heaters[<span class="number">0</span>] - mid;</span><br><span class="line">        <span class="type">long</span> <span class="variable">rmax</span> <span class="operator">=</span> heaters[heaters.length - <span class="number">1</span>] + mid;</span><br><span class="line">        <span class="comment">//判断最左最右是否包含数组范围内</span></span><br><span class="line">        <span class="keyword">if</span> (lmin &gt; houses[<span class="number">0</span>] || rmax &lt; houses[houses.length - <span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断是否包含houses所有值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; houses.length &amp;&amp; r &lt; heaters.length) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">left</span> <span class="operator">=</span> heaters[r] - mid;</span><br><span class="line">            <span class="type">long</span> <span class="variable">right</span> <span class="operator">=</span> heaters[r] + mid;</span><br><span class="line">            <span class="keyword">while</span> (l &lt; houses.length &amp;&amp; left &lt;= houses[l] &amp;&amp; right &gt;= houses[l])&#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            r++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//是否遍历完所有值</span></span><br><span class="line">        <span class="keyword">return</span> l &gt;= houses.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//再搞个双指针解法</span></span><br><span class="line">    <span class="comment">//对于每一个位置，有一个最优的供暖器（距离该位置最近的）</span></span><br><span class="line">    <span class="comment">//取每一个位置的最优供暖器即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRadius</span><span class="params">(<span class="type">int</span>[] houses, <span class="type">int</span>[] heaters)</span>&#123;</span><br><span class="line">        <span class="comment">//从大到小排序</span></span><br><span class="line">        Arrays.sort(houses);</span><br><span class="line">        Arrays.sort(heaters);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对每个位置取最优供暖期</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j= <span class="number">0</span>; i &lt; houses.length; i++) &#123;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//取最优供暖器</span></span><br><span class="line">            <span class="keyword">while</span> (!best(j, i, houses, heaters))&#123;</span><br><span class="line">                <span class="comment">//跳下一个供暖器</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//取每个供暖器中最大的距离</span></span><br><span class="line">            ans = Math.max(ans, Math.abs(houses[i] - heaters[j]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于当前位置i，j供暖器是否最优（距离最近）</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">best</span><span class="params">(<span class="type">int</span> j, <span class="type">int</span> i, <span class="type">int</span>[] houses, <span class="type">int</span>[] heaters)</span>&#123;</span><br><span class="line">        <span class="comment">//最后一个供暖器，没得选</span></span><br><span class="line">        <span class="comment">//如果下一个供暖器对于当前位置更近，则跳下一个</span></span><br><span class="line">        <span class="comment">//因为heaters 有排序，所以对于某位置来说，heaters越往后只会 越近（供暖器小于当前位置） 或 越远 （供暖器大于当前位置）。呈单调性</span></span><br><span class="line">        <span class="keyword">return</span> j == heaters.length - <span class="number">1</span> ||</span><br><span class="line">                Math.abs(houses[i] - heaters[j]) &lt; Math.abs(houses[i] - heaters[j + <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总结：</span></span><br><span class="line"><span class="comment">     * 双指针对于这题来说，更多是贪心思想的体现吧？针对每一个位置取最优的供暖器，最优体现为距离最近</span></span><br><span class="line"><span class="comment">     * 双指针主要用于两个数组的当前遍历位置</span></span><br><span class="line"><span class="comment">     * 用多个指针指向不同数组，也有许多题目是这个做法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MaxArea</title>
      <link href="/2024/06/05/MaxArea/"/>
      <url>/2024/06/05/MaxArea/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.双指针;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> MaxArea</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/6/5 16:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 盛最多水的容器</span></span><br><span class="line"><span class="comment">// 给定一个长度为 n 的整数数组 height 。有 n 条垂线，第 i 条线的两个端点是 (i, 0) 和 (i, height[i]) 。</span></span><br><span class="line"><span class="comment">// 找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水</span></span><br><span class="line"><span class="comment">// 返回容器可以储存的最大水量</span></span><br><span class="line"><span class="comment">// 说明：你不能倾斜容器</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/container-with-most-water/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxArea</span> &#123;</span><br><span class="line">    <span class="comment">//贪心，舍弃短柱子，要长柱子</span></span><br><span class="line">    <span class="comment">//从两端开始对比，储水量由最短的柱子决定</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxArea</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> height.length - <span class="number">1</span>, l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            ans = Math.max(ans, (r - l) *  Math.min(height[l], height[r]));</span><br><span class="line">            <span class="comment">//比较两端柱子，舍弃短的那根</span></span><br><span class="line">            <span class="keyword">if</span> (height[l] &gt;= height[r])&#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双指针，指向头尾的用法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NumRescueBoats</title>
      <link href="/2024/06/05/NumRescueBoats/"/>
      <url>/2024/06/05/NumRescueBoats/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.双指针;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> NumRescueBoats</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/6/5 15:53</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 救生艇</span></span><br><span class="line"><span class="comment">// 给定数组 people</span></span><br><span class="line"><span class="comment">// people[i]表示第 i 个人的体重 ，船的数量不限，每艘船可以承载的最大重量为 limit</span></span><br><span class="line"><span class="comment">// 每艘船最多可同时载两人，但条件是这些人的重量之和最多为 limit</span></span><br><span class="line"><span class="comment">// 返回 承载所有人所需的最小船数</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/boats-to-save-people/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumRescueBoats</span> &#123;</span><br><span class="line">    <span class="comment">//有点贪心的思想：重的先走，尽可能带上轻的</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numRescueBoats</span><span class="params">(<span class="type">int</span>[] people, <span class="type">int</span> limit)</span> &#123;</span><br><span class="line">        Arrays.sort(people);</span><br><span class="line">        <span class="comment">//左右指针</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = people.length - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//当前船搭的重量</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            sum += l == r ? people[r] : people[r] + people[l];</span><br><span class="line">            <span class="comment">//如果自己 或者 带上别人就超重，自己走</span></span><br><span class="line">            <span class="keyword">if</span> (people[r] &gt;= limit || sum &gt; limit)&#123;</span><br><span class="line">                r--;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//能装下当前位，左右边界缩小</span></span><br><span class="line">                l++;</span><br><span class="line">                r--;</span><br><span class="line">                <span class="comment">//看看左边界能不能装下更多人</span></span><br><span class="line">                <span class="comment">//每艘船最多装两人！！！</span></span><br><span class="line">                <span class="comment">// while (l &lt;= r &amp;&amp; sum + people[l] &lt;= limit )&#123;</span></span><br><span class="line">                <span class="comment">// sum += people[l++];</span></span><br><span class="line">                <span class="comment">// &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">            sum = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双指针，指向头尾往中间缩的用法，怎么感觉双指针总和贪心思想搞在一起</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trap</title>
      <link href="/2024/05/29/Trap/"/>
      <url>/2024/05/29/Trap/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.双指针;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Trap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/5/29 11:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 接雨水</span></span><br><span class="line"><span class="comment">// 给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/trapping-rain-water/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Trap</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有思路就非常简单。</span></span><br><span class="line">    <span class="comment">//想明白每个柱子上面的雨水量由什么决定即可 ：</span></span><br><span class="line">    <span class="comment">//由 min（柱子左边高度的最大值 和 右边高度的最大值）决定</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">trap</span><span class="params">(<span class="type">int</span>[] height)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> height.length;</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//先求每个当前柱子左右高度最大值</span></span><br><span class="line">        <span class="type">int</span>[] lmax = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="type">int</span>[] rmax = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        lmax[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        rmax[len - <span class="number">1</span>] = height[len - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = len - <span class="number">2</span>; i &lt; len &amp;&amp; j &gt;= <span class="number">0</span>; i++, j--) &#123;</span><br><span class="line">            lmax[i] = Math.max(lmax[i - <span class="number">1</span>], height[i]);</span><br><span class="line">            rmax[j] = Math.max(rmax[j + <span class="number">1</span>], height[j]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//求每个柱子水量 = 当前柱子高度h &gt; 左右高度最小值min ？ 0 : min - h</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; len - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//左右高度最小值</span></span><br><span class="line">            min = Math.min(lmax[i - <span class="number">1</span>], rmax[i + <span class="number">1</span>]);</span><br><span class="line">            sum += height[i] &gt;= min ? <span class="number">0</span> : min - height[i];</span><br><span class="line">            <span class="comment">// sum += Math.max(0, Math.min(lmax[i - 1], rmax[i + 1]) - height[i]);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总结：</span></span><br><span class="line"><span class="comment">     * 秒在解题思路，</span></span><br><span class="line"><span class="comment">     * 这里双指针主要体现在 每个当前柱子左右高度最大值的思考上，</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FindTheDuplicateNumber</title>
      <link href="/2024/05/29/FindTheDuplicateNumber/"/>
      <url>/2024/05/29/FindTheDuplicateNumber/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.双指针;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> FindTheDuplicateNumber</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/5/29 10:44</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找重复数</span></span><br><span class="line"><span class="comment">// 给定一个包含 n + 1 个整数的数组 nums ，其数字都在 [1, n] 范围内（包括 1 和 n）</span></span><br><span class="line"><span class="comment">// 可知至少存在一个重复的整数。</span></span><br><span class="line"><span class="comment">// 假设 nums 只有 一个重复的整数 ，返回 这个重复的数 。</span></span><br><span class="line"><span class="comment">// 你设计的解决方案必须 不修改 数组 nums 且只用常量级 O(1) 的额外空间。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/find-the-duplicate-number/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindTheDuplicateNumber</span> &#123;</span><br><span class="line">    <span class="comment">//简单的方法，排序后用前后两个指针，只要前后相同，那就是重复的数字</span></span><br><span class="line">    <span class="comment">//时间复杂度n*O(logn)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate2</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (pre == num)&#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如何做到O(n)时间复杂度？</span></span><br><span class="line">    <span class="comment">//让每个数x 回到 x - 1的位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate1</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>; l &lt; nums.length; l++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[l] != l + <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//左边界的都是已经排好序的，这时出现左边界的数那就是重复值</span></span><br><span class="line">                <span class="comment">//如果即将交换的两数相同，则就是重复值</span></span><br><span class="line">                <span class="keyword">if</span> (nums[l] &lt; l + <span class="number">1</span> || nums[nums[l] - <span class="number">1</span>] == nums[l] )&#123;</span><br><span class="line">                    <span class="keyword">return</span> nums[l];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//将两数位置交换</span></span><br><span class="line">                swap(l, nums[l] - <span class="number">1</span>, nums);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将数组想象成链表，重复值即是环入口，用快慢指针解题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findDuplicate</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//先走一次</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">slow</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">fast</span> <span class="operator">=</span> nums[nums[<span class="number">0</span>]];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直到相遇</span></span><br><span class="line">        <span class="keyword">while</span> (slow != fast)&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[nums[fast]];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//fast重新从0位置出发</span></span><br><span class="line">        fast = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//然后每次走一步直到相遇</span></span><br><span class="line">        <span class="keyword">while</span> (slow != fast)&#123;</span><br><span class="line">            slow = nums[slow];</span><br><span class="line">            fast = nums[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i] = nums[i] ^ nums[j];</span><br><span class="line">        nums[j] = nums[i] ^ nums[j];</span><br><span class="line">        nums[i] = nums[i] ^ nums[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 双指针的快慢指针的用法，多用于链表上</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SortArrayByParityII</title>
      <link href="/2024/05/29/SortArrayByParityII/"/>
      <url>/2024/05/29/SortArrayByParityII/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.双指针;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> SortArrayByParityII</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 按奇偶排序数组II</span></span><br><span class="line"><span class="comment"> * 给定一个非负整数数组 nums。nums 中一半整数是奇数 ，一半整数是偶数</span></span><br><span class="line"><span class="comment"> * 对数组进行排序，以便当 nums[i] 为奇数时，i也是奇数</span></span><br><span class="line"><span class="comment"> * 当 nums[i] 为偶数时， i 也是 偶数</span></span><br><span class="line"><span class="comment"> * 你可以返回 任何满足上述条件的数组作为答案</span></span><br><span class="line"><span class="comment"> * 测试链接 : https://leetcode.cn/problems/sort-array-by-parity-ii/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/5/29 10:04</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortArrayByParityII</span> &#123;</span><br><span class="line">    <span class="comment">//用两个指针来区当前奇偶位置</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArrayByParityII(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>, o = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//只要有一方排好序就可以了</span></span><br><span class="line">        <span class="keyword">while</span> (o &lt; nums.length &amp;&amp; j &lt; nums.length)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((nums[j] &amp; <span class="number">1</span>) == <span class="number">1</span>)&#123;</span><br><span class="line">                j +=<span class="number">2</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//偶数就交换位置</span></span><br><span class="line">                swap(j, o, nums);</span><br><span class="line">                o +=<span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个是只用最后一位元素来判断</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] sortArrayByParityII2(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">odd</span> <span class="operator">=</span> <span class="number">1</span>, even = <span class="number">0</span>; odd &lt; n &amp;&amp; even &lt; n;) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((nums[n - <span class="number">1</span>] &amp; <span class="number">1</span>) == <span class="number">1</span>) &#123;</span><br><span class="line">                swap(odd, n - <span class="number">1</span>, nums);</span><br><span class="line">                odd += <span class="number">2</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                swap( even, n - <span class="number">1</span>, nums);</span><br><span class="line">                even += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == j)&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i] = nums[i] ^ nums[j];</span><br><span class="line">        nums[j] = nums[i] ^ nums[j];</span><br><span class="line">        nums[i] = nums[i] ^ nums[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 总结：</span></span><br><span class="line"><span class="comment">     * 双指针没怎么体现，单纯用来标记不同位置</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 双指针 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算等位时间</title>
      <link href="/2024/05/28/%E8%AE%A1%E7%AE%97%E7%AD%89%E4%BD%8D%E6%97%B6%E9%97%B4/"/>
      <url>/2024/05/28/%E8%AE%A1%E7%AE%97%E7%AD%89%E4%BD%8D%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;计算等位时间</span><br><span class="line">&gt;给定一个数组arr长度为n，表示n个服务员，每服务一个人的时间</span><br><span class="line">&gt;给定一个正数m，表示有m个人等位，如果你是刚来的人，请问你需要等多久？</span><br><span class="line">&gt;假设m远远大于n，比如n &lt;= 10^3, m &lt;= 10^9，该怎么做是最优解？</span><br><span class="line">&gt;谷歌的面试，这个题连考了2个月</span><br><span class="line">&gt;找不到测试链接，所以用对数器验证</span><br></pre></td></tr></table></figure></blockquote><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitingTime</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接最小堆，i , 已服务时间p</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">waitingTime1</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> m)</span>&#123;</span><br><span class="line">        <span class="comment">//空闲不用等</span></span><br><span class="line">        <span class="keyword">if</span> (m &lt; arr.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每服务一个人的时长i, 总服务时间p</span></span><br><span class="line">        <span class="comment">//构建最小堆，根据总服务时长排列</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingInt(a -&gt; a[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;arr[i], <span class="number">0</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="comment">//弹出并增加服务时长</span></span><br><span class="line">            <span class="type">int</span>[] poll = queue.poll();</span><br><span class="line">            poll[<span class="number">1</span>] += poll[<span class="number">0</span>];</span><br><span class="line">            queue.add(poll);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时堆顶就是等待时间</span></span><br><span class="line">        <span class="keyword">return</span> queue.peek()[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//二分答案求解</span></span><br><span class="line">    <span class="comment">//问题转化为当服务时间是x时，一共服务了y人，y &gt; m?</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">waitingTime2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> m)</span>&#123;</span><br><span class="line">        <span class="comment">//求答案最大范围</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            r = Math.max(i, r);</span><br><span class="line">        &#125;</span><br><span class="line">        r = r * m;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="comment">//以等待时间，即每个服务员必须工作的时间</span></span><br><span class="line">            mid = l + ((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (canService(mid, arr) &gt; m)&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个服务员必须工作min分钟，一共能服务多少人</span></span><br><span class="line">    <span class="comment">//一般到了这一步就是自然智慧的解题思路</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">canService</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : arr) &#123;</span><br><span class="line">            ans += min / n + <span class="number">1</span>;<span class="comment">//结束的、开始的客人都算</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 堆模拟</span></span><br><span class="line">    <span class="comment">// 验证方法，不是重点</span></span><br><span class="line">    <span class="comment">// 如果m很大，该方法会超时</span></span><br><span class="line">    <span class="comment">// 时间复杂度O(m * log(n))，额外空间复杂度O(n)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">waitingTime3</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="comment">// 一个一个对象int[]</span></span><br><span class="line">        <span class="comment">// [醒来时间，服务一个客人要多久]</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; (a[<span class="number">0</span>] - b[<span class="number">0</span>]));</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            heap.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">0</span>, arr[i] &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">int</span>[] cur = heap.poll();</span><br><span class="line">            cur[<span class="number">0</span>] += cur[<span class="number">1</span>];</span><br><span class="line">            heap.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap.peek()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分答案法</span></span><br><span class="line">    <span class="comment">// 最优解</span></span><br><span class="line">    <span class="comment">// 时间复杂度O(n * log(min * w))，额外空间复杂度O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">waitingTime4</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : arr) &#123;</span><br><span class="line">            min = Math.min(min, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = min * w, m; l &lt;= r;) &#123;</span><br><span class="line">            <span class="comment">// m中点，表示一定要让服务员工作的时间！</span></span><br><span class="line">            m = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 能够给几个客人提供服务</span></span><br><span class="line">            <span class="keyword">if</span> (f(arr, m) &gt;= w + <span class="number">1</span>) &#123;</span><br><span class="line">                ans = m;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果每个服务员工作time，可以接待几位客人（结束的、开始的客人都算）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> time)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">            ans += (time / num) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对数器测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试开始&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">V</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">3000</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">testTime</span> <span class="operator">=</span> <span class="number">20000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * N) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span>[] arr = randomArray(n, V);</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * M);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> waitingTime1(arr, m);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> waitingTime2(arr, m);</span><br><span class="line">            <span class="comment">// int ans1 = waitingTime1(arr, m);</span></span><br><span class="line">            <span class="comment">// int ans2 = waitingTime3(arr, m);</span></span><br><span class="line">            <span class="keyword">if</span> (ans1 != ans2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;出错了!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对数器测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] randomArray(<span class="type">int</span> n, <span class="type">int</span> v) &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[i] = (<span class="type">int</span>) (Math.random() * v) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二分答案法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分答案法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分割数组的最大值</title>
      <link href="/2024/05/28/%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/"/>
      <url>/2024/05/28/%E5%88%86%E5%89%B2%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt;分割数组的最大值(画匠问题)</span><br><span class="line">&gt;给定一个非负整数数组 nums 和一个整数 m</span><br><span class="line">&gt;你需要将这个数组分成 m 个非空的连续子数组。</span><br><span class="line">&gt;设计一个算法使得这 m 个子数组各自和的最大值最小。</span><br><span class="line">&gt;测试链接 : https://leetcode.cn/problems/split-array-largest-sum/</span><br></pre></td></tr></table></figure></blockquote><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [7,2,5,10,8], k = 2</span><br><span class="line">输出：18</span><br><span class="line">解释：</span><br><span class="line">一共有四种方法将 nums 分割为 2 个子数组。 </span><br><span class="line">其中最好的方式是将其分为 [7,2,5] 和 [10,8] 。</span><br><span class="line">因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,4,5], k = 2</span><br><span class="line">输出：9</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,4,4], k = 3</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 1000</code></li><li><code>0 &lt;= nums[i] &lt;= 106</code></li><li><code>1 &lt;= k &lt;= min(50, nums.length)</code></li></ul><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SplitArrayLargestSum</span> &#123;</span><br><span class="line">    <span class="comment">//二分答案法，转换下逻辑</span></span><br><span class="line">    <span class="comment">//当数组最大和是 x时，能否把数组分成k个？</span></span><br><span class="line">    <span class="comment">//所以二分答案数组最大和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">splitArray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//定义答案范围</span></span><br><span class="line">        <span class="comment">//数组和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            r += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (can(nums, k, m))&#123;</span><br><span class="line">                ans = m;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断子数组最大和是x下，能否分成k个数组 -》 符合最大和x的子数组小于等于k</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">can</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; nums.length; r++) &#123;</span><br><span class="line">            <span class="comment">//如果某个数大于x，直接退出</span></span><br><span class="line">            <span class="keyword">if</span> (nums[r] &gt; x)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum + nums[r] &gt; x)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="comment">//直接从这开始计数</span></span><br><span class="line">                sum = nums[r];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                sum += nums[r];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加上最后一组数</span></span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span> ans &lt;= k;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二分答案法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分答案法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>找出第K小的数对距离</title>
      <link href="/2024/05/28/%E6%89%BE%E5%87%BA%E7%AC%ACK%E5%B0%8F%E7%9A%84%E6%95%B0%E5%AF%B9%E8%B7%9D%E7%A6%BB/"/>
      <url>/2024/05/28/%E6%89%BE%E5%87%BA%E7%AC%ACK%E5%B0%8F%E7%9A%84%E6%95%B0%E5%AF%B9%E8%B7%9D%E7%A6%BB/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;找出第K小的数对距离</span><br><span class="line">&gt;数对 (a,b) 由整数 a 和 b 组成，其数对距离定义为 a 和 b 的绝对差值。</span><br><span class="line">&gt;给你一个整数数组 nums 和一个整数 k</span><br><span class="line">&gt;数对由 nums[i] 和 nums[j] 组成且满足 0 &lt;= i &lt; j &lt; nums.length</span><br><span class="line">&gt;返回 所有数对距离中 第 k 小的数对距离。</span><br><span class="line">&gt;测试链接 : https://leetcode.cn/problems/find-k-th-smallest-pair-distance/</span><br></pre></td></tr></table></figure></blockquote><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,3,1], k = 1</span><br><span class="line">输出：0</span><br><span class="line">解释：数对和对应的距离如下：</span><br><span class="line">(1,3) -&gt; 2</span><br><span class="line">(1,1) -&gt; 0</span><br><span class="line">(3,1) -&gt; 2</span><br><span class="line">距离第 1 小的数对是 (1,1) ，距离为 0 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1], k = 2</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,6,1], k = 3</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>n == nums.length</code></li><li><code>2 &lt;= n &lt;= 104</code></li><li><code>0 &lt;= nums[i] &lt;= 106</code></li><li><code>1 &lt;= k &lt;= n * (n - 1) / 2</code></li></ul><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmallestDistancePair</span> &#123;</span><br><span class="line">    <span class="comment">//有点神奇的题目。用二分答案法来解的话。</span></span><br><span class="line">    <span class="comment">//对数组排序，将问题转换为当数对距离小于等于答案m时，这样的有几对（根据数数来算排名和k对比）</span></span><br><span class="line">    <span class="comment">//分析二分答案的单调性：很明显数对距离和k之间有直接的关系，k就是数对距离的排名。数对距离越大，k越大</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">smallestDistancePair</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//求二分答案最大范围</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m, l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nums[nums.length - <span class="number">1</span>] - nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="comment">//所有数对距离 &lt;= m 有几对？</span></span><br><span class="line">            m =  (r + l) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//看答案和指标的关系</span></span><br><span class="line">            <span class="keyword">if</span> (find(m, nums) &gt;= k)&#123;</span><br><span class="line">                ans = m;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数对距离为m时，在数组中是第x小 （第x小 -》 小于等于x小的有多少）</span></span><br><span class="line">    <span class="comment">//其实就是数对距离小于等于m的有多少对</span></span><br><span class="line">    <span class="comment">//直接滑动窗口：</span></span><br><span class="line">    <span class="comment">//单调性分析，从左到右的数对，越往右 窗口内的数对越大，（每个窗口内数对的最大值，越靠右越大）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定左扩右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>; l &lt; nums.length; l++) &#123;</span><br><span class="line">            <span class="comment">//符合条件就右扩</span></span><br><span class="line">            <span class="comment">//这里写r + 1是只有当r + 1符合条件了，才让r++,即当前r是窗口内的</span></span><br><span class="line">            <span class="keyword">while</span> (r + <span class="number">1</span> &lt; nums.length &amp;&amp; nums[r + <span class="number">1</span>] - nums[l] &lt;= m)&#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//窗口内所有符合条件的数对距离</span></span><br><span class="line">            ans += r - l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二分答案法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分答案法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器人跳跃问题</title>
      <link href="/2024/05/28/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B7%B3%E8%B7%83%E9%97%AE%E9%A2%98/"/>
      <url>/2024/05/28/%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B7%B3%E8%B7%83%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;机器人跳跃问题</span><br><span class="line">&gt;机器人正在玩一个古老的基于DOS的游戏</span><br><span class="line">&gt;游戏中有N+1座建筑，从0到N编号，从左到右排列</span><br><span class="line">&gt;编号为0的建筑高度为0个单位，编号为i的建筑的高度为H(i)个单位</span><br><span class="line">&gt;起初机器人在编号为0的建筑处</span><br><span class="line">&gt;每一步，它跳到下一个（右边）建筑。假设机器人在第k个建筑，且它现在的能量值是E</span><br><span class="line">&gt;下一步它将跳到第个k+1建筑</span><br><span class="line">&gt;它将会得到或者失去正比于与H(k+1)与E之差的能量</span><br><span class="line">&gt;如果 H(k+1) &gt; E 那么机器人就失去H(k+1)-E的能量值，否则它将得到E-H(k+1)的能量值</span><br><span class="line">&gt;游戏目标是到达第个N建筑，在这个过程中，能量值不能为负数个单位</span><br><span class="line">&gt;现在的问题是机器人以多少能量值开始游戏，才可以保证成功完成游戏</span><br><span class="line">&gt;测试链接 : https://www.nowcoder.com/practice/7037a3d57bbd4336856b8e16a9cafd71</span><br><span class="line">&gt;请同学们务必参考如下代码中关于输入、输出的处理</span><br><span class="line">&gt;这是输入输出处理效率很高的写法</span><br><span class="line">&gt;提交以下的code，提交时请把类名改成&quot;Main&quot;，可以直接通过</span><br></pre></td></tr></table></figure></blockquote><h3 id="输入描述："><a href="#输入描述：" class="headerlink" title="输入描述："></a>输入描述：</h3><p>第一行输入，表示一共有 N 组数据.<br>第二个是 N 个空格分隔的整数，H1, H2, H3, …, Hn 代表建筑物的高度<br>输出描述：<br>输出一个单独的数表示完成游戏所需的最少单位的初始能量</p><h4 id="示例1"><a href="#示例1" class="headerlink" title="示例1"></a>示例1</h4><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">3 4 3 2 4</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h4 id="示例2"><a href="#示例2" class="headerlink" title="示例2"></a>示例2</h4><p>输入：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">4 4 4</span><br></pre></td></tr></table></figure><p>输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4</span><br></pre></td></tr></table></figure><h4 id="备注："><a href="#备注：" class="headerlink" title="备注："></a>备注：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">数据约束：</span><br><span class="line">1 &lt;= N &lt;= 10^5</span><br><span class="line">1 &lt;= H(i) &lt;= 10^5</span><br></pre></td></tr></table></figure><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RobotPassThroughBuilding</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">100001</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bf</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(bf);</span><br><span class="line">        <span class="keyword">while</span> (st.nextToken() != StreamTokenizer.TT_EOF)&#123;</span><br><span class="line">            N = (<span class="type">int</span>) st.nval;</span><br><span class="line">            <span class="comment">//获取答案最大值</span></span><br><span class="line">            <span class="comment">//因为是和当前能量值做对比，所以只要能量是最大高度，则一定能过关</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//这里有个坑，第0个柱子是不用计算的。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">int</span>) st.nval;</span><br><span class="line">                arr[i] = n;</span><br><span class="line">                max = Math.max(max, n);</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(getInitPower(max));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        bf.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取机器人初始能量</span></span><br><span class="line">    <span class="comment">//答案和问题指标之间存在单调性，（答案越大，问题指标越容易实现，否则反之），所以用二分答案法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getInitPower</span><span class="params">(<span class="type">int</span> max)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> max;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            m = l + ((r - l) / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (can(m, max))&#123;</span><br><span class="line">                ans = m;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当初始能量为m时，能否通过所有柱子</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">can</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> max)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> m;</span><br><span class="line">        <span class="comment">// 注意！</span></span><br><span class="line">        <span class="comment">// 如果给的能量值很大，那么后续能量增长将非常恐怖</span></span><br><span class="line">        <span class="comment">// 完全有可能超出long的范围</span></span><br><span class="line">        <span class="comment">// 所以要在遍历时，一定要加入energy &gt;= max的判断</span></span><br><span class="line">        <span class="comment">// 一旦能量超过高度最大值，后面肯定通关了，可以提前返回了</span></span><br><span class="line">        <span class="comment">// 这里很阴</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            count += count - arr[i];</span><br><span class="line">            <span class="comment">//查过最大值肯定能通过</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt;= max)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二分答案法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分答案法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>同时运行N台电脑的最长时间</title>
      <link href="/2024/05/28/%E5%90%8C%E6%97%B6%E8%BF%90%E8%A1%8CN%E5%8F%B0%E7%94%B5%E8%84%91%E7%9A%84%E6%9C%80%E9%95%BF%E6%97%B6%E9%97%B4/"/>
      <url>/2024/05/28/%E5%90%8C%E6%97%B6%E8%BF%90%E8%A1%8CN%E5%8F%B0%E7%94%B5%E8%84%91%E7%9A%84%E6%9C%80%E9%95%BF%E6%97%B6%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><p>你有 <code>n</code> 台电脑。给你整数 <code>n</code> 和一个下标从 <strong>0</strong> 开始的整数数组 <code>batteries</code> ，其中第 <code>i</code> 个电池可以让一台电脑 <strong>运行</strong> <code>batteries[i]</code> 分钟。你想使用这些电池让 <strong>全部</strong> <code>n</code> 台电脑 <strong>同时</strong> 运行。</p><p>一开始，你可以给每台电脑连接 <strong>至多一个电池</strong> 。然后在任意整数时刻，你都可以将一台电脑与它的电池断开连接，并连接另一个电池，你可以进行这个操作 <strong>任意次</strong> 。新连接的电池可以是一个全新的电池，也可以是别的电脑用过的电池。断开连接和连接新的电池不会花费任何时间。</p><p>注意，你不能给电池充电。</p><p>请你返回你可以让 <code>n</code> 台电脑同时运行的 <strong>最长</strong> 分钟数。</p><p>测试链接 : <a href="https://leetcode.cn/problems/maximum-running-time-of-n-computers/">https://leetcode.cn/problems/maximum-running-time-of-n-computers/</a></p></blockquote><p><strong>示例 1：</strong></p><p><img src="https://assets.leetcode.com/uploads/2022/01/06/example1-fit.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2, batteries = [3,3,3]</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">一开始，将第一台电脑与电池 0 连接，第二台电脑与电池 1 连接。</span><br><span class="line">2 分钟后，将第二台电脑与电池 1 断开连接，并连接电池 2 。注意，电池 0 还可以供电 1 分钟。</span><br><span class="line">在第 3 分钟结尾，你需要将第一台电脑与电池 0 断开连接，然后连接电池 1 。</span><br><span class="line">在第 4 分钟结尾，电池 1 也被耗尽，第一台电脑无法继续运行。</span><br><span class="line">我们最多能同时让两台电脑同时运行 4 分钟，所以我们返回 4 。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="https://assets.leetcode.com/uploads/2022/01/06/example2.png" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 2, batteries = [1,1,1,1]</span><br><span class="line">输出：2</span><br><span class="line">解释：</span><br><span class="line">一开始，将第一台电脑与电池 0 连接，第二台电脑与电池 2 连接。</span><br><span class="line">一分钟后，电池 0 和电池 2 同时耗尽，所以你需要将它们断开连接，并将电池 1 和第一台电脑连接，电池 3 和第二台电脑连接。</span><br><span class="line">1 分钟后，电池 1 和电池 3 也耗尽了，所以两台电脑都无法继续运行。</span><br><span class="line">我们最多能让两台电脑同时运行 2 分钟，所以我们返回 2 。</span><br></pre></td></tr></table></figure><p><strong>提示：</strong></p><ul><li><code>1 &lt;= n &lt;= batteries.length &lt;= 105</code></li><li><code>1 &lt;= batteries[i] &lt;= 109</code></li></ul><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxRunTime</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二分答案法，分析单调性：电池越大，能同时运行时间越久。即答案运行分钟数m和电池之间有单调性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maxRunTime1</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] batteries)</span> &#123;</span><br><span class="line">        <span class="comment">//获取答案最大范围</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> battery : batteries) &#123;</span><br><span class="line">            sum += battery;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">r</span> <span class="operator">=</span> (sum + n - <span class="number">1</span>) / n;<span class="comment">//向上取整</span></span><br><span class="line">        <span class="comment">//直接拿最大值去试，只要验证小于limit的电池总量，是否符合条件即可</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">avg</span> <span class="operator">=</span> sum / n;</span><br><span class="line">        <span class="keyword">if</span> (can(n, batteries, avg))&#123;</span><br><span class="line">            <span class="keyword">return</span> avg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模板</span></span><br><span class="line">        <span class="type">long</span> m, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="comment">//电脑同时运行的分钟数</span></span><br><span class="line">            m = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (can(n, batteries, m))&#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">                ans = m;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原基础上加点贪心</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maxRunTime</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] batteries)</span> &#123;</span><br><span class="line">        <span class="comment">//获取答案最大范围</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> battery : batteries) &#123;</span><br><span class="line">            sum += battery;</span><br><span class="line">            max = Math.max(battery, max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果电池总量 &gt; 最大电池 * 电脑数.</span></span><br><span class="line">        <span class="comment">// 说明 : 最终的供电时间一定在 &gt;= max，而如果最终的供电时间 &gt;= max (即没有一台电脑是能够单独一个电池供电完毕）</span></span><br><span class="line">        <span class="comment">// 说明 : 对于最终的答案X来说，所有电池都是课上讲的&quot;碎片拼接&quot;的概念</span></span><br><span class="line">        <span class="comment">// 那么直接返回最大时间即可 -》平均值</span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; (<span class="type">long</span>) max * n)&#123;</span><br><span class="line">            <span class="keyword">return</span> sum / n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">r</span> <span class="operator">=</span> (sum + n - <span class="number">1</span>) / n;<span class="comment">//向上取整</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//模板</span></span><br><span class="line">        <span class="type">long</span> m, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="comment">//电脑同时运行的分钟数</span></span><br><span class="line">            m = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (can(n, batteries, m))&#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">                ans = m;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//n台电脑能否同时运行limit分钟？</span></span><br><span class="line">    <span class="comment">//有点贪心思想</span></span><br><span class="line">    <span class="comment">//电脑取电池策略：</span></span><br><span class="line">    <span class="comment">//如果batteries[i] &gt;= limit 直接给某台电脑用</span></span><br><span class="line">    <span class="comment">//分配完剩下的电池m都是小于limit的。如果电池总量 / 电脑数 &gt;= limit（即每台电脑平均运行时间）。则也符合条件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">can</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] batteries, <span class="type">long</span> limit)</span>&#123;</span><br><span class="line">        <span class="comment">//区分电池</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; batteries.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (batteries[i] &gt;= limit)&#123;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                sum += batteries[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历过程中发现，已经能提供所有电脑同时运行  直接退出</span></span><br><span class="line">            <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (sum / n ) &gt;= limit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二分答案法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分答案法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刀砍毒杀怪兽问题</title>
      <link href="/2024/05/28/%E5%88%80%E7%A0%8D%E6%AF%92%E6%9D%80%E6%80%AA%E5%85%BD%E9%97%AE%E9%A2%98/"/>
      <url>/2024/05/28/%E5%88%80%E7%A0%8D%E6%AF%92%E6%9D%80%E6%80%AA%E5%85%BD%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h3><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&gt;刀砍毒杀怪兽问题</span><br><span class="line">&gt;怪兽的初始血量是一个整数hp，给出每一回合刀砍和毒杀的数值cuts和poisons</span><br><span class="line">&gt;第i回合如果用刀砍，怪兽在这回合会直接损失cuts[i]的血，不再有后续效果</span><br><span class="line">&gt;第i回合如果用毒杀，怪兽在这回合不会损失血量，但是之后每回合都损失poisons[i]的血量</span><br><span class="line">&gt;并且你选择的所有毒杀效果，在之后的回合都会叠加</span><br><span class="line">&gt;两个数组cuts、poisons，长度都是n，代表你一共可以进行n回合</span><br><span class="line">&gt;每一回合你只能选择刀砍或者毒杀中的一个动作</span><br><span class="line">&gt;如果你在n个回合内没有直接杀死怪兽，意味着你已经无法有新的行动了</span><br><span class="line">&gt;但是怪兽如果有中毒效果的话，那么怪兽依然会在血量耗尽的那回合死掉</span><br><span class="line">&gt;返回至少多少回合，怪兽会死掉</span><br><span class="line">&gt;数据范围 :</span><br><span class="line">&gt;1 &lt;= n &lt;= 10^5</span><br><span class="line">&gt;1 &lt;= hp &lt;= 10^9</span><br><span class="line">&gt;1 &lt;= cuts[i]、poisons[i] &lt;= 10^9</span><br><span class="line">&gt;本题来自真实大厂笔试，找不到测试链接，所以用对数器验证</span><br></pre></td></tr></table></figure></blockquote><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CutOrPoison</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//只要有用毒杀，那怪兽总会在某一回合死掉，求至少几回合死掉。 -》 即总有答案，求最小答案，看是否能用二分答案法。</span></span><br><span class="line">    <span class="comment">//单调性分析：造成的伤害效果越高，怪兽死得越快。符合单调性。所以用二分答案法解题</span></span><br><span class="line">    <span class="comment">//题目转换为：当回合数为x时，怪兽能否被杀死？</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fast2</span><span class="params">(<span class="type">int</span>[] cuts, <span class="type">int</span>[] poisons, <span class="type">int</span> hp)</span> &#123;</span><br><span class="line">        <span class="comment">//求答案范围</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> hp + <span class="number">1</span>;<span class="comment">//每回合都伤害1点血,那至少要到hp + 1回合</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//至少1回合</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="comment">//在mid回合内，怪兽能否被杀死</span></span><br><span class="line">            mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (killed(mid, cuts, poisons, hp))&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有点贪心思想，哪个伤害高就选哪个</span></span><br><span class="line">    <span class="comment">//其中毒杀的伤害计算为 x * mid</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">killed</span><span class="params">(<span class="type">int</span> mid, <span class="type">int</span>[] cuts, <span class="type">int</span>[] poisons, <span class="type">long</span> hp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(poisons.length, mid);</span><br><span class="line">        <span class="comment">//取可操作的回合数</span></span><br><span class="line">        <span class="comment">//这里要注意毒杀伤害的计算，从下一回合开始才生效，即j</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">1</span>; i &lt; min; i++, j++) &#123;</span><br><span class="line">            <span class="comment">//哪个伤害高就取哪个</span></span><br><span class="line">            <span class="comment">//首个回合不计算血量，以剩余回合数 计算毒杀伤害</span></span><br><span class="line">            hp -= Math.max((<span class="type">long</span>)(mid - j) * poisons[i], (<span class="type">long</span>) cuts[i]);</span><br><span class="line">            <span class="keyword">if</span> (hp &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态规划方法(只是为了验证)</span></span><br><span class="line">    <span class="comment">// 目前没有讲动态规划，所以不需要理解这个函数</span></span><br><span class="line">    <span class="comment">// 这个函数只是为了验证二分答案的方法是否正确的</span></span><br><span class="line">    <span class="comment">// 纯粹为了写对数器验证才设计的方法，血量比较大的时候会超时</span></span><br><span class="line">    <span class="comment">// 这个方法不做要求，此时并不需要理解，可以在学习完动态规划章节之后来看看这个函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fast1</span><span class="params">(<span class="type">int</span>[] cuts, <span class="type">int</span>[] poisons, <span class="type">int</span> hp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : poisons) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[cuts.length][hp + <span class="number">1</span>][sum + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> f1(cuts, poisons, <span class="number">0</span>, hp, <span class="number">0</span>, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不做要求</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span>[] cuts, <span class="type">int</span>[] poisons, <span class="type">int</span> i, <span class="type">int</span> r, <span class="type">int</span> p, <span class="type">int</span>[][][] dp)</span> &#123;</span><br><span class="line">        r -= p;</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == cuts.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> cuts.length + <span class="number">1</span> + (r + p - <span class="number">1</span>) / p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][r][p] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[i][r][p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> r &lt;= cuts[i] ? (i + <span class="number">1</span>) : f1(cuts, poisons, i + <span class="number">1</span>, r - cuts[i], p, dp);</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> f1(cuts, poisons, i + <span class="number">1</span>, r, p + poisons[i], dp);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Math.min(p1, p2);</span><br><span class="line">        dp[i][r][p] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对数器测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 随机测试的数据量不大</span></span><br><span class="line">        <span class="comment">// 因为数据量大了，fast1方法会超时</span></span><br><span class="line">        <span class="comment">// 所以在数据量不大的情况下，验证fast2方法功能正确即可</span></span><br><span class="line">        <span class="comment">// fast2方法在大数据量的情况下一定也能通过</span></span><br><span class="line">        <span class="comment">// 因为时间复杂度就是最优的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;测试开始&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">V</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">H</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">testTimes</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTimes; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * N) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span>[] cuts = randomArray(n, V);</span><br><span class="line">            <span class="type">int</span>[] posions = randomArray(n, V);</span><br><span class="line">            <span class="type">int</span> <span class="variable">hp</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * H) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> fast1(cuts, posions, hp);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> fast2(cuts, posions, hp);</span><br><span class="line">            <span class="keyword">if</span> (ans1 != ans2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;出错了!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对数器测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] randomArray(<span class="type">int</span> n, <span class="type">int</span> v) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans[i] = (<span class="type">int</span>) (Math.random() * v) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二分答案法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分答案法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CutOrPoison</title>
      <link href="/2024/05/28/CutOrPoison/"/>
      <url>/2024/05/28/CutOrPoison/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.二分答案法;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> CutOrPoison</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/5/28 10:53</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 刀砍毒杀怪兽问题</span></span><br><span class="line"><span class="comment">// 怪兽的初始血量是一个整数hp，给出每一回合刀砍和毒杀的数值cuts和poisons</span></span><br><span class="line"><span class="comment">// 第i回合如果用刀砍，怪兽在这回合会直接损失cuts[i]的血，不再有后续效果</span></span><br><span class="line"><span class="comment">// 第i回合如果用毒杀，怪兽在这回合不会损失血量，但是之后每回合都损失poisons[i]的血量</span></span><br><span class="line"><span class="comment">// 并且你选择的所有毒杀效果，在之后的回合都会叠加</span></span><br><span class="line"><span class="comment">// 两个数组cuts、poisons，长度都是n，代表你一共可以进行n回合</span></span><br><span class="line"><span class="comment">// 每一回合你只能选择刀砍或者毒杀中的一个动作</span></span><br><span class="line"><span class="comment">// 如果你在n个回合内没有直接杀死怪兽，意味着你已经无法有新的行动了</span></span><br><span class="line"><span class="comment">// 但是怪兽如果有中毒效果的话，那么怪兽依然会在血量耗尽的那回合死掉</span></span><br><span class="line"><span class="comment">// 返回至少多少回合，怪兽会死掉</span></span><br><span class="line"><span class="comment">// 数据范围 :</span></span><br><span class="line"><span class="comment">// 1 &lt;= n &lt;= 10^5</span></span><br><span class="line"><span class="comment">// 1 &lt;= hp &lt;= 10^9</span></span><br><span class="line"><span class="comment">// 1 &lt;= cuts[i]、poisons[i] &lt;= 10^9</span></span><br><span class="line"><span class="comment">// 本题来自真实大厂笔试，找不到测试链接，所以用对数器验证</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CutOrPoison</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//只要有用毒杀，那怪兽总会在某一回合死掉，求至少几回合死掉。 -》 即总有答案，求最小答案，看是否能用二分答案法。</span></span><br><span class="line">    <span class="comment">//单调性分析：造成的伤害效果越高，怪兽死得越快。符合单调性。所以用二分答案法解题</span></span><br><span class="line">    <span class="comment">//题目转换为：当回合数为x时，怪兽能否被杀死？</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fast2</span><span class="params">(<span class="type">int</span>[] cuts, <span class="type">int</span>[] poisons, <span class="type">int</span> hp)</span> &#123;</span><br><span class="line">        <span class="comment">//求答案范围</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> hp + <span class="number">1</span>;<span class="comment">//每回合都伤害1点血,那至少要到hp + 1回合</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>; <span class="comment">//至少1回合</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, mid = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="comment">//在mid回合内，怪兽能否被杀死</span></span><br><span class="line">            mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (killed(mid, cuts, poisons, hp))&#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">                ans = mid;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有点贪心思想，哪个伤害高就选哪个</span></span><br><span class="line">    <span class="comment">//其中毒杀的伤害计算为 x * mid</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">killed</span><span class="params">(<span class="type">int</span> mid, <span class="type">int</span>[] cuts, <span class="type">int</span>[] poisons, <span class="type">long</span> hp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Math.min(poisons.length, mid);</span><br><span class="line">        <span class="comment">//取可操作的回合数</span></span><br><span class="line">        <span class="comment">//这里要注意毒杀伤害的计算，从下一回合开始才生效，即j</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = <span class="number">1</span>; i &lt; min; i++, j++) &#123;</span><br><span class="line">            <span class="comment">//哪个伤害高就取哪个</span></span><br><span class="line">            <span class="comment">//首个回合不计算血量，以剩余回合数 计算毒杀伤害</span></span><br><span class="line">            hp -= Math.max((<span class="type">long</span>)(mid - j) * poisons[i], (<span class="type">long</span>) cuts[i]);</span><br><span class="line">            <span class="keyword">if</span> (hp &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 动态规划方法(只是为了验证)</span></span><br><span class="line">    <span class="comment">// 目前没有讲动态规划，所以不需要理解这个函数</span></span><br><span class="line">    <span class="comment">// 这个函数只是为了验证二分答案的方法是否正确的</span></span><br><span class="line">    <span class="comment">// 纯粹为了写对数器验证才设计的方法，血量比较大的时候会超时</span></span><br><span class="line">    <span class="comment">// 这个方法不做要求，此时并不需要理解，可以在学习完动态规划章节之后来看看这个函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">fast1</span><span class="params">(<span class="type">int</span>[] cuts, <span class="type">int</span>[] poisons, <span class="type">int</span> hp)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : poisons) &#123;</span><br><span class="line">            sum += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[][][] dp = <span class="keyword">new</span> <span class="title class_">int</span>[cuts.length][hp + <span class="number">1</span>][sum + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">return</span> f1(cuts, poisons, <span class="number">0</span>, hp, <span class="number">0</span>, dp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不做要求</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f1</span><span class="params">(<span class="type">int</span>[] cuts, <span class="type">int</span>[] poisons, <span class="type">int</span> i, <span class="type">int</span> r, <span class="type">int</span> p, <span class="type">int</span>[][][] dp)</span> &#123;</span><br><span class="line">        r -= p;</span><br><span class="line">        <span class="keyword">if</span> (r &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == cuts.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> cuts.length + <span class="number">1</span> + (r + p - <span class="number">1</span>) / p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dp[i][r][p] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> dp[i][r][p];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> r &lt;= cuts[i] ? (i + <span class="number">1</span>) : f1(cuts, poisons, i + <span class="number">1</span>, r - cuts[i], p, dp);</span><br><span class="line">        <span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> f1(cuts, poisons, i + <span class="number">1</span>, r, p + poisons[i], dp);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Math.min(p1, p2);</span><br><span class="line">        dp[i][r][p] = ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对数器测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 随机测试的数据量不大</span></span><br><span class="line">        <span class="comment">// 因为数据量大了，fast1方法会超时</span></span><br><span class="line">        <span class="comment">// 所以在数据量不大的情况下，验证fast2方法功能正确即可</span></span><br><span class="line">        <span class="comment">// fast2方法在大数据量的情况下一定也能通过</span></span><br><span class="line">        <span class="comment">// 因为时间复杂度就是最优的</span></span><br><span class="line">        System.out.println(<span class="string">&quot;测试开始&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">V</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">H</span> <span class="operator">=</span> <span class="number">300</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">testTimes</span> <span class="operator">=</span> <span class="number">10000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTimes; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * N) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span>[] cuts = randomArray(n, V);</span><br><span class="line">            <span class="type">int</span>[] posions = randomArray(n, V);</span><br><span class="line">            <span class="type">int</span> <span class="variable">hp</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * H) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> fast1(cuts, posions, hp);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> fast2(cuts, posions, hp);</span><br><span class="line">            <span class="keyword">if</span> (ans1 != ans2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;出错了!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对数器测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] randomArray(<span class="type">int</span> n, <span class="type">int</span> v) &#123;</span><br><span class="line">        <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans[i] = (<span class="type">int</span>) (Math.random() * v) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二分答案法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分答案法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>WaitingTime</title>
      <link href="/2024/05/27/WaitingTime/"/>
      <url>/2024/05/27/WaitingTime/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.二分答案法;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> WaitingTime</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/5/27 17:50</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 计算等位时间</span></span><br><span class="line"><span class="comment">// 给定一个数组arr长度为n，表示n个服务员，每服务一个人的时间</span></span><br><span class="line"><span class="comment">// 给定一个正数m，表示有m个人等位，如果你是刚来的人，请问你需要等多久？</span></span><br><span class="line"><span class="comment">// 假设m远远大于n，比如n &lt;= 10^3, m &lt;= 10^9，该怎么做是最优解？</span></span><br><span class="line"><span class="comment">// 谷歌的面试，这个题连考了2个月</span></span><br><span class="line"><span class="comment">// 找不到测试链接，所以用对数器验证</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">WaitingTime</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接最小堆，i , 已服务时间p</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">waitingTime1</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> m)</span>&#123;</span><br><span class="line">        <span class="comment">//空闲不用等</span></span><br><span class="line">        <span class="keyword">if</span> (m &lt; arr.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//每服务一个人的时长i, 总服务时间p</span></span><br><span class="line">        <span class="comment">//构建最小堆，根据总服务时长排列</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(Comparator.comparingInt(a -&gt; a[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            queue.add(<span class="keyword">new</span> <span class="title class_">int</span>[]&#123;arr[i], <span class="number">0</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="comment">//弹出并增加服务时长</span></span><br><span class="line">            <span class="type">int</span>[] poll = queue.poll();</span><br><span class="line">            poll[<span class="number">1</span>] += poll[<span class="number">0</span>];</span><br><span class="line">            queue.add(poll);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//此时堆顶就是等待时间</span></span><br><span class="line">        <span class="keyword">return</span> queue.peek()[<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//二分答案求解</span></span><br><span class="line">    <span class="comment">//问题转化为当服务时间是x时，一共服务了y人，y &gt; m?</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">waitingTime2</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> m)</span>&#123;</span><br><span class="line">        <span class="comment">//求答案最大范围</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i : arr) &#123;</span><br><span class="line">            r = Math.max(i, r);</span><br><span class="line">        &#125;</span><br><span class="line">        r = r * m;</span><br><span class="line">        <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="comment">//以等待时间，即每个服务员必须工作的时间</span></span><br><span class="line">            mid = l + ((r-l)&gt;&gt;<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (canService(mid, arr) &gt; m)&#123;</span><br><span class="line">                ans = mid;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个服务员必须工作min分钟，一共能服务多少人</span></span><br><span class="line">    <span class="comment">//一般到了这一步就是自然智慧的解题思路</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">canService</span><span class="params">(<span class="type">int</span> min, <span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> n : arr) &#123;</span><br><span class="line">            ans += min / n + <span class="number">1</span>;<span class="comment">//结束的、开始的客人都算</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 堆模拟</span></span><br><span class="line">    <span class="comment">// 验证方法，不是重点</span></span><br><span class="line">    <span class="comment">// 如果m很大，该方法会超时</span></span><br><span class="line">    <span class="comment">// 时间复杂度O(m * log(n))，额外空间复杂度O(n)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">waitingTime3</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="comment">// 一个一个对象int[]</span></span><br><span class="line">        <span class="comment">// [醒来时间，服务一个客人要多久]</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; heap = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((a, b) -&gt; (a[<span class="number">0</span>] - b[<span class="number">0</span>]));</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            heap.add(<span class="keyword">new</span> <span class="title class_">int</span>[] &#123; <span class="number">0</span>, arr[i] &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="type">int</span>[] cur = heap.poll();</span><br><span class="line">            cur[<span class="number">0</span>] += cur[<span class="number">1</span>];</span><br><span class="line">            heap.add(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> heap.peek()[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 二分答案法</span></span><br><span class="line">    <span class="comment">// 最优解</span></span><br><span class="line">    <span class="comment">// 时间复杂度O(n * log(min * w))，额外空间复杂度O(1)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">waitingTime4</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> w)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> x : arr) &#123;</span><br><span class="line">            min = Math.min(min, x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = min * w, m; l &lt;= r;) &#123;</span><br><span class="line">            <span class="comment">// m中点，表示一定要让服务员工作的时间！</span></span><br><span class="line">            m = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 能够给几个客人提供服务</span></span><br><span class="line">            <span class="keyword">if</span> (f(arr, m) &gt;= w + <span class="number">1</span>) &#123;</span><br><span class="line">                ans = m;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果每个服务员工作time，可以接待几位客人（结束的、开始的客人都算）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> time)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : arr) &#123;</span><br><span class="line">            ans += (time / num) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对数器测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试开始&quot;</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">50</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">V</span> <span class="operator">=</span> <span class="number">30</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">M</span> <span class="operator">=</span> <span class="number">3000</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">testTime</span> <span class="operator">=</span> <span class="number">20000</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTime; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * N) + <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span>[] arr = randomArray(n, V);</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * M);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> waitingTime1(arr, m);</span><br><span class="line">            <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> waitingTime2(arr, m);</span><br><span class="line">            <span class="comment">// int ans1 = waitingTime1(arr, m);</span></span><br><span class="line">            <span class="comment">// int ans2 = waitingTime3(arr, m);</span></span><br><span class="line">            <span class="keyword">if</span> (ans1 != ans2) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;出错了!&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对数器测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] randomArray(<span class="type">int</span> n, <span class="type">int</span> v) &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            arr[i] = (<span class="type">int</span>) (Math.random() * v) + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二分答案法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分答案法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MaxRunTime</title>
      <link href="/2024/05/27/MaxRunTime/"/>
      <url>/2024/05/27/MaxRunTime/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.二分答案法;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> MaxRunTime</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/5/27 17:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 同时运行N台电脑的最长时间</span></span><br><span class="line"><span class="comment">// 你有 n 台电脑。给你整数 n 和一个下标从 0 开始的整数数组 batteries</span></span><br><span class="line"><span class="comment">// 其中第 i 个电池可以让一台电脑 运行 batteries[i] 分钟</span></span><br><span class="line"><span class="comment">// 你想使用这些电池让 全部 n 台电脑 同时 运行。</span></span><br><span class="line"><span class="comment">// 一开始，你可以给每台电脑连接 至多一个电池</span></span><br><span class="line"><span class="comment">// 然后在任意整数时刻，你都可以将一台电脑与它的电池断开连接，并连接另一个电池，你可以进行这个操作 任意次</span></span><br><span class="line"><span class="comment">// 新连接的电池可以是一个全新的电池，也可以是别的电脑用过的电池</span></span><br><span class="line"><span class="comment">// 断开连接和连接新的电池不会花费任何时间。</span></span><br><span class="line"><span class="comment">// 注意，你不能给电池充电。</span></span><br><span class="line"><span class="comment">// 请你返回你可以让 n 台电脑同时运行的 最长 分钟数。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/maximum-running-time-of-n-computers/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxRunTime</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//二分答案法，分析单调性：电池越大，能同时运行时间越久。即答案运行分钟数m和电池之间有单调性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maxRunTime1</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] batteries)</span> &#123;</span><br><span class="line">        <span class="comment">//获取答案最大范围</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> battery : batteries) &#123;</span><br><span class="line">            sum += battery;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">r</span> <span class="operator">=</span> (sum + n - <span class="number">1</span>) / n;<span class="comment">//向上取整</span></span><br><span class="line">        <span class="comment">//直接拿最大值去试，只要验证小于limit的电池总量，是否符合条件即可</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">avg</span> <span class="operator">=</span> sum / n;</span><br><span class="line">        <span class="keyword">if</span> (can(n, batteries, avg))&#123;</span><br><span class="line">            <span class="keyword">return</span> avg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//模板</span></span><br><span class="line">        <span class="type">long</span> m, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="comment">//电脑同时运行的分钟数</span></span><br><span class="line">            m = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (can(n, batteries, m))&#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">                ans = m;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//原基础上加点贪心</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">maxRunTime</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] batteries)</span> &#123;</span><br><span class="line">        <span class="comment">//获取答案最大范围</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> battery : batteries) &#123;</span><br><span class="line">            sum += battery;</span><br><span class="line">            max = Math.max(battery, max);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果电池总量 &gt; 最大电池 * 电脑数.</span></span><br><span class="line">        <span class="comment">// 说明 : 最终的供电时间一定在 &gt;= max，而如果最终的供电时间 &gt;= max (即没有一台电脑是能够单独一个电池供电完毕）</span></span><br><span class="line">        <span class="comment">// 说明 : 对于最终的答案X来说，所有电池都是课上讲的&quot;碎片拼接&quot;的概念</span></span><br><span class="line">        <span class="comment">// 那么直接返回最大时间即可 -》平均值</span></span><br><span class="line">        <span class="keyword">if</span> (sum &gt; (<span class="type">long</span>) max * n)&#123;</span><br><span class="line">            <span class="keyword">return</span> sum / n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">r</span> <span class="operator">=</span> (sum + n - <span class="number">1</span>) / n;<span class="comment">//向上取整</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//模板</span></span><br><span class="line">        <span class="type">long</span> m, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="comment">//电脑同时运行的分钟数</span></span><br><span class="line">            m = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (can(n, batteries, m))&#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">                ans = m;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//n台电脑能否同时运行limit分钟？</span></span><br><span class="line">    <span class="comment">//有点贪心思想</span></span><br><span class="line">    <span class="comment">//电脑取电池策略：</span></span><br><span class="line">    <span class="comment">//如果batteries[i] &gt;= limit 直接给某台电脑用</span></span><br><span class="line">    <span class="comment">//分配完剩下的电池m都是小于limit的。如果电池总量 / 电脑数 &gt;= limit（即每台电脑平均运行时间）。则也符合条件</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">can</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span>[] batteries, <span class="type">long</span> limit)</span>&#123;</span><br><span class="line">        <span class="comment">//区分电池</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; batteries.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (batteries[i] &gt;= limit)&#123;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                sum += batteries[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遍历过程中发现，已经能提供所有电脑同时运行  直接退出</span></span><br><span class="line">            <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (sum / n ) &gt;= limit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二分答案法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分答案法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SmallestDistancePair</title>
      <link href="/2024/05/27/SmallestDistancePair/"/>
      <url>/2024/05/27/SmallestDistancePair/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.二分答案法;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> SmallestDistancePair</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/5/27 17:06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">// 找出第K小的数对距离</span></span><br><span class="line"><span class="comment">// 数对 (a,b) 由整数 a 和 b 组成，其数对距离定义为 a 和 b 的绝对差值。</span></span><br><span class="line"><span class="comment">// 给你一个整数数组 nums 和一个整数 k</span></span><br><span class="line"><span class="comment">// 数对由 nums[i] 和 nums[j] 组成且满足 0 &lt;= i &lt; j &lt; nums.length</span></span><br><span class="line"><span class="comment">// 返回 所有数对距离中 第 k 小的数对距离。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/find-k-th-smallest-pair-distance/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmallestDistancePair</span> &#123;</span><br><span class="line">    <span class="comment">//有点神奇的题目。用二分答案法来解的话。</span></span><br><span class="line">    <span class="comment">//对数组排序，将问题转换为当数对距离小于等于答案m时，这样的有几对（根据数数来算排名和k对比）</span></span><br><span class="line">    <span class="comment">//分析二分答案的单调性：很明显数对距离和k之间有直接的关系，k就是数对距离的排名。数对距离越大，k越大</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">smallestDistancePair</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//求二分答案最大范围</span></span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> m, l = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> nums[nums.length - <span class="number">1</span>] - nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="comment">//所有数对距离 &lt;= m 有几对？</span></span><br><span class="line">            m =  (r + l) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//看答案和指标的关系</span></span><br><span class="line">            <span class="keyword">if</span> (find(m, nums) &gt;= k)&#123;</span><br><span class="line">                ans = m;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数对距离为m时，在数组中是第x小 （第x小 -》 小于等于x小的有多少）</span></span><br><span class="line">    <span class="comment">//其实就是数对距离小于等于m的有多少对</span></span><br><span class="line">    <span class="comment">//直接滑动窗口：</span></span><br><span class="line">    <span class="comment">//单调性分析，从左到右的数对，越往右 窗口内的数对越大，（每个窗口内数对的最大值，越靠右越大）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//定左扩右</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>; l &lt; nums.length; l++) &#123;</span><br><span class="line">            <span class="comment">//符合条件就右扩</span></span><br><span class="line">            <span class="comment">//这里写r + 1是只有当r + 1符合条件了，才让r++,即当前r是窗口内的</span></span><br><span class="line">            <span class="keyword">while</span> (r + <span class="number">1</span> &lt; nums.length &amp;&amp; nums[r + <span class="number">1</span>] - nums[l] &lt;= m)&#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//窗口内所有符合条件的数对距离</span></span><br><span class="line">            ans += r - l;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二分答案法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分答案法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RobotPassThroughBuilding</title>
      <link href="/2024/05/27/RobotPassThroughBuilding/"/>
      <url>/2024/05/27/RobotPassThroughBuilding/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.二分答案法;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> RobotPassThroughBuilding</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/5/27 14:18</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">// 机器人跳跃问题</span></span><br><span class="line"><span class="comment">// 机器人正在玩一个古老的基于DOS的游戏</span></span><br><span class="line"><span class="comment">// 游戏中有N+1座建筑，从0到N编号，从左到右排列</span></span><br><span class="line"><span class="comment">// 编号为0的建筑高度为0个单位，编号为i的建筑的高度为H(i)个单位</span></span><br><span class="line"><span class="comment">// 起初机器人在编号为0的建筑处</span></span><br><span class="line"><span class="comment">// 每一步，它跳到下一个（右边）建筑。假设机器人在第k个建筑，且它现在的能量值是E</span></span><br><span class="line"><span class="comment">// 下一步它将跳到第个k+1建筑</span></span><br><span class="line"><span class="comment">// 它将会得到或者失去正比于与H(k+1)与E之差的能量</span></span><br><span class="line"><span class="comment">// 如果 H(k+1) &gt; E 那么机器人就失去H(k+1)-E的能量值，否则它将得到E-H(k+1)的能量值</span></span><br><span class="line"><span class="comment">// 游戏目标是到达第个N建筑，在这个过程中，能量值不能为负数个单位</span></span><br><span class="line"><span class="comment">// 现在的问题是机器人以多少能量值开始游戏，才可以保证成功完成游戏</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.nowcoder.com/practice/7037a3d57bbd4336856b8e16a9cafd71</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下的code，提交时请把类名改成&quot;Main&quot;，可以直接通过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入描述：</span></span><br><span class="line"><span class="comment">// 第一行输入，表示一共有 N 组数据.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// 第二个是 N 个空格分隔的整数，H1, H2, H3, ..., Hn 代表建筑物的高度</span></span><br><span class="line"><span class="comment">// 输出描述：</span></span><br><span class="line"><span class="comment">// 输出一个单独的数表示完成游戏所需的最少单位的初始能量</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RobotPassThroughBuilding</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">100001</span>;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bf</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(bf);</span><br><span class="line">        <span class="keyword">while</span> (st.nextToken() != StreamTokenizer.TT_EOF)&#123;</span><br><span class="line">            N = (<span class="type">int</span>) st.nval;</span><br><span class="line">            <span class="comment">//获取答案最大值</span></span><br><span class="line">            <span class="comment">//因为是和当前能量值做对比，所以只要能量是最大高度，则一定能过关</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="comment">//这里有个坑，第0个柱子是不用计算的。</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">int</span>) st.nval;</span><br><span class="line">                arr[i] = n;</span><br><span class="line">                max = Math.max(max, n);</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(getInitPower(max));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        bf.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取机器人初始能量</span></span><br><span class="line">    <span class="comment">//答案和问题指标之间存在单调性，（答案越大，问题指标越容易实现，否则反之），所以用二分答案法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">getInitPower</span><span class="params">(<span class="type">int</span> max)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> max;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            m = l + ((r - l) / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">if</span> (can(m, max))&#123;</span><br><span class="line">                ans = m;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当初始能量为m时，能否通过所有柱子</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">can</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> max)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> m;</span><br><span class="line">        <span class="comment">// 注意！</span></span><br><span class="line">        <span class="comment">// 如果给的能量值很大，那么后续能量增长将非常恐怖</span></span><br><span class="line">        <span class="comment">// 完全有可能超出long的范围</span></span><br><span class="line">        <span class="comment">// 所以要在遍历时，一定要加入energy &gt;= max的判断</span></span><br><span class="line">        <span class="comment">// 一旦能量超过高度最大值，后面肯定通关了，可以提前返回了</span></span><br><span class="line">        <span class="comment">// 这里很阴</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">            count += count - arr[i];</span><br><span class="line">            <span class="comment">//查过最大值肯定能通过</span></span><br><span class="line">            <span class="keyword">if</span> (count &gt;= max)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (count &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二分答案法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分答案法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SplitArrayLargestSum</title>
      <link href="/2024/05/27/SplitArrayLargestSum/"/>
      <url>/2024/05/27/SplitArrayLargestSum/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.二分答案法;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> SplitArrayLargestSum</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/5/27 11:46</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 分割数组的最大值(画匠问题)</span></span><br><span class="line"><span class="comment">// 给定一个非负整数数组 nums 和一个整数 m</span></span><br><span class="line"><span class="comment">// 你需要将这个数组分成 m 个非空的连续子数组。</span></span><br><span class="line"><span class="comment">// 设计一个算法使得这 m 个子数组各自和的最大值最小。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/split-array-largest-sum/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SplitArrayLargestSum</span> &#123;</span><br><span class="line">    <span class="comment">//二分答案法，转换下逻辑</span></span><br><span class="line">    <span class="comment">//当数组最大和是 x时，能否把数组分成k个？</span></span><br><span class="line">    <span class="comment">//所以二分答案数组最大和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">splitArray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="comment">//定义答案范围</span></span><br><span class="line">        <span class="comment">//数组和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            r += num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (can(nums, k, m))&#123;</span><br><span class="line">                ans = m;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断子数组最大和是x下，能否分成k个数组 -》 符合最大和x的子数组小于等于k</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">can</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k, <span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>; r &lt; nums.length; r++) &#123;</span><br><span class="line">            <span class="comment">//如果某个数大于x，直接退出</span></span><br><span class="line">            <span class="keyword">if</span> (nums[r] &gt; x)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (sum + nums[r] &gt; x)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="comment">//直接从这开始计数</span></span><br><span class="line">                sum = nums[r];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                sum += nums[r];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加上最后一组数</span></span><br><span class="line">        ans++;</span><br><span class="line">        <span class="keyword">return</span> ans &lt;= k;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二分答案法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分答案法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinEatingSpeed</title>
      <link href="/2024/05/27/MinEatingSpeed/"/>
      <url>/2024/05/27/MinEatingSpeed/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.二分答案法;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> MinEatingSpeed</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/5/27 11:04</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">// 爱吃香蕉的珂珂</span></span><br><span class="line"><span class="comment">// 珂珂喜欢吃香蕉。这里有 n 堆香蕉，第 i 堆中有 piles[i] 根香蕉</span></span><br><span class="line"><span class="comment">// 警卫已经离开了，将在 h 小时后回来。</span></span><br><span class="line"><span class="comment">// 珂珂可以决定她吃香蕉的速度 k （单位：根/小时)</span></span><br><span class="line"><span class="comment">// 每个小时，她将会选择一堆香蕉，从中吃掉 k 根</span></span><br><span class="line"><span class="comment">// 如果这堆香蕉少于 k 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉</span></span><br><span class="line"><span class="comment">// 珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</span></span><br><span class="line"><span class="comment">// 返回她可以在 h 小时内吃掉所有香蕉的最小速度 k（k 为整数）</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/koko-eating-bananas/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinEatingSpeed</span> &#123;</span><br><span class="line">    <span class="comment">//求最小速度k，满足在h小时内吃光。</span></span><br><span class="line">    <span class="comment">// 即总有k能吃完，求最小答案。直接二分答案法求k。条件逻辑是判断k是否能在h小时吃完</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minEatingSpeed</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">        <span class="comment">//二分答案法模板</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//求答案范围，最大范围就是数组最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> pile : piles) &#123;</span><br><span class="line">            r = Math.max(pile, r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//二分答案</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            m = l + ((r-l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (canEat(piles, h, m))&#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">                ans = m;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//问题主逻辑 判断k速度下，能否在h小时内吃完</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canEat</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> h, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; piles.length;i++) &#123;</span><br><span class="line">            <span class="comment">// (a/b)结果向上取整，如果a和b都是非负数，可以写成(a+b-1)/b</span></span><br><span class="line">            ans += (piles[i] + k - <span class="number">1</span>) / k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans &lt;= h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二分答案法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分答案法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>爱吃香蕉的珂珂</title>
      <link href="/2024/05/24/%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/"/>
      <url>/2024/05/24/%E7%88%B1%E5%90%83%E9%A6%99%E8%95%89%E7%9A%84%E7%8F%82%E7%8F%82/</url>
      
        <content type="html"><![CDATA[<h3 id="题目描述："><a href="#题目描述：" class="headerlink" title="题目描述："></a>题目描述：</h3><blockquote><p><strong>爱吃香蕉的珂珂</strong>  </p><p>珂珂喜欢吃香蕉。这里有 <code>n</code> 堆香蕉，第 <code>i</code> 堆中有 <code>piles[i]</code> 根香蕉。警卫已经离开了，将在 <code>h</code> 小时后回来。</p><p>珂珂可以决定她吃香蕉的速度 <code>k</code> （单位：根&#x2F;小时）。每个小时，她将会选择一堆香蕉，从中吃掉 <code>k</code> 根。如果这堆香蕉少于 <code>k</code> 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。 </p><p>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。</p><p>返回她可以在 <code>h</code> 小时内吃掉所有香蕉的最小速度 <code>k</code>（<code>k</code> 为整数）。</p><p>测试链接 : <a href="https://leetcode.cn/problems/koko-eating-bananas/">https://leetcode.cn/problems/koko-eating-bananas/</a>  </p></blockquote><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = [3,6,7,11], h = 8</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = [30,11,23,4,20], h = 5</span><br><span class="line">输出：30</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：piles = [30,11,23,4,20], h = 6</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure><h3 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinEatingSpeed</span> &#123;</span><br><span class="line">    <span class="comment">//求最小速度k，满足在h小时内吃光。</span></span><br><span class="line">    <span class="comment">// 即总有k能吃完，求最小答案。直接二分答案法求k。条件逻辑是判断k是否能在h小时吃完</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minEatingSpeed</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> h)</span> &#123;</span><br><span class="line">        <span class="comment">//二分答案法模板</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//求答案范围，最大范围就是数组最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> pile : piles) &#123;</span><br><span class="line">            r = Math.max(pile, r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//二分答案</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            m = l + ((r-l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (canEat(piles, h, m))&#123;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">                ans = m;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//问题主逻辑 判断k速度下，能否在h小时内吃完</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">canEat</span><span class="params">(<span class="type">int</span>[] piles, <span class="type">int</span> h, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; piles.length;i++) &#123;</span><br><span class="line">            <span class="comment">// (a/b)结果向上取整，如果a和b都是非负数，可以写成(a+b-1)/b</span></span><br><span class="line">            ans += (piles[i] + k - <span class="number">1</span>) / k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans &lt;= h;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二分答案法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分答案法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2024/05/23/hello-world/"/>
      <url>/2024/05/23/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 首个分类 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 第二个标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>my-first-blog</title>
      <link href="/2024/05/23/my-first-blog/"/>
      <url>/2024/05/23/my-first-blog/</url>
      
        <content type="html"><![CDATA[<p>我的第一个博客，markdown风格不太熟</p><p>用来记录学习过程。包括算法、常见框架、JVM、mysql等等</p><p>想搞个目录跳转，怎么搞呢？</p><span id="more"></span><p>以下是更多内容，敬请期待~~</p>]]></content>
      
      
      
        <tags>
            
            <tag> 首个标签 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LongestSubstring</title>
      <link href="/2024/05/14/LongestSubstring/"/>
      <url>/2024/05/14/LongestSubstring/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.滑动窗口;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> LongestSubstring</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/5/14 18:26</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 至少有K个重复字符的最长子串</span></span><br><span class="line"><span class="comment">// 给你一个字符串 s 和一个整数 k ，请你找出 s 中的最长子串</span></span><br><span class="line"><span class="comment">// 要求该子串中的每一字符出现次数都不少于 k 。返回这一子串的长度</span></span><br><span class="line"><span class="comment">// 如果不存在这样的子字符串，则返回 0。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/longest-substring-with-at-least-k-repeating-characters/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongestSubstring</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接题意是不符合滑动窗口单调性的，所以要转换</span></span><br><span class="line">    <span class="comment">//转换为，限定子串出现的字符种类数</span></span><br><span class="line">    <span class="comment">//子串只有1种字符时，每种字符出现次数&gt;= k，最长字串有多长</span></span><br><span class="line">    <span class="comment">//子串只有2种字符时，每种字符出现次数&gt;= k，最长字串有多长</span></span><br><span class="line">    <span class="comment">//子串只有3种字符时，每种字符出现次数&gt;= k，最长字串有多长</span></span><br><span class="line">    <span class="comment">// ....</span></span><br><span class="line">    <span class="comment">//子串只有26种字符时，每种字符出现次数&gt;= k，最长字串有多长</span></span><br><span class="line">    <span class="comment">//求所有结果中max</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//怎么求限定n种字符时，每种字符出现次数&gt;= k，最长字串长度呢？</span></span><br><span class="line">    <span class="comment">//用cnt数组统计窗口内的每个字符个数，用kind 统计窗口内字符种类，当 kind &gt; n 时左缩</span></span><br><span class="line">    <span class="comment">//用h统计次数达标字符的个数， 当h == n 时 统计长度len</span></span><br><span class="line">    <span class="comment">//正常右扩，统计cnt数组的字符个数, 种类数kind,达标数 h</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestSubstring</span><span class="params">(String s, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">26</span>; i++) &#123;</span><br><span class="line">            ans = Math.max(ans, findMaxLen(arr, i, k));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//限定字符种类数下，每种字符出现次数都大于等于k的最长长度</span></span><br><span class="line">    <span class="comment">//用cnt数组统计窗口内的每个字符个数，用kind 统计窗口内字符种类，当 kind &gt; n 时左缩</span></span><br><span class="line">    <span class="comment">//用h统计次数达标字符的个数， 当h == n 时 统计长度len</span></span><br><span class="line">    <span class="comment">//正常右扩，统计cnt数组的字符个数, 种类数kind,达标数 h</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaxLen</span><span class="params">(<span class="type">char</span>[] arr, <span class="type">int</span> n, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];<span class="comment">//字符出现次数</span></span><br><span class="line">        <span class="comment">//达标数h，种类数kind</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>, l = <span class="number">0</span>, h = <span class="number">0</span>, kind = <span class="number">0</span>; r &lt; arr.length; r++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[arr[r] - <span class="string">&#x27;a&#x27;</span>]++ == <span class="number">0</span>)&#123;</span><br><span class="line">                kind++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//刚加进来的，次数达标了</span></span><br><span class="line">            <span class="keyword">if</span> (cnt[arr[r] - <span class="string">&#x27;a&#x27;</span>] == k)&#123;</span><br><span class="line">                h++;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (kind &gt; n)&#123;</span><br><span class="line">                <span class="comment">//如果出现次数刚好达标,下面要扣减了，所以变成不达标</span></span><br><span class="line">                <span class="keyword">if</span> (cnt[arr[l] - <span class="string">&#x27;a&#x27;</span>] == k)&#123;</span><br><span class="line">                    h--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//如果扣减后次数为0，种类数 -1</span></span><br><span class="line">                <span class="keyword">if</span> (--cnt[arr[l++] - <span class="string">&#x27;a&#x27;</span>] == <span class="number">0</span>)&#123;</span><br><span class="line">                    kind--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//达标种类等于限定字符</span></span><br><span class="line">            <span class="keyword">if</span> (h == n)&#123;</span><br><span class="line">                ans = Math.max(ans, r - l + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SubarraysWithKDistinct</title>
      <link href="/2024/05/14/SubarraysWithKDistinct/"/>
      <url>/2024/05/14/SubarraysWithKDistinct/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.滑动窗口;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> SubarraysWithKDistinct</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/5/14 17:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// K个不同整数的子数组</span></span><br><span class="line"><span class="comment">// 给定一个正整数数组 nums和一个整数 k，返回 nums 中 「好子数组」 的数目。</span></span><br><span class="line"><span class="comment">// 如果 nums 的某个子数组中不同整数的个数恰好为 k</span></span><br><span class="line"><span class="comment">// 则称 nums 的这个连续、不一定不同的子数组为 「好子数组 」。</span></span><br><span class="line"><span class="comment">// 例如，[1,2,3,1,2] 中有 3 个不同的整数：1，2，以及 3。</span></span><br><span class="line"><span class="comment">// 子数组 是数组的 连续 部分。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/subarrays-with-k-different-integers/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubarraysWithKDistinct</span> &#123;</span><br><span class="line">    <span class="comment">//解题思路：因为无法直接统计刚好组成k个整数的所有子数组。（滑动窗口无法做到，会回退，但能得到小于等于k个不同整数的子数组）</span></span><br><span class="line">    <span class="comment">//所以转换思路： 小于等于K个子数组 - 小于等于k-1个子数组。</span></span><br><span class="line">    <span class="comment">// 这里滑动窗口的作用是找到 某个小于等于k个不同整数的子数组（非所有），再统计以当前位置结尾的所有子数组个数</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//其实单看题目，是不符合滑动窗口的单调性的，因为直接解题的话，滑动窗口大小不一，且可能回退。</span></span><br><span class="line">    <span class="comment">//求解怎么统计小于等于k个整数的数组？</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//难点在于怎么统计出现不同整数的个数 ? 用count统计</span></span><br><span class="line">    <span class="comment">//往右扩时，维护cnt</span></span><br><span class="line">    <span class="comment">// cnt &gt; k时 ，左缩，也维护cnt。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraysWithKDistinct</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> findLessEqual(nums, k) - findLessEqual(nums, k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">20001</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//小于等于k个不同整数的子数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findLessEqual</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        Arrays.fill(arr, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//这里右扩</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>, cnt = <span class="number">0</span>; r &lt; nums.length; r++) &#123;</span><br><span class="line">            <span class="comment">//右扩时，有新元素进来。加1</span></span><br><span class="line">            <span class="keyword">if</span> (arr[nums[r]]++ == <span class="number">0</span>)&#123;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//符合的子数组+1   不能这样统计，这里会忽略很多子数组</span></span><br><span class="line">            <span class="comment">// if (cnt &lt;= k)&#123;</span></span><br><span class="line">            <span class="comment">// ans++;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">//循环左缩</span></span><br><span class="line">            <span class="keyword">while</span> (cnt &gt; k)&#123;</span><br><span class="line">                <span class="comment">//左缩</span></span><br><span class="line">                <span class="keyword">if</span> (--arr[nums[l++]] == <span class="number">0</span>)&#123;</span><br><span class="line">                    cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//这里才是重点啊，如何统计符合条件的数组个数？ 直接统计以当前位置结尾的所以子数组</span></span><br><span class="line">            <span class="comment">//以当前位置结尾的子数组有几个。所以这里多次相加不会重复</span></span><br><span class="line">            <span class="comment">// l.....r不超过了</span></span><br><span class="line">            <span class="comment">// 0...3</span></span><br><span class="line">            <span class="comment">// 0~3</span></span><br><span class="line">            <span class="comment">// 1~3</span></span><br><span class="line">            <span class="comment">// 2~3</span></span><br><span class="line">            <span class="comment">// 3~3</span></span><br><span class="line">            ans += r - l + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BalancedString</title>
      <link href="/2024/05/13/BalancedString/"/>
      <url>/2024/05/13/BalancedString/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.滑动窗口;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> BalancedString</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/5/13 18:01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">// 替换子串得到平衡字符串</span></span><br><span class="line"><span class="comment">// 有一个只含有 &#x27;Q&#x27;, &#x27;W&#x27;, &#x27;E&#x27;, &#x27;R&#x27; 四种字符，且长度为 n 的字符串。</span></span><br><span class="line"><span class="comment">// 假如在该字符串中，这四个字符都恰好出现 n/4 次，那么它就是一个「平衡字符串」。</span></span><br><span class="line"><span class="comment">// 给你一个这样的字符串 s，请通过「替换一个子串」的方式，使原字符串 s 变成一个「平衡字符串」。</span></span><br><span class="line"><span class="comment">// 你可以用和「待替换子串」长度相同的 任何 其他字符串来完成替换。</span></span><br><span class="line"><span class="comment">// 请返回待替换子串的最小可能长度。</span></span><br><span class="line"><span class="comment">// 如果原字符串自身就是一个平衡字符串，则返回 0。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/replace-the-substring-for-balanced-string/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BalancedString</span> &#123;</span><br><span class="line">    <span class="comment">//将s统计各个字符次数后，减去最小次数（n/4)后，大于0的字符就是该字串要包含的字符</span></span><br><span class="line">    <span class="comment">//从而转换为最小覆盖字串问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">balancedString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] array = s.toCharArray();</span><br><span class="line">        <span class="type">int</span>[] cnts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">low</span> <span class="operator">=</span> s.length() / <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : array) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> toIndex(c);</span><br><span class="line">            cnts[index]++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            cnts[i] -= low;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnts[i] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                sb.append(toStr(i, cnts[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">tar</span> <span class="operator">=</span> sb.toString();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(tar))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minLen(s, tar);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最小覆盖字串，滑动窗口，直接统计负债dept</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">minLen</span><span class="params">(String s, String tar)</span>&#123;</span><br><span class="line">        <span class="type">char</span>[] sarr = s.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] tarr = tar.toCharArray();</span><br><span class="line">        <span class="comment">//用来统计负债情况</span></span><br><span class="line">        <span class="type">int</span>[] cnts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : tarr) &#123;</span><br><span class="line">            cnts[toIndex(c)]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>, l = <span class="number">0</span>,  dept = tarr.length; r &lt; sarr.length; r++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnts[toIndex(sarr[r])]++ &lt; <span class="number">0</span>)&#123;<span class="comment">//当前字符还不够</span></span><br><span class="line">                dept--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (dept == <span class="number">0</span>)&#123;<span class="comment">//当前字符够了</span></span><br><span class="line">                <span class="comment">//尝试左缩</span></span><br><span class="line">                <span class="keyword">while</span> (cnts[toIndex(sarr[l])] &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                    cnts[toIndex(sarr[l++])]--;<span class="comment">//回收字符</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (len &gt; r - l + <span class="number">1</span>)&#123;</span><br><span class="line">                    len = r - l + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">toIndex</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;Q&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;W&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;E&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;R&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">toStr</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; num; j++) &#123;</span><br><span class="line">            <span class="keyword">switch</span> (i)&#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    sb.append(<span class="string">&quot;Q&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                    sb.append(<span class="string">&quot;W&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                    sb.append(<span class="string">&quot;E&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                    sb.append(<span class="string">&quot;R&quot;</span>);<span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        balancedString(<span class="string">&quot;QQWE&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GasStation</title>
      <link href="/2024/05/13/GasStation/"/>
      <url>/2024/05/13/GasStation/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.滑动窗口;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> GasStation</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/5/13 15:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 加油站</span></span><br><span class="line"><span class="comment">// 在一条环路上有 n 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</span></span><br><span class="line"><span class="comment">// 你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升</span></span><br><span class="line"><span class="comment">// 你从其中的一个加油站出发，开始时油箱为空。</span></span><br><span class="line"><span class="comment">// 给定两个整数数组 gas 和 cost ，如果你可以按顺序绕环路行驶一周</span></span><br><span class="line"><span class="comment">// 则返回出发时加油站的编号，否则返回 -1</span></span><br><span class="line"><span class="comment">// 如果存在解，则 保证 它是 唯一 的。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/gas-station/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GasStation</span> &#123;</span><br><span class="line">    <span class="comment">//滑动窗口，单调性体现在 右侧不回退</span></span><br><span class="line">    <span class="comment">//思路：设定sum,当转一圈后sum大于等于0，则成功。记录start，len，当前index</span></span><br><span class="line">    <span class="comment">//定左，往右扩</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">canCompleteCircuit</span><span class="params">(<span class="type">int</span>[] gas, <span class="type">int</span>[] cost)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> gas.length;</span><br><span class="line">        <span class="comment">//滑动窗口，以sum为标准，sum为负时，左缩，否则右扩</span></span><br><span class="line">        <span class="comment">//定左，往右扩。定左时，就让循坏中自动左缩，所以下面代码主要右扩</span></span><br><span class="line">        <span class="comment">//何时右扩？sum&gt;=0</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>, l = <span class="number">0</span>, r = <span class="number">0</span>, sum = <span class="number">0</span>; l &lt; n; l++) &#123;</span><br><span class="line">            <span class="comment">//直接右扩</span></span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="comment">//这里把len拿到最前面来判断，是因为要保证sum 大于0的情况下，len已经转一圈</span></span><br><span class="line">                <span class="comment">//后面sum值被改了</span></span><br><span class="line">                <span class="comment">//所以说，代码首先要考虑边界条件</span></span><br><span class="line">                <span class="keyword">if</span> (len == n)&#123;</span><br><span class="line">                    <span class="keyword">return</span> l;</span><br><span class="line">                &#125;</span><br><span class="line">                sum += gas[r] - cost[r];</span><br><span class="line">                r = (r+<span class="number">1</span>) % n;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左缩</span></span><br><span class="line">            sum -= gas[l] - cost[l];</span><br><span class="line">            len--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinWindow</title>
      <link href="/2024/05/13/MinWindow/"/>
      <url>/2024/05/13/MinWindow/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.滑动窗口;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> MinWindow</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/5/13 11:24</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 最小覆盖子串</span></span><br><span class="line"><span class="comment">// 给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串</span></span><br><span class="line"><span class="comment">// 如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/minimum-window-substring/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinWindow</span> &#123;</span><br><span class="line">    <span class="comment">//滑动窗口 单调性体现在出现的字符次数。</span></span><br><span class="line">    <span class="comment">//解题思路为：像这种字串类型的，直接统计目标字符串的字符总数。再来个欠债数dept。当欠债数dept为0时，证明当前字串包含目标串所有字符 。</span></span><br><span class="line">    <span class="comment">//用什么来装目标字符呢？直接用数组装就可，范围都是英文字符</span></span><br><span class="line">    <span class="comment">// 怎么判断当前字串是否包含目标所有字符呢？噢，依赖右扩时，看欠债dept是否为0决定。</span></span><br><span class="line">    <span class="comment">//关键点在于，不用管目标字符是什么，只要包含目标所有字符就行了，即要dept是0就可以了</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minWindow</span><span class="params">(String s, String t)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() &lt; t.length()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] cnts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">256</span>];</span><br><span class="line">        <span class="type">char</span>[] tar = t.toCharArray();</span><br><span class="line">        <span class="type">char</span>[] sour = s.toCharArray();</span><br><span class="line">        <span class="comment">//减法可以用0来做分割线</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : tar) &#123;</span><br><span class="line">            cnts[c]--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录最小字串的开始</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">start</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录最小字串的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>, dept = t.length(); r &lt; sour.length; r++) &#123;</span><br><span class="line">            <span class="comment">//右扩，目标数组还没清零时，dept减少。若目标数为0以上，则不做任何处理</span></span><br><span class="line">            <span class="keyword">if</span> (cnts[sour[r]]++ &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                dept--;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//当前字串能覆盖目标数组</span></span><br><span class="line">            <span class="keyword">if</span> (dept == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span> (cnts[sour[l]] &gt; <span class="number">0</span>) &#123;<span class="comment">//将多余的串左缩</span></span><br><span class="line">                    cnts[sour[l++]]--;<span class="comment">//将该字符拿回</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//记录长度</span></span><br><span class="line">                <span class="keyword">if</span> (len &gt; r - l + <span class="number">1</span>) &#123;</span><br><span class="line">                    start = l;</span><br><span class="line">                    len = r - l + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//从当前字符开始重新统计</span></span><br><span class="line">                <span class="comment">// dept = t.length();</span></span><br><span class="line">                <span class="comment">// l = r;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> len == Integer.MAX_VALUE ? <span class="string">&quot;&quot;</span> : s.substring(start,  start + len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LengthOfLongestSubstring</title>
      <link href="/2024/05/11/LengthOfLongestSubstring/"/>
      <url>/2024/05/11/LengthOfLongestSubstring/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.滑动窗口;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> LengthOfLongestSubstring</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/5/11 16:00</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 无重复字符的最长子串</span></span><br><span class="line"><span class="comment">// 给定一个字符串 s ，请你找出其中不含有重复字符的 最长子串 的长度。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/longest-substring-without-repeating-characters/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LengthOfLongestSubstring</span> &#123;</span><br><span class="line">    <span class="comment">//直接滑动窗口，单调性体现在出现过字符的次数</span></span><br><span class="line">    <span class="comment">//难点在于怎么判断子串是否出现过某字符？ 用map记录字符出现的坐标，还能快速定位到该字符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span>[] arr = s.toCharArray();</span><br><span class="line">        Map&lt;Character, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Character, Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>, l = <span class="number">0</span>; r &lt; arr.length; r++) &#123;</span><br><span class="line">            <span class="comment">//左缩 字符出现在字串里</span></span><br><span class="line">            <span class="keyword">if</span> (map.get(arr[r]) != <span class="literal">null</span> &amp;&amp; map.get(arr[r]) &gt;= l)&#123;</span><br><span class="line">                <span class="comment">//l左缩到该字符的下一位</span></span><br><span class="line">                l = map.get(arr[r]) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新字符出现位置，右扩。这里这样写是因为左缩后也要更新字符位置，所以就写这公共代码里了</span></span><br><span class="line">            map.put(arr[r], r);</span><br><span class="line">            <span class="comment">//更新长度</span></span><br><span class="line">            ans = Math.max(r - l + <span class="number">1</span>, ans);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinSubArrayLen</title>
      <link href="/2024/05/09/MinSubArrayLen/"/>
      <url>/2024/05/09/MinSubArrayLen/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.滑动窗口;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> MinSubArrayLen</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/5/9 17:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 累加和大于等于target的最短子数组长度</span></span><br><span class="line"><span class="comment">// 给定一个含有 n 个正整数的数组和一个正整数 target</span></span><br><span class="line"><span class="comment">// 找到累加和 &gt;= target 的长度最小的子数组并返回其长度</span></span><br><span class="line"><span class="comment">// 如果不存在符合条件的子数组返回0</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/minimum-size-subarray-sum/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinSubArrayLen</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//满足单调性（窗口往右递增），使用滑动窗口解法</span></span><br><span class="line">    <span class="comment">//基本思路：窗口右扩，直到大于等于目标值，记录当前窗口长度，找最小长度</span></span><br><span class="line">    <span class="comment">//求子数组在 每个位置开头 或 结尾 情况下的答案.真是要好好理解这里话。</span></span><br><span class="line">    <span class="comment">// 这里的开头 或 结尾的意思是，固定住这个开头或结尾的情况下，判断当前子数组是否符合预期。</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法是固定了结尾，求数组是否符合预期（有点贪心思想，每个子数组的最优解即是全局的最优解，前提是要求单调性）</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>, l = <span class="number">0</span>; r &lt; nums.length; r++) &#123;</span><br><span class="line">            <span class="comment">//直接加右，相当于固定结尾，再讨论当前子数组是否符合预期</span></span><br><span class="line">            sum += nums[r];</span><br><span class="line">            <span class="comment">//讨论当前子数组是否符合预  顺便左缩</span></span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= target)&#123;</span><br><span class="line">                ans = Math.min(ans, r - l + <span class="number">1</span>);</span><br><span class="line">                sum -= nums[l++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这个方法是固定了开头，求结尾是否符合预期</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubArrayLen1</span><span class="params">(<span class="type">int</span> target, <span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> nums[l];</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="comment">//右扩  直到当前子数组符合预期</span></span><br><span class="line">            <span class="keyword">while</span> (r &lt; nums.length &amp;&amp; sum &lt; target)&#123;</span><br><span class="line">                sum += nums[r++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//记录长度</span></span><br><span class="line">            <span class="keyword">if</span> (sum &gt;= target)&#123;</span><br><span class="line">                ans = Math.min(r - l, ans);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//左缩,一格一格缩</span></span><br><span class="line">            sum -= nums[l++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? <span class="number">0</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 滑动窗口 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 滑动窗口 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FieldOfGreatestBlessing</title>
      <link href="/2024/05/07/FieldOfGreatestBlessing/"/>
      <url>/2024/05/07/FieldOfGreatestBlessing/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.二维差分数组;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> FieldOfGreatestBlessing</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/5/7 15:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">// 最强祝福力场</span></span><br><span class="line"><span class="comment">// 小扣在探索丛林的过程中，无意间发现了传说中&quot;落寞的黄金之都&quot;</span></span><br><span class="line"><span class="comment">// 而在这片建筑废墟的地带中，小扣使用探测仪监测到了存在某种带有「祝福」效果的力场</span></span><br><span class="line"><span class="comment">// 经过不断的勘测记录，小扣将所有力场的分布都记录了下来</span></span><br><span class="line"><span class="comment">// forceField[i] = [x,y,side]</span></span><br><span class="line"><span class="comment">// 表示第 i 片力场将覆盖以坐标 (x,y) 为中心，边长为 side 的正方形区域。</span></span><br><span class="line"><span class="comment">// 若任意一点的 力场强度 等于覆盖该点的力场数量</span></span><br><span class="line"><span class="comment">// 请求出在这片地带中 力场强度 最强处的 力场强度</span></span><br><span class="line"><span class="comment">// 注意：力场范围的边缘同样被力场覆盖。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/xepqZ5/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FieldOfGreatestBlessing</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//就是构建前置和数组、差分数组</span></span><br><span class="line">    <span class="comment">//构建差分数组 标记每处的力场强度</span></span><br><span class="line">    <span class="comment">// 因为有小数，所以将坐标放大两倍</span></span><br><span class="line">    <span class="comment">//利用离散化技巧，将扩大后的坐标x、y都转为离散的某个点，对应为数组内的编号。缩小空间</span></span><br><span class="line">    <span class="comment">//因为数据范围巨大，而给出的实际数据却可能很少，不得不用离散化。</span></span><br><span class="line">    <span class="comment">//要注意使用long类型！！！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fieldOfGreatestBlessing</span><span class="params">(<span class="type">int</span>[][] forceField)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> forceField.length;</span><br><span class="line">        <span class="comment">//构建离散化对应数组，获取x、y坐标</span></span><br><span class="line">        <span class="type">long</span>[] xrr = <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">2</span> * n];</span><br><span class="line">        <span class="type">long</span>[] yrr = <span class="keyword">new</span> <span class="title class_">long</span>[<span class="number">2</span> * n];</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> forceField[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">long</span> <span class="variable">y</span> <span class="operator">=</span> forceField[i][<span class="number">1</span>];</span><br><span class="line">            <span class="type">long</span> <span class="variable">r</span> <span class="operator">=</span> forceField[i][<span class="number">2</span>];</span><br><span class="line">            <span class="comment">//左上角点</span></span><br><span class="line">            xrr[k++] = (x &lt;&lt; <span class="number">1</span>) - r;</span><br><span class="line">            yrr[p++] = (y &lt;&lt; <span class="number">1</span>) - r;</span><br><span class="line">            <span class="comment">//右下角点</span></span><br><span class="line">            xrr[k++] = (x &lt;&lt; <span class="number">1</span>) + r;</span><br><span class="line">            yrr[p++] = (y &lt;&lt; <span class="number">1</span>) + r;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将获取到的坐标 去重、排序,返回有效长度</span></span><br><span class="line">        <span class="comment">//所有坐标对应的离散范围</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sizeX</span> <span class="operator">=</span> sort(xrr);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sizeY</span> <span class="operator">=</span> sort(yrr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置差分数组</span></span><br><span class="line">        <span class="type">int</span>[][] diff = <span class="keyword">new</span> <span class="title class_">int</span>[sizeX + <span class="number">2</span>][sizeY + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">x</span> <span class="operator">=</span> forceField[i][<span class="number">0</span>];</span><br><span class="line">            <span class="type">long</span> <span class="variable">y</span> <span class="operator">=</span> forceField[i][<span class="number">1</span>];</span><br><span class="line">            <span class="type">long</span> <span class="variable">r</span> <span class="operator">=</span> forceField[i][<span class="number">2</span>];</span><br><span class="line">            <span class="comment">//左上角点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> rank((x &lt;&lt; <span class="number">1</span>) - r, xrr, sizeX);</span><br><span class="line">            <span class="type">int</span> <span class="variable">y1</span> <span class="operator">=</span> rank((y &lt;&lt; <span class="number">1</span>) - r, yrr, sizeY);</span><br><span class="line">            <span class="comment">//右下角点</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> rank((x &lt;&lt; <span class="number">1</span>) + r, xrr, sizeX);</span><br><span class="line">            <span class="type">int</span> <span class="variable">y2</span> <span class="operator">=</span> rank((y &lt;&lt; <span class="number">1</span>) + r, yrr, sizeY);</span><br><span class="line">            set(x1,y1,x2,y2, diff);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//构建差分数组并获取最大值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; diff.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; diff[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                diff[i][j] += diff[i][j - <span class="number">1</span>] + diff[i - <span class="number">1</span>][j] - diff[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                ans = Math.max(diff[i][j], ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sort</span><span class="params">(<span class="type">long</span>[] arr)</span>&#123;</span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="comment">//如果当前位置不等于上一个</span></span><br><span class="line">            <span class="keyword">if</span> (arr[i] != arr[size - <span class="number">1</span>])&#123;</span><br><span class="line">                <span class="comment">//将当前位置设置到当前长度位置</span></span><br><span class="line">                arr[size++] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找数值对应的离散点</span></span><br><span class="line">    <span class="comment">//二分查找</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">rank</span><span class="params">(<span class="type">long</span> num, <span class="type">long</span>[] arr, <span class="type">int</span> size)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> size - <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            m = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (arr[m] &gt;= num)&#123;</span><br><span class="line">                ans = m;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//加1是为了返回实际坐标</span></span><br><span class="line">        <span class="keyword">return</span> ans + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span>[][] arr)</span>&#123;</span><br><span class="line">        arr[x1][y1] += <span class="number">1</span>;</span><br><span class="line">        arr[x1][y2 + <span class="number">1</span>] -= <span class="number">1</span>;</span><br><span class="line">        arr[x2 + <span class="number">1</span>][y1] -= <span class="number">1</span>;</span><br><span class="line">        arr[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二维差分数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维差分数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PossibleToStamp</title>
      <link href="/2024/05/06/PossibleToStamp/"/>
      <url>/2024/05/06/PossibleToStamp/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.二维差分数组;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> PossibleToStamp</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/5/6 17:27</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">// 用邮票贴满网格图</span></span><br><span class="line"><span class="comment">// 给你一个 m * n 的二进制矩阵 grid</span></span><br><span class="line"><span class="comment">// 每个格子要么为 0 （空）要么为 1 （被占据）</span></span><br><span class="line"><span class="comment">// 给你邮票的尺寸为 stampHeight * stampWidth</span></span><br><span class="line"><span class="comment">// 我们想将邮票贴进二进制矩阵中，且满足以下 限制 和 要求 ：</span></span><br><span class="line"><span class="comment">// 覆盖所有空格子，不覆盖任何被占据的格子</span></span><br><span class="line"><span class="comment">// 可以放入任意数目的邮票，邮票可以相互有重叠部分</span></span><br><span class="line"><span class="comment">// 邮票不允许旋转，邮票必须完全在矩阵内</span></span><br><span class="line"><span class="comment">// 如果在满足上述要求的前提下，可以放入邮票，请返回 true ，否则返回 false</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/stamping-the-grid/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PossibleToStamp</span> &#123;</span><br><span class="line">    <span class="comment">//感觉就是求前缀和呀，从点1到 点2区域内的前缀和为0 则符合要求</span></span><br><span class="line">    <span class="comment">//思路：</span></span><br><span class="line">    <span class="comment">// 1、构建数组前缀和</span></span><br><span class="line">    <span class="comment">//2、遍历数组，以每个点为左上角，贴满每一处地方</span></span><br><span class="line">    <span class="comment">// 3、用新数组记录是否被贴，原数组点到点的前缀和判断是否可贴</span></span><br><span class="line">    <span class="comment">//、遍历新数组，看是否贴满</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">possibleToStamp</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> stampHeight, <span class="type">int</span> stampWidth)</span> &#123;</span><br><span class="line">        <span class="comment">//构建原数组前缀和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] sumArr = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">1</span>][m + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                sumArr[i][j] += sumArr[i][j - <span class="number">1</span>] + sumArr[i - <span class="number">1</span>][j] - sumArr[i - <span class="number">1</span>][j - <span class="number">1</span>] + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新数组记录是否以贴</span></span><br><span class="line">        <span class="type">int</span>[][] recordArr = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>][m + <span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历每个数组左上角</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> i + <span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">y1</span> <span class="operator">=</span> j + <span class="number">1</span>;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> i + stampHeight;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">y2</span> <span class="operator">=</span> j + stampWidth;</span><br><span class="line">                    <span class="keyword">if</span> (canP(x1, y1,x2, y2, sumArr))&#123;</span><br><span class="line">                        set(x1, y1, x2, y2, recordArr, <span class="number">1</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        build(recordArr);</span><br><span class="line">        <span class="comment">//遍历record看是否有空格子</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= m; j++) &#123;</span><br><span class="line">                <span class="comment">//查看每一个空格子是否被贴</span></span><br><span class="line">                <span class="keyword">if</span> (grid[i - <span class="number">1</span>][j - <span class="number">1</span>] == <span class="number">0</span> &amp;&amp; recordArr[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//能否贴</span></span><br><span class="line">    <span class="comment">//前缀和数组的坐标</span></span><br><span class="line">    <span class="comment">//前缀和数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">canP</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span>[][] sumArr)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> sumArr.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> sumArr[<span class="number">0</span>].length;</span><br><span class="line">        <span class="comment">//超过边界</span></span><br><span class="line">        <span class="keyword">if</span> (x1 &lt; <span class="number">0</span> || y1 &lt; <span class="number">0</span> || x2 &lt; <span class="number">0</span> || y2 &lt; <span class="number">0</span> || x1 &gt;= n || x2 &gt;= n || y1 &gt;= m || y2 &gt;= m) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//计算点到点的前缀和 是否等于 0</span></span><br><span class="line">        <span class="comment">//前缀和计算 = 整块 - 左边 - 上面 + 左上</span></span><br><span class="line">        <span class="keyword">return</span>  (sumArr[x2][y2] - sumArr[x2][y1 - <span class="number">1</span>] - sumArr[x1 - <span class="number">1</span>][y2] + sumArr[x1 -<span class="number">1</span>][y1 -<span class="number">1</span>]) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置二维差分数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span>[][] recordArr, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        recordArr[x1][y1] += k;</span><br><span class="line">        <span class="comment">//结束行和列</span></span><br><span class="line">        recordArr[x1][y2 + <span class="number">1</span>] -= k;</span><br><span class="line">        recordArr[x2 + <span class="number">1</span>][y1] -= k;</span><br><span class="line">        <span class="comment">//消除影响</span></span><br><span class="line">        recordArr[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += k;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//前缀和数组和差分数组的最大区别就是 是否加上原数组对应的值</span></span><br><span class="line">    <span class="comment">//前缀和因为要统计数组前缀和，所以要加上数组原有值</span></span><br><span class="line">    <span class="comment">//差分数组，单纯用于设置数组内的值，所以不用加上原有值</span></span><br><span class="line">    <span class="comment">//做法都是  该值 += 左 + 上 - 左上 + （是否要加原数组对应的值）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//构建二维差分数组</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span>[][] recordArr)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; recordArr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; recordArr[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                recordArr[i][j] += recordArr[i][j - <span class="number">1</span>] + recordArr[i - <span class="number">1</span>][j] - recordArr[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[][]&#123;&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;, &#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line">        possibleToStamp(arr, <span class="number">4</span>, <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二维差分数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维差分数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ArithmeticSequenceDifference</title>
      <link href="/2024/05/06/ArithmeticSequenceDifference/"/>
      <url>/2024/05/06/ArithmeticSequenceDifference/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.一维差分数组;</span><br><span class="line"><span class="comment">// 一开始1~n范围上的数字都是0，一共有m个操作，每次操作为(l,r,s,e,d)</span></span><br><span class="line"><span class="comment">// 表示在l~r范围上依次加上首项为s、末项为e、公差为d的数列</span></span><br><span class="line"><span class="comment">// m个操作做完之后，统计1~n范围上所有数字的最大值和异或和</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P4231</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下的code，提交时请把类名改成&quot;Main&quot;，可以直接通过</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.BufferedReader;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStreamReader;</span><br><span class="line"><span class="keyword">import</span> java.io.OutputStreamWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.io.StreamTokenizer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ArithmeticSequenceDifference</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">10000005</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span>[] arr = <span class="keyword">new</span> <span class="title class_">long</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> n, m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            n = (<span class="type">int</span>) in.nval;</span><br><span class="line">            in.nextToken();</span><br><span class="line">            m = (<span class="type">int</span>) in.nval;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, l, r, s, e; i &lt; m; i++) &#123;</span><br><span class="line">                in.nextToken(); l = (<span class="type">int</span>) in.nval;</span><br><span class="line">                in.nextToken(); r = (<span class="type">int</span>) in.nval;</span><br><span class="line">                in.nextToken(); s = (<span class="type">int</span>) in.nval;</span><br><span class="line">                in.nextToken(); e = (<span class="type">int</span>) in.nval;</span><br><span class="line">                set(l, r, s, e, (e - s) / (r - l));</span><br><span class="line">            &#125;</span><br><span class="line">            build();</span><br><span class="line">            <span class="type">long</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>, xor = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">                max = Math.max(max, arr[i]);</span><br><span class="line">                xor ^= arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(xor + <span class="string">&quot; &quot;</span> + max);</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> s, <span class="type">int</span> e, <span class="type">int</span> d)</span> &#123;</span><br><span class="line">        arr[l] += s;</span><br><span class="line">        arr[l + <span class="number">1</span>] += d - s;</span><br><span class="line">        arr[r + <span class="number">1</span>] -= d + e;</span><br><span class="line">        arr[r + <span class="number">2</span>] += e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            arr[i] += arr[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            arr[i] += arr[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 一维差分数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一维差分数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DiffMatrixLuogu</title>
      <link href="/2024/05/06/DiffMatrixLuogu/"/>
      <url>/2024/05/06/DiffMatrixLuogu/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.二维差分数组;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> DiffMatrixLuogu</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/5/6 10:37</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 二维差分模版(洛谷)</span></span><br><span class="line"><span class="comment">// 测试链接 : https://www.luogu.com.cn/problem/P3397</span></span><br><span class="line"><span class="comment">// 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment">// 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment">// 提交以下的code，提交时请把类名改成&quot;Main&quot;，可以直接通过</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DiffMatrixLuogu</span> &#123;</span><br><span class="line">    <span class="comment">//思路：这不就是二维前缀和吗</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAIN</span> <span class="operator">=</span> <span class="number">1002</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[MAIN][MAIN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> N;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> M;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">pw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">sk</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line">        <span class="keyword">while</span> (sk.nextToken() != StreamTokenizer.TT_EOF)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">int</span>) sk.nval;</span><br><span class="line">            sk.nextToken();</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (<span class="type">int</span>) sk.nval;</span><br><span class="line">            N = n; M = m;</span><br><span class="line">            <span class="keyword">while</span> (m-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                sk.nextToken();</span><br><span class="line">                <span class="type">int</span> <span class="variable">x1</span> <span class="operator">=</span> (<span class="type">int</span>) sk.nval;</span><br><span class="line">                sk.nextToken();</span><br><span class="line">                <span class="type">int</span> <span class="variable">y1</span> <span class="operator">=</span> (<span class="type">int</span>) sk.nval;</span><br><span class="line">                sk.nextToken();</span><br><span class="line">                <span class="type">int</span> <span class="variable">x2</span> <span class="operator">=</span> (<span class="type">int</span>) sk.nval;</span><br><span class="line">                sk.nextToken();</span><br><span class="line">                <span class="type">int</span> <span class="variable">y2</span> <span class="operator">=</span> (<span class="type">int</span>) sk.nval;</span><br><span class="line">                set(x1,y1, x2,y2,<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            build();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N; i++) &#123;</span><br><span class="line">                pw.print(arr[i][<span class="number">1</span>]);</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">2</span>; j &lt;= N; j++) &#123;</span><br><span class="line">                    pw.print(<span class="string">&quot; &quot;</span> + arr[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line">                pw.println();</span><br><span class="line">            &#125;</span><br><span class="line">            clear();</span><br><span class="line">        &#125;</span><br><span class="line">        pw.flush();</span><br><span class="line">        pw.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">build</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="comment">//构建前缀和</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N ; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= N ; j++) &#123;</span><br><span class="line">                <span class="comment">//左边 + 上 - 左上</span></span><br><span class="line">                arr[i][j] +=  arr[i][j - <span class="number">1</span>] + arr[i - <span class="number">1</span>][j] - arr[i - <span class="number">1</span>][j -<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">set</span><span class="params">(<span class="type">int</span> x1, <span class="type">int</span> y1, <span class="type">int</span> x2, <span class="type">int</span> y2, <span class="type">int</span> val)</span>&#123;</span><br><span class="line">        <span class="comment">//标记开始的行</span></span><br><span class="line">        arr[x1][y1] += val;</span><br><span class="line">        <span class="comment">//标记结束的行</span></span><br><span class="line">        arr[x2 + <span class="number">1</span>][y1] -= val;<span class="comment">//消除往下的影响</span></span><br><span class="line">        <span class="comment">//标记结束的列</span></span><br><span class="line">        arr[x1][y2 + <span class="number">1</span>] -= val;<span class="comment">//消除往右的影响</span></span><br><span class="line">        <span class="comment">//消除多余列、行突出来的 -val</span></span><br><span class="line">        arr[x2 + <span class="number">1</span>][y2 + <span class="number">1</span>] += val;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= N + <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="comment">// Arrays.fill(arr[i], 1, N + 1, 0);</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;= N + <span class="number">1</span>; j++) &#123;</span><br><span class="line">                arr[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二维差分数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维差分数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Largest1BorderedSquare</title>
      <link href="/2024/05/06/Largest1BorderedSquare/"/>
      <url>/2024/05/06/Largest1BorderedSquare/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.二维前缀和;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Largest1BorderedSquare</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/5/6 10:35</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 边框为1的最大正方形</span></span><br><span class="line"><span class="comment">// 给你一个由若干 0 和 1 组成的二维网格 grid</span></span><br><span class="line"><span class="comment">// 请你找出边界全部由 1 组成的最大 正方形 子网格</span></span><br><span class="line"><span class="comment">// 并返回该子网格中的元素数量。如果不存在，则返回 0。</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/largest-1-bordered-square/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Largest1BorderedSquare</span> &#123;</span><br><span class="line">    <span class="comment">//二维前缀和：</span></span><br><span class="line">    <span class="comment">//解题思路；</span></span><br><span class="line">    <span class="comment">//遍历每个位置作为正方形的左上角，逐渐增加边长</span></span><br><span class="line">    <span class="comment">//判断正方形周长是否全为1：</span></span><br><span class="line">    <span class="comment">// 利用前缀和计算正方形的周长 是否等于理论值</span></span><br><span class="line">    <span class="comment">//正方形周长 = 大正方形前缀和 - 内部正方形前缀和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">largest1BorderedSquare</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">        <span class="comment">//构建前缀和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len1</span> <span class="operator">=</span> grid.length;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len2</span> <span class="operator">=</span> grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[len1 + <span class="number">1</span>][len2 + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; arr[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="comment">//左 + 上 - 左上 + 本值</span></span><br><span class="line">                arr[i][j] += arr[i][j - <span class="number">1</span>] + arr[i - <span class="number">1</span>][j] - arr[i - <span class="number">1</span>][j - <span class="number">1</span>] + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (arr[len1][len2] == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//遍历每个值作为左上角</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; len1; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; len2; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>)&#123;</span><br><span class="line">                    <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;<span class="comment">//边长</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> ans + <span class="number">1</span>;<span class="comment">//当前尝试的边长</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> i + <span class="number">1</span>;<span class="comment">//左上角坐标</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> j + <span class="number">1</span>;<span class="comment">//左上角坐标</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> i + k;<span class="comment">//右下角坐标</span></span><br><span class="line">                    <span class="type">int</span> <span class="variable">d</span> <span class="operator">=</span> j + k;<span class="comment">//右下角坐标</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//右下角左边在范围内</span></span><br><span class="line">                    <span class="keyword">while</span> (c &lt;= len1 &amp;&amp; d &lt;= len2)&#123;</span><br><span class="line">                        <span class="comment">//计算当前位置和边长的正方形，周长是否符合要求</span></span><br><span class="line">                        <span class="keyword">if</span> (sum(a, b, c, d, arr) - sum(a + <span class="number">1</span>, b + <span class="number">1</span>, c - <span class="number">1</span>, d - <span class="number">1</span>, arr) == ((k - <span class="number">1</span>) &lt;&lt; <span class="number">2</span>))&#123;</span><br><span class="line">                            ans = k;</span><br><span class="line">                            max = Math.max(max, ans);</span><br><span class="line">                        &#125;</span><br><span class="line">                        k++;<span class="comment">//逐渐增加边长</span></span><br><span class="line">                        c = i + k;<span class="comment">//右下角坐标</span></span><br><span class="line">                        d = j + k;<span class="comment">//右下角坐标</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> max * max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算前缀和</span></span><br><span class="line">    <span class="comment">//左上角和右下角坐标</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> c1, <span class="type">int</span> r1, <span class="type">int</span> c2, <span class="type">int</span> r2, <span class="type">int</span>[][] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c2 &lt; c1 || r2 &lt; r1 || r2 &gt;= arr[<span class="number">0</span>].length || c2 &gt;= arr.length || r1 &gt;= arr[<span class="number">0</span>].length || c1 &gt;= arr.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//总 - 左边 - 上面 + 左上</span></span><br><span class="line">        <span class="keyword">return</span> arr[c2][r2] - arr[c2][r1 - <span class="number">1</span>] - arr[c1 - <span class="number">1</span>][r2] + arr[c1 - <span class="number">1</span>][r1 - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二维前缀和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NumMatrix</title>
      <link href="/2024/05/06/NumMatrix/"/>
      <url>/2024/05/06/NumMatrix/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.二维前缀和;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> NumMatrix</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * // 利用二维前缀和信息迅速得到二维区域和</span></span><br><span class="line"><span class="comment"> * // 测试链接 : https://leetcode.cn/problems/range-sum-query-2d-immutable/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/5/6 10:31</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NumMatrix</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span>[][] arr;</span><br><span class="line">    <span class="comment">//二维前缀和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumMatrix</span><span class="params">(<span class="type">int</span>[][] matrix)</span> &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[matrix.length + <span class="number">1</span>][matrix[<span class="number">0</span>].length + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt; arr[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="comment">//二维前缀和构建规则：</span></span><br><span class="line">                <span class="comment">//某个位置的值 = 左 + 上 - 左上（左和上重叠的区域） + 本值</span></span><br><span class="line">                <span class="comment">//空出左边和上面，避免边界讨论</span></span><br><span class="line">                arr[i][j] += arr[i][j-<span class="number">1</span>]  + arr[i - <span class="number">1</span>][j] - arr[i-<span class="number">1</span>][j-<span class="number">1</span>] + matrix[i-<span class="number">1</span>][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRegion</span><span class="params">(<span class="type">int</span> row1, <span class="type">int</span> col1, <span class="type">int</span> row2, <span class="type">int</span> col2)</span> &#123;</span><br><span class="line">        <span class="comment">//这里入参是从0开始的，所以对标前缀和要+1</span></span><br><span class="line">        row2++;</span><br><span class="line">        col2++;</span><br><span class="line">        <span class="comment">//右下角 - 左边 - 上边 + 左上</span></span><br><span class="line">        <span class="keyword">return</span> arr[row2][col2] - arr[row2][col1] - arr[row1][col2] + arr[row1][col1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二维前缀和 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二维前缀和 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CorpFlightBookings</title>
      <link href="/2024/04/26/CorpFlightBookings/"/>
      <url>/2024/04/26/CorpFlightBookings/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.一维差分数组;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> CorpFlightBookings</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * 航班预订统计</span></span><br><span class="line"><span class="comment"> *  * https://leetcode.cn/problems/corporate-flight-bookings/description/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/4/26 16:43</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CorpFlightBookings</span> &#123;</span><br><span class="line">    <span class="comment">//多条数组就是多个操作记录</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] corpFlightBookings(<span class="type">int</span>[][] bookings, <span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="comment">//空出前后一个位置</span></span><br><span class="line">        <span class="type">int</span>[] cnt = <span class="keyword">new</span> <span class="title class_">int</span>[n + <span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] booking : bookings) &#123;</span><br><span class="line">            cnt[booking[<span class="number">0</span>]] += booking[<span class="number">2</span>];</span><br><span class="line">            cnt[booking[<span class="number">1</span>] + <span class="number">1</span>] -= booking[<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; res.length; i++) &#123;</span><br><span class="line">            cnt[i + <span class="number">1</span>] += cnt[i];</span><br><span class="line">            res[i] = cnt[i + <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 一维差分数组 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 一维差分数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FindTheLongestSubstring</title>
      <link href="/2024/04/18/FindTheLongestSubstring/"/>
      <url>/2024/04/18/FindTheLongestSubstring/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.数组前缀信息;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> FindTheLongestSubstring</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 每个元音包含偶数次的最长子字符串</span></span><br><span class="line"><span class="comment"> *  https://leetcode.cn/problems/find-the-longest-substring-containing-vowels-in-even-counts/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/4/18 11:35</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindTheLongestSubstring</span> &#123;</span><br><span class="line">    <span class="comment">//核心思想： 一步一步思考的来：</span></span><br><span class="line">    <span class="comment">//1、要有个东西记录每个字符出现的奇偶次数，可以用二进制位来记录</span></span><br><span class="line">    <span class="comment">//2、当某个字符是奇数次时，要找对应奇数次的字符，加上就是偶数次。当某个字符是偶数次时，他本身或者找个偶数次字符加上就是偶数</span></span><br><span class="line">    <span class="comment">//推广到每个字符  那就是奇找奇，偶找偶，用二进制表示，那就是找和本身相同的数。</span></span><br><span class="line">    <span class="comment">//所以用int数组记录每个数字出现的最早下标。一共就5个字符，就2^5位数字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findTheLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">32</span>];</span><br><span class="line">        Arrays.fill(arr, -<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; s.length(); i++) &#123;</span><br><span class="line">            <span class="comment">//字符转数字</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> change(s.charAt(i));</span><br><span class="line">            sum ^= index;</span><br><span class="line">            <span class="comment">//都是偶数个时，直接记录当前长度</span></span><br><span class="line">            <span class="keyword">if</span> (sum == <span class="number">0</span>)&#123;</span><br><span class="line">                ans = Math.max(ans, i + <span class="number">1</span>);</span><br><span class="line">                arr[sum] = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果没出现过这个数字，则定位最早出现的下标</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (arr[sum] != -<span class="number">1</span>)&#123;</span><br><span class="line">                ans = Math.max(ans, i - arr[sum]);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                arr[sum] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">change</span><span class="params">(<span class="type">char</span> c)</span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (c)&#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;a&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">16</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;e&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;i&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">4</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;o&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;u&#x27;</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组前缀信息 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组前缀信息 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MinSubarray</title>
      <link href="/2024/04/15/MinSubarray/"/>
      <url>/2024/04/15/MinSubarray/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.数组前缀信息;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> MinSubarray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * // 使数组和能被P整除</span></span><br><span class="line"><span class="comment"> * // 给你一个正整数数组 nums，请你移除 最短 子数组（可以为 空）</span></span><br><span class="line"><span class="comment"> * // 使得剩余元素的 和 能被 p 整除。 不允许 将整个数组都移除。</span></span><br><span class="line"><span class="comment"> * // 请你返回你需要移除的最短子数组的长度，如果无法满足题目要求，返回 -1 。</span></span><br><span class="line"><span class="comment"> * // 子数组 定义为原数组中连续的一组元素。</span></span><br><span class="line"><span class="comment"> * // 测试链接 : https://leetcode.cn/problems/make-sum-divisible-by-p/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/4/15 17:39</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MinSubarray</span> &#123;</span><br><span class="line">    <span class="comment">//核心思想：当某数x % p得z,(z != 0)时，若要x能整除p，则把子数组前缀和，余数为z的段去掉即可。</span></span><br><span class="line">    <span class="comment">//以下是求某段</span></span><br><span class="line">    <span class="comment">//设a % p = z;</span></span><br><span class="line">    <span class="comment">//a % p = (x + y) % p = (x%p + y%p + p) % p = z</span></span><br><span class="line">    <span class="comment">//设x%p 为余数x1, y%p为余数y1,</span></span><br><span class="line">    <span class="comment">// 式1，即 (余数x1 + 余数y1) % p = 余数z</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//(记住以下公式)</span></span><br><span class="line">    <span class="comment">// 式2 有（x + y）% p = z  能得出  y = (x - z + p ) % p</span></span><br><span class="line">    <span class="comment">//式1、2结合，得若已知余数x,z,和被余数p,则可得余数y。</span></span><br><span class="line">    <span class="comment">// 若要z为0，则y余数也为0，即把y变成0即可。既把y这段余数删除即可</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用上面结论，先求出整体余数z，再求余数y出现的最早下标。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minSubarray</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> p)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//有个坑啊，不能直接相加（会超过范围）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//先求总余数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            mod = (mod + nums[i]) % p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//刚好整除，不用移除</span></span><br><span class="line">        <span class="keyword">if</span> (mod == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这个遍历是从左到右的，所以下面实际要删去的是右边的长度</span></span><br><span class="line">        <span class="comment">//即已知对应的左边的余数存在，则删除右边的求和余数段</span></span><br><span class="line">        <span class="comment">//所以要记录余数出现的最晚下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            cur = (cur + nums[i]) % p;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//已知当前余数 x,总余数z,求是否有对应的余数y</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> (cur - mod + p) % p;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(key))&#123;</span><br><span class="line">                <span class="comment">//求对应长度:</span></span><br><span class="line">                ans = Math.min(ans, i - map.get(key));</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(cur, i);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans == nums.length ? -<span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组前缀信息 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组前缀信息 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LongestWPI</title>
      <link href="/2024/04/15/LongestWPI/"/>
      <url>/2024/04/15/LongestWPI/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.数组前缀信息;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> LongestWPI</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * // 表现良好的最长时间段</span></span><br><span class="line"><span class="comment"> * // 给你一份工作时间表 hours，上面记录着某一位员工每天的工作小时数</span></span><br><span class="line"><span class="comment"> * // 我们认为当员工一天中的工作小时数大于 8 小时的时候，那么这一天就是 劳累的一天</span></span><br><span class="line"><span class="comment"> * // 所谓 表现良好的时间段 ，意味在这段时间内，「劳累的天数」是严格 大于 不劳累的天数</span></span><br><span class="line"><span class="comment"> * // 请你返回 表现良好时间段 的最大长度</span></span><br><span class="line"><span class="comment"> * // 测试链接 : https://leetcode.cn/problems/longest-well-performing-interval/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/4/15 14:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LongestWPI</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心思想：</span></span><br><span class="line">    <span class="comment">//转为1和-1，即求某段长度和为x的情况下，求良好时间段为 子段长度和 x-y&gt;= 1,即求剩下的段为y&lt;=x-1。</span></span><br><span class="line">    <span class="comment">//如果数组和为大于0，则最大长度就是数组长度</span></span><br><span class="line">    <span class="comment">// 总和 -3，求某段大于等于1，即求剩下的段小于等于-4。即求最早出现-4的段</span></span><br><span class="line">    <span class="comment">//用map记录每个数和最早出现的i</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">longestWPI</span><span class="params">(<span class="type">int</span>[] hours)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; hours.length; i++) &#123;</span><br><span class="line">            sum += hours[i] &gt; <span class="number">8</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">//看是否存在某段使得 y成立</span></span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(sum - <span class="number">1</span>))&#123;</span><br><span class="line">                <span class="comment">//求长度</span></span><br><span class="line">                ans = Math.max(ans, i - map.get(sum - <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//记录每个数组和最早出现的下标</span></span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(sum))&#123;</span><br><span class="line">                map.put(sum, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数组和大于0，直接返回数组长度</span></span><br><span class="line">        <span class="keyword">return</span> sum &gt; <span class="number">0</span> ? hours.length : ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左神代码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">longestWPI2</span><span class="params">(<span class="type">int</span>[] hours)</span> &#123;</span><br><span class="line">        <span class="comment">// 某个前缀和，最早出现的位置</span></span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 0这个前缀和，最早出现在-1，一个数也没有的时候</span></span><br><span class="line">        map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, sum = <span class="number">0</span>; i &lt; hours.length; i++) &#123;</span><br><span class="line">            sum += hours[i] &gt; <span class="number">8</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (sum &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                ans = i + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// sum &lt;= 0</span></span><br><span class="line">                <span class="keyword">if</span> (map.containsKey(sum - <span class="number">1</span>)) &#123;</span><br><span class="line">                    ans = Math.max(ans, i - map.get(sum - <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!map.containsKey(sum)) &#123;</span><br><span class="line">                map.put(sum, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组前缀信息 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组前缀信息 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Compute</title>
      <link href="/2024/04/12/Compute/"/>
      <url>/2024/04/12/Compute/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.数组前缀信息;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Compute</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * 给定一个无序数组arr，其中元素可正、可负、可0。求arr所有子数组中正数与负数个数相等的最长子数组的长度。</span></span><br><span class="line"><span class="comment"> * 第一行一个整数N，表示数组长度</span></span><br><span class="line"><span class="comment"> * 接下来一行有N个数表示数组中的数</span></span><br><span class="line"><span class="comment"> * https://www.nowcoder.com/practice/545544c060804eceaed0bb84fcd992fb</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/4/12 16:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Compute</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">in</span>  <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(bf);</span><br><span class="line">        <span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">int</span>) in.nval;</span><br><span class="line">            in.nextToken();</span><br><span class="line">            <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">                arr[i] = (<span class="type">int</span>) in.nval;</span><br><span class="line">                in.nextToken();</span><br><span class="line">            &#125;</span><br><span class="line">            out.println(compute(arr));</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        bf.close();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心思想: 转为求指定数组和为0的最长长度，用map记录数组和中最早出现的下标i</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">compute</span><span class="params">(<span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//数组和为0的情况，数组为空时就出现过了</span></span><br><span class="line">        <span class="comment">//为了兼容最后一个前缀和也符合的情况</span></span><br><span class="line">        map.put(<span class="number">0</span>, -<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                sum += arr[i] &gt; <span class="number">0</span> ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (map.containsKey(sum))&#123;</span><br><span class="line">                <span class="comment">//直接求长度</span></span><br><span class="line">                ans = Math.max(ans, i - map.get(sum));</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                map.put(sum, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组前缀信息 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组前缀信息 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SubarraySum</title>
      <link href="/2024/04/12/SubarraySum/"/>
      <url>/2024/04/12/SubarraySum/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.数组前缀信息;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.Map;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> SubarraySum</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 和为k的数组</span></span><br><span class="line"><span class="comment"> * https://leetcode.cn/problems/subarray-sum-equals-k/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/4/12 16:23</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubarraySum</span> &#123;</span><br><span class="line">    <span class="comment">//核心思想：看到题目关键子包含  ”数组和“,可联想到前缀和数组是否能解题</span></span><br><span class="line">    <span class="comment">//数组中某段子数组和为k，假设是i-j的和为k,那么只要求 sum[j] - sum[i] = k 即可</span></span><br><span class="line">    <span class="comment">//即记录数组和为x出现的下表</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">subarraySum</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//意味着当k是当前遍历的数组和时，0这个和已经在数组为空时出现过。为了 0-j的和为k的情况</span></span><br><span class="line">        <span class="comment">// 0这个前缀和，在没有任何数字的时候，已经有1次了</span></span><br><span class="line">        map.put(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="comment">//这里先判断再把和放入map的原因是</span></span><br><span class="line">            <span class="comment">//要判断 之前 有没有出现过sum - k的前缀和，而不应该包含当前前缀和。（当前前缀和就是k是整个数组的情况）</span></span><br><span class="line">            <span class="comment">// if (map.containsKey(sum - k))&#123;</span></span><br><span class="line">            <span class="comment">//     ans += map.get(sum - k);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">//简化写法</span></span><br><span class="line">            ans += map.getOrDefault(sum, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//记录某前缀出现次数+ 1</span></span><br><span class="line">            map.put(sum, map.getOrDefault(sum, <span class="number">0</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组前缀信息 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组前缀信息 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NumArray</title>
      <link href="/2024/04/12/NumArray/"/>
      <url>/2024/04/12/NumArray/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.数组前缀信息;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> NumArray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * 数组前缀和</span></span><br><span class="line"><span class="comment"> * https://leetcode.cn/problems/range-sum-query-immutable/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/4/12 16:22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NumArray</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//前缀和</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">NumArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length + <span class="number">1</span>];</span><br><span class="line">        <span class="comment">//构建数组前缀和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            arr[i + <span class="number">1</span>] = sum;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumRange</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> arr[right + <span class="number">1</span>] - arr[left];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数组前缀信息 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组前缀信息 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FindWords</title>
      <link href="/2024/04/12/FindWords/"/>
      <url>/2024/04/12/FindWords/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.前缀树.相关题目;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 单词搜索 II</span></span><br><span class="line"><span class="comment"> * https://leetcode.cn/problems/word-search-ii/</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024-04-10 16:05:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindWords</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//leetcode submit region begin(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心思想：递归回溯，再剪枝</span></span><br><span class="line">    <span class="comment">//剪枝优化：</span></span><br><span class="line">    <span class="comment">//利用前缀树大量剪枝</span></span><br><span class="line">    <span class="comment">//前缀树优化：</span></span><br><span class="line">    <span class="comment">// 1、将words放入前缀树，递归查找时，判断当前字符是否在树中（记录前一个路径的index)，不在则剪枝1</span></span><br><span class="line">    <span class="comment">// 2、end记录整个单词，当已经找到单词时候，将沿路的pass 减1，当pass为0时，代表下面的路径已经查找过，不用在找了。  剪枝2</span></span><br><span class="line">    <span class="comment">//递归：四个方向递归操作，返回值为找到单词的数量，为了pass减去该数量.</span></span><br><span class="line">    <span class="comment">//遍历过的路径置0，遍历后恢复现场</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;String&gt; <span class="title function_">findWords</span><span class="params">(<span class="type">char</span>[][] board, String[] words)</span> &#123;</span><br><span class="line">        build(words);</span><br><span class="line">        List&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//每个字母都为起点，找4个方向</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                dfs(board, i, j, <span class="number">1</span>, ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        clear();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> pre, List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="comment">//超出边界， 已经路过</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= board.length || j &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || board[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> tree[pre][board[i][j] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="comment">//不在树中 || 该路径已经找到过单词</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="number">0</span> || pass[t] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当前字符是否能找到单词</span></span><br><span class="line">        <span class="keyword">if</span> (end[t] != <span class="literal">null</span>) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">            list.add(end[t]);</span><br><span class="line">            end[t] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//当前路径设置0</span></span><br><span class="line">        <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> board[i][j];</span><br><span class="line">        board[i][j] = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//四个方向找</span></span><br><span class="line">        ans += dfs(board, i - <span class="number">1</span>, j, t, list);</span><br><span class="line">        ans += dfs(board, i + <span class="number">1</span>, j, t, list);</span><br><span class="line">        ans += dfs(board, i, j - <span class="number">1</span>, t, list);</span><br><span class="line">        ans += dfs(board, i, j + <span class="number">1</span>, t, list);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//恢复现场</span></span><br><span class="line">        board[i][j] = tmp;</span><br><span class="line">        pass[t] -= ans;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">10001</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[][] tree = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN][<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[] pass = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line">    <span class="keyword">static</span> String[] end = <span class="keyword">new</span> <span class="title class_">String</span>[MAXN];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(String[] words)</span> &#123;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (String word : words) &#123;</span><br><span class="line">            insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">            Arrays.fill(tree[i], <span class="number">0</span>);</span><br><span class="line">            pass[i] = <span class="number">0</span>;</span><br><span class="line">            end[i] = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        pass[cur]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (tree[cur][index] == <span class="number">0</span>) &#123;</span><br><span class="line">                tree[cur][index] = ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = tree[cur][index];</span><br><span class="line">            pass[cur]++;</span><br><span class="line">        &#125;</span><br><span class="line">        end[cur] = word;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//leetcode submit region end(Prohibit modification and deletion)</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 相关题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 相关题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FindMaximumXOR</title>
      <link href="/2024/04/10/FindMaximumXOR/"/>
      <url>/2024/04/10/FindMaximumXOR/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.前缀树.相关题目;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> findMaximumXOR</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * 数组中两个数的最大异或值</span></span><br><span class="line"><span class="comment"> * https://leetcode.cn/problems/maximum-xor-of-two-numbers-in-an-array/description/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/4/10 16:04</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindMaximumXOR</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心思想：比较巧妙的方法.</span></span><br><span class="line">    <span class="comment">//有点点贪心策略，要两数异或最大值，那肯定想要两数当前二进制位上不同，即得到的结果是1.</span></span><br><span class="line">    <span class="comment">//所以从最大位上开始，遍历每位上，是否能异或其他数得到这个位上1的结果</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaximumXOR1</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找最大位数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> num : nums )&#123;</span><br><span class="line">            max = Math.max(max, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最高位数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">high</span> <span class="operator">=</span> <span class="number">32</span> - Integer.numberOfLeadingZeros(max);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//保存每个成员在当前位的结果</span></span><br><span class="line">        HashSet&lt;Integer&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//从最大位数开始遍历，和其他数的该位异或，看能否得到该位上1的结果</span></span><br><span class="line">        <span class="comment">//从最高位的下一位开始异或，因为当前最高位肯定是1，已经符合预期结果</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> high - <span class="number">1</span>; i &gt;=<span class="number">0</span> ; i--) &#123;</span><br><span class="line">            <span class="comment">//预期的答案</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">better</span> <span class="operator">=</span> ans | (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            set.clear();</span><br><span class="line">            <span class="keyword">for</span>( <span class="type">int</span> num : nums )&#123;</span><br><span class="line">                <span class="comment">//将该数只保留到当前位</span></span><br><span class="line">                num = (num &gt;&gt; i) &lt;&lt; i;</span><br><span class="line">                <span class="comment">//添加成员在该位的结果</span></span><br><span class="line">                set.add(num);</span><br><span class="line">                <span class="comment">//判断数组中是否有成员在当前位上，异或达到预期的答案</span></span><br><span class="line">                <span class="keyword">if</span> (set.contains(better ^ num))&#123;</span><br><span class="line">                    <span class="comment">//保留当前位置结果</span></span><br><span class="line">                    ans = better;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用前缀树的做法。</span></span><br><span class="line">    <span class="comment">//很简单，将数组中的数都转为二进制数，每一位都放到前缀树中。</span></span><br><span class="line">    <span class="comment">//遍历数组，找当前位上 异或为1的路，找不到就0，然后继续找下一位</span></span><br><span class="line">    <span class="comment">//遍历完每个数后，将结果比较max即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findMaximumXOR</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        build(nums);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> num : nums )&#123;</span><br><span class="line">            ans = Math.max(ans, find(num));</span><br><span class="line">        &#125;</span><br><span class="line">        clear();</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="comment">//从最高位开始插入</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> HIGH - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">want</span> <span class="operator">=</span> index ^ <span class="number">1</span>;</span><br><span class="line">            <span class="comment">//对应路径如果没有值</span></span><br><span class="line">            <span class="keyword">if</span> (root[cur][want] == <span class="number">0</span>)&#123;</span><br><span class="line">                want ^= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ans |= (index ^ want) &lt;&lt; i;</span><br><span class="line">            <span class="comment">//跳转到实际往下走的路</span></span><br><span class="line">            cur = root[cur][want];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 准备这么多静态空间就够了，实验出来的</span></span><br><span class="line">    <span class="comment">// 如果测试数据升级了规模，就改大这个值</span></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>  <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">3000001</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span>[][] root = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN][<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> cnt;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> HIGH;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">clear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= cnt; i++) &#123;</span><br><span class="line">            root[i][<span class="number">0</span>] = root[i][<span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">build</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//找最大位数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> num : nums )&#123;</span><br><span class="line">            max = Math.max(max, num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//最高位数</span></span><br><span class="line">        HIGH = <span class="number">32</span> - Integer.numberOfLeadingZeros(max);</span><br><span class="line">        <span class="keyword">for</span>( <span class="type">int</span> num : nums )&#123;</span><br><span class="line">            insert(num);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="comment">//从最高位开始插入</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> HIGH - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (num &gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span> (root[cur][index] == <span class="number">0</span>)&#123;</span><br><span class="line">                root[cur][index] = ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = root[cur][index];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 相关题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 相关题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trie1</title>
      <link href="/2024/04/09/Trie1/"/>
      <url>/2024/04/09/Trie1/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.前缀树;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Trie1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> *  * 前缀树  用数组实现</span></span><br><span class="line"><span class="comment"> *  核心思想：（感觉就是邻接矩阵）</span></span><br><span class="line"><span class="comment"> *  用二维数组标记每个字母的路径（列为字母，行为起点，值为目标点），用cnt维护最新编号（主要用于标记，类似id的作用）</span></span><br><span class="line"><span class="comment"> *  用pass数组记录每个编号经过次数。end数组记录每个编号结束次数</span></span><br><span class="line"><span class="comment"> *  插入值，则为从行1开始，向下跳转。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *  * https://www.nowcoder.com/practice/7f8a8553ddbf4eaab749ec988726702b</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/4/9 15:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">//自己根据思路实现的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Trie1</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果将来增加了数据量，就改大这个值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAX</span> <span class="operator">=</span> <span class="number">150001</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组存储路径</span></span><br><span class="line">    <span class="type">int</span>[][] root = <span class="keyword">new</span> <span class="title class_">int</span>[MAX][<span class="number">26</span>];</span><br><span class="line">    <span class="comment">//编号经过次数</span></span><br><span class="line">    <span class="type">int</span>[] pass = <span class="keyword">new</span> <span class="title class_">int</span>[MAX];</span><br><span class="line">    <span class="comment">//编号结束次数</span></span><br><span class="line">    <span class="type">int</span>[] end = <span class="keyword">new</span> <span class="title class_">int</span>[MAX];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始编号</span></span><br><span class="line">    <span class="type">int</span> cnt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie1</span><span class="params">()</span> &#123;</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">Trie1</span> <span class="variable">trie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie1</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//现在给定一个m，表示有m次操作，每次操作都为以上四种操作之一。</span></span><br><span class="line">        <span class="comment">// 每次操作会给定一个整数op和一个字符串word，op代表一个操作码，</span></span><br><span class="line">        <span class="comment">// 如果op为1，则代表添加word，op为2则代表删除word，</span></span><br><span class="line">        <span class="comment">// op为3则代表查询word是否在字典树中，op为4代表返回以word为前缀的单词数量（数据保证不会删除不存在的word)</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = bf.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> Integer.parseInt(line);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                String[] split = bf.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">op</span> <span class="operator">=</span> Integer.parseInt(split[<span class="number">0</span>]);</span><br><span class="line">                <span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> split[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (op == <span class="number">1</span>)&#123;</span><br><span class="line">                    trie.insert(word);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">                    trie.delete(word);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) &#123;</span><br><span class="line">                    out.println(trie.search(word) ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    out.println(trie.prefixNumber(word));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.flush();</span><br><span class="line">        bf.close();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加word，可重复添加</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span>&#123;</span><br><span class="line">        <span class="comment">//从1开始</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        pass[cur]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (root[cur][index] == <span class="number">0</span>)&#123;</span><br><span class="line">                root[cur][index] = ++cnt;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//跳到下一个</span></span><br><span class="line">            cur = root[cur][index];</span><br><span class="line"></span><br><span class="line">            <span class="comment">//经过路径+1</span></span><br><span class="line">            pass[cur]++;</span><br><span class="line">            <span class="comment">//这样也能实现，只是没那么优雅</span></span><br><span class="line">            <span class="comment">// if (i == word.length() - 1) &#123;</span></span><br><span class="line">            <span class="comment">//     end[cur]++;</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">        end[cur]++;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除word，如果word添加过多次，仅删除一次</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String word)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (search(word))&#123;</span><br><span class="line">            <span class="comment">//从1开始</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            pass[cur]--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> cur;</span><br><span class="line">                <span class="comment">//跳到下一个</span></span><br><span class="line">                cur = root[cur][index];</span><br><span class="line">                <span class="keyword">if</span> (--pass[cur] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//都删掉了，则去掉该路径</span></span><br><span class="line">                    root[pre][index] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (i == word.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                    end[cur]--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询word是否在字典树中出现过(完整的出现过，前缀式不算)</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span>&#123;</span><br><span class="line">        <span class="comment">//从1开始</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (root[cur][index] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//跳到下一个</span></span><br><span class="line">            cur = root[cur][index];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (i == word.length() - <span class="number">1</span> &amp;&amp; end[cur] == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回以字符串pre作为前缀的单词数量</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">prefixNumber</span><span class="params">(String word)</span>&#123;</span><br><span class="line">        <span class="comment">//从1开始</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (root[cur][index] == <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//跳到下一个</span></span><br><span class="line">            cur = root[cur][index];</span><br><span class="line">            <span class="comment">//这样也能实现，只是没那么优雅</span></span><br><span class="line">            <span class="comment">// if (i == word.length() - 1) &#123;</span></span><br><span class="line">            <span class="comment">//     return pass[cur];</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// return 0;</span></span><br><span class="line">        <span class="keyword">return</span> pass[cur];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 前缀树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前缀树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TrieTree</title>
      <link href="/2024/04/08/TrieTree/"/>
      <url>/2024/04/08/TrieTree/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.前缀树;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用类描述实现前缀树。不推荐！</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/implement-trie-ii-prefix-tree/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TrieTree</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 路是数组实现的</span></span><br><span class="line">    <span class="comment">// 提交时把类名、构造方法改为Trie</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Trie1</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> pass;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> end;</span><br><span class="line">            <span class="keyword">public</span> TrieNode[] nexts;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">                pass = <span class="number">0</span>;</span><br><span class="line">                end = <span class="number">0</span>;</span><br><span class="line">                nexts = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Trie1</span><span class="params">()</span> &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">            <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">            node.pass++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; word.length(); i++) &#123; <span class="comment">// 从左往右遍历字符</span></span><br><span class="line">                path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>; <span class="comment">// 由字符，对应成走向哪条路</span></span><br><span class="line">                <span class="keyword">if</span> (node.nexts[path] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    node.nexts[path] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.nexts[path];</span><br><span class="line">                node.pass++;</span><br><span class="line">            &#125;</span><br><span class="line">            node.end++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果之前word插入过前缀树，那么此时删掉一次</span></span><br><span class="line">        <span class="comment">// 如果之前word没有插入过前缀树，那么什么也不做</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">erase</span><span class="params">(String word)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (countWordsEqualTo(word) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">                node.pass--;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; word.length(); i++) &#123;</span><br><span class="line">                    path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                    <span class="keyword">if</span> (--node.nexts[path].pass == <span class="number">0</span>) &#123;</span><br><span class="line">                        node.nexts[path] = <span class="literal">null</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    node = node.nexts[path];</span><br><span class="line">                &#125;</span><br><span class="line">                node.end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询前缀树里，word单词出现了几次</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWordsEqualTo</span><span class="params">(String word)</span> &#123;</span><br><span class="line">            <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; word.length(); i++) &#123;</span><br><span class="line">                path = word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (node.nexts[path] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.nexts[path];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node.end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 查询前缀树里，有多少单词以pre做前缀</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWordsStartingWith</span><span class="params">(String pre)</span> &#123;</span><br><span class="line">            <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; pre.length(); i++) &#123;</span><br><span class="line">                path = pre.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (node.nexts[path] == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.nexts[path];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node.pass;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 路是哈希表实现的</span></span><br><span class="line">    <span class="comment">// 提交时把类名、构造方法改为Trie</span></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Trie2</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">TrieNode</span> &#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> pass;</span><br><span class="line">            <span class="keyword">public</span> <span class="type">int</span> end;</span><br><span class="line">            HashMap&lt;Integer, TrieNode&gt; nexts;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">                pass = <span class="number">0</span>;</span><br><span class="line">                end = <span class="number">0</span>;</span><br><span class="line">                nexts = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Trie2</span><span class="params">()</span> &#123;</span><br><span class="line">            root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span> &#123;</span><br><span class="line">            <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">            node.pass++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; word.length(); i++) &#123; <span class="comment">// 从左往右遍历字符</span></span><br><span class="line">                path = word.charAt(i);</span><br><span class="line">                <span class="keyword">if</span> (!node.nexts.containsKey(path)) &#123;</span><br><span class="line">                    node.nexts.put(path, <span class="keyword">new</span> <span class="title class_">TrieNode</span>());</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.nexts.get(path);</span><br><span class="line">                node.pass++;</span><br><span class="line">            &#125;</span><br><span class="line">            node.end++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">erase</span><span class="params">(String word)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (countWordsEqualTo(word) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">                TrieNode next;</span><br><span class="line">                node.pass--;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; word.length(); i++) &#123;</span><br><span class="line">                    path = word.charAt(i);</span><br><span class="line">                    next = node.nexts.get(path);</span><br><span class="line">                    <span class="keyword">if</span> (--next.pass == <span class="number">0</span>) &#123;</span><br><span class="line">                        node.nexts.remove(path);</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    node = next;</span><br><span class="line">                &#125;</span><br><span class="line">                node.end--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWordsEqualTo</span><span class="params">(String word)</span> &#123;</span><br><span class="line">            <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; word.length(); i++) &#123;</span><br><span class="line">                path = word.charAt(i);</span><br><span class="line">                <span class="keyword">if</span> (!node.nexts.containsKey(path)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.nexts.get(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node.end;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countWordsStartingWith</span><span class="params">(String pre)</span> &#123;</span><br><span class="line">            <span class="type">TrieNode</span> <span class="variable">node</span> <span class="operator">=</span> root;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, path; i &lt; pre.length(); i++) &#123;</span><br><span class="line">                path = pre.charAt(i);</span><br><span class="line">                <span class="keyword">if</span> (!node.nexts.containsKey(path)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                node = node.nexts.get(path);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> node.pass;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 前缀树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前缀树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trie</title>
      <link href="/2024/04/08/Trie/"/>
      <url>/2024/04/08/Trie/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.前缀树;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Trie</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * 前缀树</span></span><br><span class="line"><span class="comment"> * https://www.nowcoder.com/practice/7f8a8553ddbf4eaab749ec988726702b</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/4/8 16:54</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">//类实现方式：</span></span><br><span class="line"><span class="comment">// 核心思想：主要是类的结构，结构出来了就很简单了。  主要有经过数量统计p, 结束数量统计end,下一个前缀数组next。</span></span><br><span class="line">    <span class="comment">//这个是自己根据思路实现的</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Trie</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">TrieNode</span>&#123;</span><br><span class="line">        <span class="type">int</span> p;</span><br><span class="line">        <span class="type">int</span> end;</span><br><span class="line">        TrieNode[] next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">TrieNode</span><span class="params">()</span> &#123;</span><br><span class="line">            next = <span class="keyword">new</span> <span class="title class_">TrieNode</span>[<span class="number">26</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TrieNode root;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Trie</span><span class="params">()</span> &#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">Trie</span> <span class="variable">trie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Trie</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//现在给定一个m，表示有m次操作，每次操作都为以上四种操作之一。</span></span><br><span class="line">        <span class="comment">// 每次操作会给定一个整数op和一个字符串word，op代表一个操作码，</span></span><br><span class="line">        <span class="comment">// 如果op为1，则代表添加word，op为2则代表删除word，</span></span><br><span class="line">        <span class="comment">// op为3则代表查询word是否在字典树中，op为4代表返回以word为前缀的单词数量（数据保证不会删除不存在的word)</span></span><br><span class="line">        String line;</span><br><span class="line">        <span class="keyword">while</span> ((line = bf.readLine()) != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> Integer.parseInt(line);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">                String[] split = bf.readLine().split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">                <span class="type">int</span> <span class="variable">op</span> <span class="operator">=</span> Integer.parseInt(split[<span class="number">0</span>]);</span><br><span class="line">                <span class="type">String</span> <span class="variable">word</span> <span class="operator">=</span> split[<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (op == <span class="number">1</span>)&#123;</span><br><span class="line">                    trie.insert(word);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>) &#123;</span><br><span class="line">                    trie.delete(word);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">3</span>) &#123;</span><br><span class="line">                    out.println(trie.search(word) ? <span class="string">&quot;YES&quot;</span> : <span class="string">&quot;NO&quot;</span>);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    out.println(trie.prefixNumber(word));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.flush();</span><br><span class="line">        bf.close();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//添加word，可重复添加</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">insert</span><span class="params">(String word)</span>&#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        cur.p++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.next[index] == <span class="literal">null</span>)&#123;</span><br><span class="line">                cur.next[index] = <span class="keyword">new</span> <span class="title class_">TrieNode</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next[index];</span><br><span class="line">            cur.p++;</span><br><span class="line">            <span class="keyword">if</span> (i == word.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                cur.end++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//删除word，如果word添加过多次，仅删除一次</span></span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">delete</span><span class="params">(String word)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (search(word))&#123;</span><br><span class="line">            <span class="type">TrieNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">            cur.p--;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">                <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">                <span class="keyword">if</span> (--cur.next[index].p == <span class="number">0</span>)&#123;</span><br><span class="line">                    cur.next[index] = <span class="literal">null</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cur = cur.next[index];</span><br><span class="line">                <span class="keyword">if</span> (i == word.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                    cur.end--;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//查询word是否在字典树中出现过(完整的出现过，前缀式不算)</span></span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">search</span><span class="params">(String word)</span>&#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.next[index] == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next[index];</span><br><span class="line">            <span class="keyword">if</span> (i == word.length() - <span class="number">1</span> &amp;&amp; cur.end == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回以字符串pre作为前缀的单词数量</span></span><br><span class="line">    <span class="type">int</span> <span class="title function_">prefixNumber</span><span class="params">(String word)</span>&#123;</span><br><span class="line">        <span class="type">TrieNode</span> <span class="variable">cur</span> <span class="operator">=</span> root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; word.length(); i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> word.charAt(i) - <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (cur.next[index] == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next[index];</span><br><span class="line">            <span class="keyword">if</span> (i == word.length() - <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> cur.p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 前缀树 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前缀树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SuperpalindromesInRange</title>
      <link href="/2024/03/28/SuperpalindromesInRange/"/>
      <url>/2024/03/28/SuperpalindromesInRange/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.必备;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> SuperpalindromesInRange</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/28 14:27</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SuperpalindromesInRange</span> &#123;</span><br><span class="line">    <span class="comment">//核心思想：</span></span><br><span class="line">    <span class="comment">//题目范围数据量太大。想办法缩小数据量</span></span><br><span class="line">    <span class="comment">//1、找出某数是回文数，再看平方是否回文数。数据量缩小为10^9</span></span><br><span class="line">    <span class="comment">//2、找出某数（称为种子),将种子构造出回文数（长度为奇偶的回文数），数据量再次缩小为10^5.</span></span><br><span class="line">    <span class="comment">//3、这个数据量，直接遍历都可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">superpalindromesInRange</span><span class="params">(String left, String right)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历1~10^5次方的所有种子变成的回文数，看是否再根号下right范围内</span></span><br><span class="line">        <span class="type">Long</span> <span class="variable">l</span> <span class="operator">=</span> Long.valueOf(left);</span><br><span class="line">        <span class="type">Long</span> <span class="variable">r</span> <span class="operator">=</span> Long.valueOf(right);</span><br><span class="line">        <span class="type">double</span> <span class="variable">limit</span> <span class="operator">=</span> Math.sqrt(Double.valueOf(right));</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//构造回文数</span></span><br><span class="line">            <span class="type">Long</span> <span class="variable">j</span> <span class="operator">=</span> jH(i);</span><br><span class="line">            <span class="type">Long</span> <span class="variable">o</span> <span class="operator">=</span> oH(i);</span><br><span class="line">            <span class="keyword">if</span> (j &gt; limit)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//判断回文数是否符合条件</span></span><br><span class="line">            <span class="type">long</span> <span class="variable">jL</span> <span class="operator">=</span>  j * j;</span><br><span class="line">            <span class="type">long</span> <span class="variable">ol</span> <span class="operator">=</span>  o * o;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (jL &gt;= l &amp;&amp; judge(jL))&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ol &lt;= r &amp;&amp; ol &gt;= l &amp;&amp; judge(ol))&#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">judge</span><span class="params">(<span class="type">long</span> num)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(num);</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s.charAt(l++) != s.charAt(r--))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">jH</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> num;</span><br><span class="line">        num = num / <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">while</span> (num != <span class="number">0</span>)&#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">oH</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> num;</span><br><span class="line">        <span class="keyword">while</span> (num != <span class="number">0</span>)&#123;</span><br><span class="line">            ans = ans * <span class="number">10</span> + num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 必备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KillMonsterEverySkillUseOnce</title>
      <link href="/2024/03/27/KillMonsterEverySkillUseOnce/"/>
      <url>/2024/03/27/KillMonsterEverySkillUseOnce/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.必备;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> KillMonsterEverySkillUseOnce</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * // 现在有一个打怪类型的游戏，这个游戏是这样的，你有n个技能</span></span><br><span class="line"><span class="comment"> * // 每一个技能会有一个伤害，</span></span><br><span class="line"><span class="comment"> * // 同时若怪物小于等于一定的血量，则该技能可能造成双倍伤害</span></span><br><span class="line"><span class="comment"> * // 每一个技能最多只能释放一次，已知怪物有m点血量</span></span><br><span class="line"><span class="comment"> * // 现在想问你最少用几个技能能消灭掉他(血量小于等于0)</span></span><br><span class="line"><span class="comment"> * // 技能的数量是n，怪物的血量是m</span></span><br><span class="line"><span class="comment"> * // i号技能的伤害是x[i]，i号技能触发双倍伤害的血量最小值是y[i]</span></span><br><span class="line"><span class="comment"> * // 1 &lt;= n &lt;= 10</span></span><br><span class="line"><span class="comment"> * // 1 &lt;= m、x[i]、y[i] &lt;= 10^6</span></span><br><span class="line"><span class="comment"> * // 测试链接 : https://www.nowcoder.com/practice/d88ef50f8dab4850be8cd4b95514bbbd</span></span><br><span class="line"><span class="comment"> * // 请同学们务必参考如下代码中关于输入、输出的处理</span></span><br><span class="line"><span class="comment"> * // 这是输入输出处理效率很高的写法</span></span><br><span class="line"><span class="comment"> * // 提交以下的所有代码，并把主类名改成&quot;Main&quot;</span></span><br><span class="line"><span class="comment"> * // 可以直接通过</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/27 17:05</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">KillMonsterEverySkillUseOnce</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">MAXN</span> <span class="operator">=</span> <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] kill = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] blood = <span class="keyword">new</span> <span class="title class_">int</span>[MAXN];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> (<span class="type">int</span>) in.nval;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; t; i++) &#123;</span><br><span class="line">                in.nextToken();</span><br><span class="line">                <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">int</span>) in.nval;</span><br><span class="line">                in.nextToken();</span><br><span class="line">                <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (<span class="type">int</span>) in.nval;</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                    in.nextToken();</span><br><span class="line">                    kill[j] = (<span class="type">int</span>) in.nval;</span><br><span class="line">                    in.nextToken();</span><br><span class="line">                    blood[j] = (<span class="type">int</span>) in.nval;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> f(n, <span class="number">0</span>, m);</span><br><span class="line">                out.println(ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        br.close();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//技能的数量是n，怪物的血量是m</span></span><br><span class="line">    <span class="comment">//i号技能的伤害是x[i]，i号技能触发双倍伤害的血量最小值是y[i]</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> i, <span class="type">int</span> m)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (m &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> Integer.MAX_VALUE;</span><br><span class="line">        <span class="comment">//标准全排列代码</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; n; j++) &#123;</span><br><span class="line">            swap(j, i);</span><br><span class="line">            ans =  Math.min(ans, f(n, i + <span class="number">1</span>,  m - (m &lt;= blood[i] ? <span class="number">2</span> * kill[i] : kill[i])));</span><br><span class="line">            swap(i, j);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        blood[i] = blood[i] * blood[j];</span><br><span class="line">        blood[j] = blood[i] * blood[j];</span><br><span class="line">        blood[i] = blood[i] * blood[j];</span><br><span class="line"></span><br><span class="line">        kill[i] = kill[i] * kill[j];</span><br><span class="line">        kill[j] = kill[i] * kill[j];</span><br><span class="line">        kill[i] = kill[i] * kill[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 必备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DivisorGame</title>
      <link href="/2024/03/27/DivisorGame/"/>
      <url>/2024/03/27/DivisorGame/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.打表;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> DivisorGame</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * 1025 除数博弈</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/27 16:56</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DivisorGame</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归不通过</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">divisorGame1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;a&quot;</span>.equals(f(n, <span class="string">&quot;a&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//祭出打表法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">divisorGame</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> n % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DivisorGame</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DivisorGame</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">20</span>; i++) &#123;</span><br><span class="line">            System.out.println(i + <span class="string">&quot;:&quot;</span> + d.divisorGame(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//暴力递归</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">f</span><span class="params">(<span class="type">int</span> n, String cur)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">em</span> <span class="operator">=</span> cur.equals(<span class="string">&quot;a&quot;</span>) ? <span class="string">&quot;b&quot;</span> : <span class="string">&quot;a&quot;</span>;</span><br><span class="line">        <span class="comment">//判断是否输了</span></span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> em;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//选自己赢的回合</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (n % i != <span class="number">0</span>)&#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//返回赢的情况</span></span><br><span class="line">            <span class="keyword">if</span> (cur.equals(f(n - i, em)))&#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> em;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 打表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 打表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AppleMinBags</title>
      <link href="/2024/03/27/AppleMinBags/"/>
      <url>/2024/03/27/AppleMinBags/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.打表;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> AppleMinBags</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 买苹果</span></span><br><span class="line"><span class="comment"> * // 有装下8个苹果的袋子、装下6个苹果的袋子，一定要保证买苹果时所有使用的袋子都装满</span></span><br><span class="line"><span class="comment"> * // 对于无法装满所有袋子的方案不予考虑，给定n个苹果，返回至少要多少个袋子</span></span><br><span class="line"><span class="comment"> * // 如果不存在每个袋子都装满的方案返回-1</span></span><br><span class="line"><span class="comment"> * 测试链接： https://www.nowcoder.com/questionTerminal/61cfbb2e62104bc8aa3da5d44d38a6ef</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/27 15:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppleMinBags</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main1</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">bf</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(bf);</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(in.nextToken() != StreamTokenizer.TT_EOF)&#123;</span><br><span class="line">            n = (<span class="type">int</span>) in.nval;</span><br><span class="line">            out.println(bags(n));</span><br><span class="line">        &#125;</span><br><span class="line">        out.flush();</span><br><span class="line">        bf.close();</span><br><span class="line">        out.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//法1：暴力递归</span></span><br><span class="line">    <span class="comment">//核心思想：尝试 选6 或 8个袋子，递归选下一个袋子</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bags</span><span class="params">(<span class="type">int</span> apple)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (apple % <span class="number">2</span> != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> f(apple);</span><br><span class="line">        <span class="keyword">return</span> ans == Integer.MAX_VALUE ? -<span class="number">1</span> : ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//要取最小值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">6</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans1</span> <span class="operator">=</span> f(n - <span class="number">6</span>);</span><br><span class="line">        <span class="keyword">if</span> (ans1 != Integer.MAX_VALUE)&#123;</span><br><span class="line">            ans1++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans2</span> <span class="operator">=</span> f(n - <span class="number">8</span>);</span><br><span class="line">        <span class="keyword">if</span> (ans2 != Integer.MAX_VALUE)&#123;</span><br><span class="line">            ans2++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Math.min(ans1, ans2);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//打表观察规律</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">bags1</span><span class="params">(<span class="type">int</span> apple)</span>&#123;</span><br><span class="line">        <span class="comment">//打表法观察得 18以上， 每8个一组，结果+1</span></span><br><span class="line">        <span class="keyword">if</span> (apple % <span class="number">2</span> != <span class="number">0</span> || apple &lt; <span class="number">6</span> || apple == <span class="number">10</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (apple &lt; <span class="number">12</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (apple &lt; <span class="number">18</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (apple - <span class="number">18</span>) / <span class="number">8</span> + <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">apple</span> <span class="operator">=</span> <span class="number">0</span>; apple &lt; <span class="number">100</span>; apple++) &#123;</span><br><span class="line">            System.out.println(apple + <span class="string">&quot; : &quot;</span> + bags(apple));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 打表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 打表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NthMagicalNumber</title>
      <link href="/2024/03/25/NthMagicalNumber/"/>
      <url>/2024/03/25/NthMagicalNumber/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.必备;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> NthMagicalNumber</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> *  * 第 N 个神奇数字</span></span><br><span class="line"><span class="comment"> *  * https://leetcode.cn/problems/nth-magical-number/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/25 17:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NthMagicalNumber</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">mod</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">    <span class="comment">//核心思想：二分答案法。</span></span><br><span class="line">    <span class="comment">//1、先确定答案范围 2、在答案范围 二分 3、根据逻辑 获取答案</span></span><br><span class="line">    <span class="comment">//注意这题是求具体的数字，而不是多少个神奇数字</span></span><br><span class="line">    <span class="comment">//注意取值范围（int 和long的转换)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthMagicalNumber</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">lcm</span> <span class="operator">=</span> lcm(a, b);</span><br><span class="line">        <span class="comment">//答案的数字最大范围</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">r</span> <span class="operator">=</span> (<span class="type">long</span>)n * Math.min(a, b), l = <span class="number">0</span>, m = <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="comment">//二分范围</span></span><br><span class="line">            <span class="comment">//用某个确定的中间值，取获取答案</span></span><br><span class="line">            m = (r + l) / <span class="number">2</span>;</span><br><span class="line">            <span class="comment">//求该范围内有多少个数字</span></span><br><span class="line">            cnt = getMagNums(m, a, b, lcm);</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt;= n) &#123;<span class="comment">//缩小范围</span></span><br><span class="line">                ans = m;</span><br><span class="line">                r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//扩大范围</span></span><br><span class="line">                l = m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (ans % mod);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取n范围内有多少个神奇的数字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">getMagNums</span><span class="params">(<span class="type">long</span> n, <span class="type">int</span> a, <span class="type">int</span> b, <span class="type">long</span> lcm)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (n / a) + (n / b) - (n / lcm);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取最小公倍数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">lcm</span> <span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a / gcd(a, b) * b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最小公因数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">long</span> <span class="title function_">gcd</span><span class="params">(<span class="type">long</span> a, <span class="type">long</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ? a : gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 必备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GcdAndLcm</title>
      <link href="/2024/03/25/GcdAndLcm/"/>
      <url>/2024/03/25/GcdAndLcm/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.必备;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> GcdAndLcm</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 求最大公约数和最小公倍数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/25 16:27</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GcdAndLcm</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最大公约数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> b == <span class="number">0</span> ?  a : gcd(b, a % b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//最小公倍数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">long</span>) a / gcd(a, b) * b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main1</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(Integer.numberOfLeadingZeros(<span class="number">1</span> &lt;&lt; <span class="number">30</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Long&gt; l1 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">5L</span>,<span class="number">4L</span>,<span class="number">3L</span>,<span class="number">2L</span>,<span class="number">1L</span>));</span><br><span class="line">        List&lt;Long&gt; l2 = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(Arrays.asList(<span class="number">5L</span>,<span class="number">4L</span>,<span class="number">3L</span>,<span class="number">2L</span>,<span class="number">1L</span>));</span><br><span class="line"></span><br><span class="line">        sortByPcIds(l1,l2);</span><br><span class="line">        l1.forEach(System.out::println);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sortByPcIds</span><span class="params">(List&lt;Long&gt; target, List&lt;Long&gt; pcIds)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (target == <span class="literal">null</span> || pcIds == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Input lists cannot be null.&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将pcIds转换为Set，以提高查找效率</span></span><br><span class="line">        Set&lt;Long&gt; pcIdsSet = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;(pcIds);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 对target列表进行排序</span></span><br><span class="line">        target.sort((i1, i2) -&gt; &#123;</span><br><span class="line">            <span class="comment">// 检查i1和i2是否都在pcIds中</span></span><br><span class="line">            <span class="type">boolean</span> <span class="variable">containsI1</span> <span class="operator">=</span> pcIdsSet.contains(i1);</span><br><span class="line">            <span class="type">boolean</span> <span class="variable">containsI2</span> <span class="operator">=</span> pcIdsSet.contains(i2);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果两者都在pcIds中，比较它们在pcIds中的顺序</span></span><br><span class="line">            <span class="keyword">if</span> (containsI1 &amp;&amp; containsI2) &#123;</span><br><span class="line">                <span class="keyword">return</span> pcIds.indexOf(i1) - pcIds.indexOf(i2);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (containsI1) &#123;</span><br><span class="line">                <span class="comment">// 如果只有i1在pcIds中，i1应该排在前面</span></span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (containsI2) &#123;</span><br><span class="line">                <span class="comment">// 如果只有i2在pcIds中，i2应该排在前面</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果两者都不在pcIds中，保持原有顺序</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 必备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NQueens</title>
      <link href="/2024/03/25/NQueens/"/>
      <url>/2024/03/25/NQueens/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.必备;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> NQueens</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * // N皇后问题</span></span><br><span class="line"><span class="comment"> * // 测试链接 : https://leetcode.cn/problems/n-queens-ii/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/25 16:27</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">NQueens</span> &#123;</span><br><span class="line">    <span class="comment">//核心思想，用二进制位代替数组，标记已放置列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalNQueens</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">limit</span> <span class="operator">=</span> (<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> f(limit, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//limit:n问题的总限制</span></span><br><span class="line">    <span class="comment">//left:左边列限制</span></span><br><span class="line">    <span class="comment">//right:右边列限制</span></span><br><span class="line">    <span class="comment">//cur：当前列限制</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> limit, <span class="type">int</span> left, <span class="type">int</span> right, <span class="type">int</span> cur)</span>&#123;</span><br><span class="line">        <span class="comment">//当前所有列都占满了，返回该种结果</span></span><br><span class="line">        <span class="keyword">if</span> (cur == limit)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//获取所有可取的位置（1可取，0不可取)</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">batch</span> <span class="operator">=</span> cur | left | right;</span><br><span class="line">        batch = limit &amp; (~batch);</span><br><span class="line">        <span class="keyword">while</span> (batch != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="comment">//获取最右边的1</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> batch &amp; (-batch);</span><br><span class="line">            batch -= p;</span><br><span class="line">            <span class="comment">//递归取可用列</span></span><br><span class="line">            ans += f(limit, (left | p) &gt;&gt; <span class="number">1</span>, (right | p) &lt;&lt; <span class="number">1</span>, cur | p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心思想：存储以往递归已放位置，校验遍历可放位置</span></span><br><span class="line">    <span class="comment">//单纯递归遍历所有可放位置罢了</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">totalNQueens1</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] p = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        <span class="keyword">return</span> f(p, n, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//已放位置数组：索引为行，值为列</span></span><br><span class="line">    <span class="comment">//n为n皇后</span></span><br><span class="line">    <span class="comment">//i是当前遍历行</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] p, <span class="type">int</span> n, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="comment">//已遍历所有行，得到的1种可行方法</span></span><br><span class="line">        <span class="keyword">if</span> (i == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历每一列，看是否可放</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="comment">//校验当前列是否可放</span></span><br><span class="line">            <span class="keyword">if</span> (check(p, j, i))&#123;</span><br><span class="line">                <span class="comment">//可放，则把当前行设置为相应可放列</span></span><br><span class="line">                p[i] = j;</span><br><span class="line">                ans += f(p, n, i + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">check</span><span class="params">(<span class="type">int</span>[] p, <span class="type">int</span> j, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>; k &lt; i; k++) &#123;</span><br><span class="line">            <span class="comment">//校验以往列 || 对角线(当前行减去以往行 == 当前列减去以往列（斜率相同为1，相减除以斜率1  相等）</span></span><br><span class="line">            <span class="keyword">if</span> (p[k] == j || Math.abs(i - k) == Math.abs(j - p[k]))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 必备 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 必备 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CountOfAtoms</title>
      <link href="/2024/03/22/CountOfAtoms/"/>
      <url>/2024/03/22/CountOfAtoms/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.嵌套类问题递归解题套路;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.TreeMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 原子的数量</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> *     //核心思想：用map记录上一轮递归返回的统计结果，后面汇总到总map。</span></span><br><span class="line"><span class="comment"> *     //通用代码：遇到数字就继续遍历统计数字</span></span><br><span class="line"><span class="comment"> *     //1、统计元素：直到遇到非小写字母</span></span><br><span class="line"><span class="comment"> *     //2、遇到大写字母或&quot;(&quot;则 重新开始统计元素并汇总，遇到“（”则递归统计下一轮</span></span><br><span class="line"><span class="comment"> *     //3、遇到数字，则将前面统计的字符串 * 数字 的结果再放入map中</span></span><br><span class="line"><span class="comment"> *     //4、遇到“）”则结束当前递归，并更新当前索引，更新pre字符串，统计当次递归字符元素</span></span><br><span class="line"><span class="comment"> *  https://leetcode.cn/problems/number-of-atoms/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024-03-22 14:33:26</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountOfAtoms</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下是左神的代码</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">countOfAtoms</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        where = <span class="number">0</span>;</span><br><span class="line">        TreeMap&lt;String, Integer&gt; map = f(str.toCharArray(), <span class="number">0</span>);</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (String key : map.keySet()) &#123;</span><br><span class="line">            ans.append(key);</span><br><span class="line">            <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            <span class="keyword">if</span> (cnt &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                ans.append(cnt);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> where;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// s[i....]开始计算，遇到字符串终止 或者 遇到 ) 停止</span></span><br><span class="line">    <span class="comment">// 返回 : 自己负责的这一段字符串的结果，有序表！</span></span><br><span class="line">    <span class="comment">// 返回之间，更新全局变量where，为了上游函数知道从哪继续！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> TreeMap&lt;String, Integer&gt; <span class="title function_">f</span><span class="params">(<span class="type">char</span>[] s, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="comment">// ans是总表</span></span><br><span class="line">        TreeMap&lt;String, Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">// 之前收集到的名字，历史一部分</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">name</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="comment">// 之前收集到的有序表，历史一部分</span></span><br><span class="line">        TreeMap&lt;String, Integer&gt; pre = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">// 历史翻几倍</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length &amp;&amp; s[i] != <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span> || s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">                fill(ans, name, pre, cnt);</span><br><span class="line">                name.setLength(<span class="number">0</span>);</span><br><span class="line">                pre = <span class="literal">null</span>;</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;Z&#x27;</span>) &#123;</span><br><span class="line">                    name.append(s[i++]);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 遇到 (</span></span><br><span class="line">                    pre = f(s, i + <span class="number">1</span>);</span><br><span class="line">                    i = where + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;z&#x27;</span>) &#123;</span><br><span class="line">                name.append(s[i++]);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cnt = cnt * <span class="number">10</span> + s[i++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        fill(ans, name, pre, cnt);</span><br><span class="line">        where = i;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">fill</span><span class="params">(TreeMap&lt;String, Integer&gt; ans, StringBuilder name, TreeMap&lt;String, Integer&gt; pre, <span class="type">int</span> cnt)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.length() &gt; <span class="number">0</span> || pre != <span class="literal">null</span>) &#123;</span><br><span class="line">            cnt = cnt == <span class="number">0</span> ? <span class="number">1</span> : cnt;</span><br><span class="line">            <span class="keyword">if</span> (name.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="type">String</span> <span class="variable">key</span> <span class="operator">=</span> name.toString();</span><br><span class="line">                ans.put(key, ans.getOrDefault(key, <span class="number">0</span>) + cnt);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (String key : pre.keySet()) &#123;</span><br><span class="line">                    ans.put(key, ans.getOrDefault(key, <span class="number">0</span>) + pre.get(key) * cnt);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*************************以下是自己写的****************/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心思想：</span></span><br><span class="line">    <span class="comment">//1、统计元素：直到遇到非小写字母</span></span><br><span class="line">    <span class="comment">//2、遇到大写字母则 重新开始统计元素</span></span><br><span class="line">    <span class="comment">//3、遇到数字，则将前面统计的字符串 * 数字 的结果再放入map中</span></span><br><span class="line">    <span class="comment">//4、遇到“（”则递归统计下一轮</span></span><br><span class="line">    <span class="comment">//5、遇到“）”则结束当前递归，并更新当前索引，更新pre字符串，统计当次递归字符元素</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">countOfAtoms1</span><span class="params">(String formula)</span> &#123;</span><br><span class="line">        where = <span class="number">0</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        TreeMap&lt;String, Integer&gt; map = f(<span class="number">0</span>, formula.toCharArray());</span><br><span class="line"></span><br><span class="line">        map.forEach((k, v) -&gt; &#123;</span><br><span class="line">            builder.append(k);</span><br><span class="line">            <span class="keyword">if</span> (v &gt; <span class="number">1</span>) &#123;</span><br><span class="line">                builder.append(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//自己的思路写的，bug根据左神的改的。</span></span><br><span class="line">    <span class="keyword">public</span> TreeMap&lt;String, Integer&gt; <span class="title function_">f</span><span class="params">(<span class="type">int</span> i, <span class="type">char</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">cur</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//当次统计</span></span><br><span class="line">        TreeMap&lt;String, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        TreeMap&lt;String, Integer&gt; next = <span class="keyword">new</span> <span class="title class_">TreeMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> ( i &lt; arr.length &amp;&amp; arr[i] != <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt;= <span class="string">&#x27;A&#x27;</span> &amp;&amp; arr[i] &lt;= <span class="string">&#x27;Z&#x27;</span> || arr[i] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                <span class="comment">//记录元素，放入map</span></span><br><span class="line">                pre = cur.toString();</span><br><span class="line">                compute(map, next, pre, cnt);</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                pre = <span class="string">&quot;&quot;</span>;</span><br><span class="line">                cur.setLength(<span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (arr[i] == <span class="string">&#x27;(&#x27;</span>)&#123;</span><br><span class="line">                    next = f(i + <span class="number">1</span>, arr);</span><br><span class="line">                    i = where + <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    cur.append(arr[i++]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt;= <span class="string">&#x27;a&#x27;</span> &amp;&amp; arr[i] &lt;= <span class="string">&#x27;z&#x27;</span>)&#123;</span><br><span class="line">                cur.append(arr[i++]);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; arr[i] &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                cnt = cnt * <span class="number">10</span> + arr[i++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理最后一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (!cur.toString().isEmpty())&#123;</span><br><span class="line">            pre = cur.toString();</span><br><span class="line">        &#125;</span><br><span class="line">        compute(map, next, pre, cnt);</span><br><span class="line">        where = i;</span><br><span class="line">        <span class="keyword">return</span> map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">compute</span><span class="params">(TreeMap&lt;String, Integer&gt; map, TreeMap&lt;String, Integer&gt; next, String pre, <span class="type">int</span> cnt)</span>&#123;</span><br><span class="line">        <span class="comment">//统计上一个元素的次数，并重新清零</span></span><br><span class="line">        cnt = cnt == <span class="number">0</span> ? <span class="number">1</span> : cnt;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> cnt;</span><br><span class="line">        <span class="keyword">if</span> (!pre.isEmpty())&#123;</span><br><span class="line">            map.put(pre, cnt + map.getOrDefault(pre, <span class="number">0</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//证明下轮递归有结果</span></span><br><span class="line">        <span class="keyword">if</span> (!next.isEmpty())&#123;</span><br><span class="line">            <span class="comment">//汇总到总map</span></span><br><span class="line">            next.forEach((k, v) -&gt; map.put(k, v * count + map.getOrDefault(k, <span class="number">0</span>)));</span><br><span class="line">            next.clear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">CountOfAtoms</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CountOfAtoms</span>();</span><br><span class="line">        <span class="comment">// c.countOfAtoms(&quot;Mg(OH)2&quot;);</span></span><br><span class="line">        c.countOfAtoms(<span class="string">&quot;((N42)24(OB40Li30CHe3O48LiNN26)33(C12Li48N30H13HBe31)21(BHN30Li26BCBe47N40)15(H5)16)14&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 嵌套类问题递归解题套路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌套类问题递归解题套路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DecodeString</title>
      <link href="/2024/03/21/DecodeString/"/>
      <url>/2024/03/21/DecodeString/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.嵌套类问题递归解题套路;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> DecodeString</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> *  * 字符串解码</span></span><br><span class="line"><span class="comment"> *  * https://leetcode.cn/problems/decode-string/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/21 17:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DecodeString</span> &#123;</span><br><span class="line">    <span class="comment">//核心思想：</span></span><br><span class="line">    <span class="comment">//准备数字栈和字符栈</span></span><br><span class="line">    <span class="comment">//遇到【就递归下次结果</span></span><br><span class="line">    <span class="comment">//遇到】就结束当次递归，并返回处理结果</span></span><br><span class="line">    <span class="comment">//遇到数字就 遍历相加</span></span><br><span class="line">    <span class="comment">//遇到字母就加到字符串</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">decodeString</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        where = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> f(<span class="number">0</span>, s.toCharArray());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> where;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">f</span><span class="params">(<span class="type">int</span> i, <span class="type">char</span>[] s)</span>&#123;</span><br><span class="line">        <span class="comment">//统计数字结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.length &amp;&amp; s[i] != <span class="string">&#x27;]&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; s[i] &lt;= <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                cnt = cnt * <span class="number">10</span> + s[i++] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (s[i] != <span class="string">&#x27;[&#x27;</span>)&#123;<span class="comment">//遇到字母</span></span><br><span class="line">                builder.append(String.valueOf(s[i++]));</span><br><span class="line">                <span class="comment">// cnt = 0;</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//遇到左括号，进入下次递归</span></span><br><span class="line">                <span class="comment">//处理下轮递归得到的字符串结果</span></span><br><span class="line">                compute(cnt, f(i + <span class="number">1</span>, s), builder);</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">//更新遍历</span></span><br><span class="line">                i = where + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//处理当次遍历结果</span></span><br><span class="line">        where = i;</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">compute</span><span class="params">(<span class="type">int</span> cnt, String s, StringBuilder builder)</span>&#123;</span><br><span class="line">        cnt = cnt == <span class="number">0</span> ? <span class="number">1</span> : cnt;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; cnt; i++) &#123;</span><br><span class="line">            builder.append(s);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 嵌套类问题递归解题套路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌套类问题递归解题套路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BasicCalculator</title>
      <link href="/2024/03/21/BasicCalculator/"/>
      <url>/2024/03/21/BasicCalculator/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.嵌套类问题递归解题套路;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> BasicCalculator</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 224,基本计算器</span></span><br><span class="line"><span class="comment"> *  https://leetcode.cn/problems/basic-calculator/description/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/21 15:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BasicCalculator</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心思路：</span></span><br><span class="line">    <span class="comment">//准备一个数字栈和一个符号栈</span></span><br><span class="line">    <span class="comment">//遇到数字 直到遇到符号，则数字入数字栈，符号入符号栈</span></span><br><span class="line">    <span class="comment">//当遇到符号放入符号栈，如果栈顶是*/，则将两栈顶和当前数字处理后，再将结果和当前符号放入栈中</span></span><br><span class="line">    <span class="comment">//遇到） 加入当前数字，处理当前递归结果，并结束当前递归</span></span><br><span class="line">    <span class="comment">//遇到（开启下一个递归</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">calculate</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        where = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> f(<span class="number">0</span>, str.trim());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">int</span> <span class="variable">where</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> i, String str)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; nums = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Character&gt; chars = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//统计数字结果</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cnt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历每个字符，直到遇到）</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; str.length() &amp;&amp; str.charAt(i) != <span class="string">&#x27;)&#x27;</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (str.charAt(i) == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//遇到数字</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (str.charAt(i) &lt;= <span class="string">&#x27;9&#x27;</span> &amp;&amp; str.charAt(i) &gt;= <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                cnt = cnt * <span class="number">10</span> + str.charAt(i++) - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (str.charAt(i) == <span class="string">&#x27;(&#x27;</span>)&#123;<span class="comment">//开启下轮递归</span></span><br><span class="line">                <span class="comment">//把下轮递归结果数字放入栈中</span></span><br><span class="line">                <span class="comment">// push(nums, chars, f(i + 1, str), &#x27;+&#x27;);</span></span><br><span class="line">                cnt = f(i + <span class="number">1</span>, str);</span><br><span class="line">                <span class="comment">//调整位置</span></span><br><span class="line">                i = where + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//遇到符号</span></span><br><span class="line">                push(nums, chars, cnt, str.charAt(i++));</span><br><span class="line">                cnt = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//把括号末尾数字加上</span></span><br><span class="line">        push(nums, chars, cnt, <span class="string">&#x27;+&#x27;</span>);</span><br><span class="line">        <span class="comment">//标记遍历到哪了</span></span><br><span class="line">        where = i;</span><br><span class="line">        <span class="keyword">return</span> comple(nums, chars);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(List&lt;Integer&gt; nums, List&lt;Character&gt; chars, <span class="type">int</span> n, <span class="type">char</span> c )</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (chars.isEmpty() || chars.get(<span class="number">0</span>) == <span class="string">&#x27;+&#x27;</span> || chars.get(<span class="number">0</span>) == <span class="string">&#x27;-&#x27;</span>)&#123;</span><br><span class="line">            nums.add(n);</span><br><span class="line">            chars.add(c);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums.get(nums.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (chars.get(chars.size() - <span class="number">1</span>) == <span class="string">&#x27;*&#x27;</span>)&#123;</span><br><span class="line">                res *= n;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                res /= n;</span><br><span class="line">            &#125;</span><br><span class="line">            nums.add(nums.size() - <span class="number">1</span>, res);</span><br><span class="line">            chars.add(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">comple</span><span class="params">(List&lt;Integer&gt; nums, List&lt;Character&gt; chars)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span>  <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;+&#x27;</span>)&#123;</span><br><span class="line">                res += nums.get(i);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                res -= nums.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">            c = chars.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(calculate(<span class="string">&quot;1+1&quot;</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 嵌套类问题递归解题套路 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 嵌套类问题递归解题套路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TowerOfHanoi</title>
      <link href="/2024/03/19/TowerOfHanoi/"/>
      <url>/2024/03/19/TowerOfHanoi/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.常见经典递归;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> TowerOfHanoi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 打印n层汉诺塔问题的最优移动轨迹</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/19 17:37</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TowerOfHanoi</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//主要流程：</span></span><br><span class="line">    <span class="comment">//左 中 右</span></span><br><span class="line">    <span class="comment">//（n - 1）层  左 -&gt; 右，剩个其他</span></span><br><span class="line">    <span class="comment">// (n-2)层， 右 -》 其他，剩个左</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">hanoi</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        f(n, <span class="string">&quot;左&quot;</span>, <span class="string">&quot;右&quot;</span>, <span class="string">&quot;其他&quot;</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//抽象化思想：（有点像把大象放入冰箱需要几步）（把n-1个盘移走，移动第 n个圆盘，把n-1个盘移回来</span></span><br><span class="line">    <span class="comment">//要移动n个圆盘到最右边的柱子，</span></span><br><span class="line">    <span class="comment">//首页得把n-1个圆盘从左移动到中</span></span><br><span class="line">    <span class="comment">//此时第n个圆盘就可以移动到右边啦</span></span><br><span class="line">    <span class="comment">//再把n-1个圆盘从中移动回 右边</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span> n, String from, String to, String other)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;移动圆盘 &quot;</span> + n + <span class="string">&quot; 从 &quot;</span> + from + <span class="string">&quot; 到 &quot;</span> + to);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将上面的n - 1个圆盘，从from移动到other</span></span><br><span class="line">        f(n - <span class="number">1</span>, from, other, to);</span><br><span class="line">        <span class="comment">//此时第n个圆盘能从from移动到to了，所以打印</span></span><br><span class="line">        System.out.println(<span class="string">&quot;移动圆盘 &quot;</span> + n + <span class="string">&quot; 从 &quot;</span> + from + <span class="string">&quot; 到 &quot;</span> + to);</span><br><span class="line">        <span class="comment">//再将刚才的n-1个圆盘从other移动到to，搞定所有圆盘了</span></span><br><span class="line">        f(n - <span class="number">1</span>, other, to, from);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">        hanoi(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 常见经典递归 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常见经典递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SortStackWithRecursive</title>
      <link href="/2024/03/19/SortStackWithRecursive/"/>
      <url>/2024/03/19/SortStackWithRecursive/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.常见经典递归;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> SortStackWithRecursive</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/19 16:55</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用递归函数排序栈</span></span><br><span class="line"><span class="comment">// 栈只提供push、pop、isEmpty三个方法</span></span><br><span class="line"><span class="comment">// 请完成无序栈的排序，要求排完序之后，从栈顶到栈底从小到大</span></span><br><span class="line"><span class="comment">// 只能使用栈提供的push、pop、isEmpty三个方法、以及递归函数</span></span><br><span class="line"><span class="comment">// 除此之外不能使用任何的容器，数组也不行</span></span><br><span class="line"><span class="comment">// 就是排序过程中只能用：</span></span><br><span class="line"><span class="comment">// 1) 栈提供的push、pop、isEmpty三个方法</span></span><br><span class="line"><span class="comment">// 2) 递归函数，并且返回值最多为单个整数</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortStackWithRecursive</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归找栈最小元素并从栈中移除，然后递归放入该元素即可</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(Stack&lt;Integer&gt; stack)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拿到最小元素，并从栈中移除</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> min(stack);</span><br><span class="line">        removeNum(stack, min);</span><br><span class="line">        <span class="comment">//递归拿最小元素</span></span><br><span class="line">        sort(stack);</span><br><span class="line">        stack.push(min);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//移除指定的数字</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">removeNum</span><span class="params">(Stack&lt;Integer&gt; stack, <span class="type">int</span> tar)</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (num == tar) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        removeNum(stack, tar);</span><br><span class="line">        stack.push(num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">(Stack&lt;Integer&gt; stack)</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (stack.empty()) &#123;</span><br><span class="line">            stack.push(num);</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用递归的上一个数和当前数做对比</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> min(stack);</span><br><span class="line">        stack.push(num);</span><br><span class="line">        <span class="keyword">return</span> Math.min(min, num);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">min1</span><span class="params">(Stack&lt;Integer&gt; stack, <span class="type">int</span> ans)</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (stack.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> min1(stack, ans);</span><br><span class="line">        ans = Math.min(min, num);</span><br><span class="line">        stack.push(num);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了测试</span></span><br><span class="line">    <span class="comment">// 生成随机栈</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Stack&lt;Integer&gt; <span class="title function_">randomStack</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> v)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            ans.add((<span class="type">int</span>) (Math.random() * v));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了测试</span></span><br><span class="line">    <span class="comment">// 检测栈是不是从顶到底依次有序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="title function_">isSorted</span><span class="params">(Stack&lt;Integer&gt; stack)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">step</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (step &gt; stack.peek()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            step = stack.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为了测试</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; test = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">        test.add(<span class="number">1</span>);</span><br><span class="line">        test.add(<span class="number">5</span>);</span><br><span class="line">        test.add(<span class="number">4</span>);</span><br><span class="line">        test.add(<span class="number">5</span>);</span><br><span class="line">        test.add(<span class="number">3</span>);</span><br><span class="line">        test.add(<span class="number">2</span>);</span><br><span class="line">        test.add(<span class="number">3</span>);</span><br><span class="line">        test.add(<span class="number">1</span>);</span><br><span class="line">        test.add(<span class="number">4</span>);</span><br><span class="line">        test.add(<span class="number">2</span>);</span><br><span class="line">        sort(test);</span><br><span class="line">        <span class="keyword">while</span> (!test.isEmpty()) &#123;</span><br><span class="line">            System.out.println(test.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 随机测试</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">N</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">V</span> <span class="operator">=</span> <span class="number">20</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">testTimes</span> <span class="operator">=</span> <span class="number">20000</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试开始&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; testTimes; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * N);</span><br><span class="line">            Stack&lt;Integer&gt; stack = randomStack(n, V);</span><br><span class="line">            sort(stack);</span><br><span class="line">            <span class="keyword">if</span> (!isSorted(stack)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;出错了!&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">&quot;测试结束&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 常见经典递归 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常见经典递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReverseStackWithRecursive</title>
      <link href="/2024/03/19/ReverseStackWithRecursive/"/>
      <url>/2024/03/19/ReverseStackWithRecursive/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.常见经典递归;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> ReverseStackWithRecursive</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * // 用递归函数逆序栈</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/19 16:43</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReverseStackWithRecursive</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//利用递归的空间，将最后一个元素取出后，递归，再放回</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">reverse</span><span class="params">(Stack&lt;Integer&gt; stack)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (stack.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">last</span> <span class="operator">=</span> bottom(stack);</span><br><span class="line">        reverse(stack);</span><br><span class="line">        stack.push(last);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归取最后一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title function_">bottom</span><span class="params">(Stack&lt;Integer&gt; stack)</span>&#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">num</span> <span class="operator">=</span> stack.pop();</span><br><span class="line">        <span class="keyword">if</span> (stack.empty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//递归取最后一个元素</span></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">last</span> <span class="operator">=</span> bottom(stack);</span><br><span class="line">        stack.push(num);</span><br><span class="line">        <span class="keyword">return</span> last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;Integer&gt;();</span><br><span class="line">        stack.push(<span class="number">1</span>);</span><br><span class="line">        stack.push(<span class="number">2</span>);</span><br><span class="line">        stack.push(<span class="number">3</span>);</span><br><span class="line">        stack.push(<span class="number">4</span>);</span><br><span class="line">        stack.push(<span class="number">5</span>);</span><br><span class="line">        reverse(stack);</span><br><span class="line">        <span class="keyword">while</span> (!stack.isEmpty()) &#123;</span><br><span class="line">            System.out.println(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 常见经典递归 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常见经典递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Permute</title>
      <link href="/2024/03/13/Permute/"/>
      <url>/2024/03/13/Permute/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.常见经典递归;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Permute</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 全排列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/13 15:32</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Permute</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心思想：这题 用原数组去做就有点骚</span></span><br><span class="line">    <span class="comment">//核心点就是定首个位置！，然后递归定下一个索引的首个位置</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">permute</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        f(nums, ans, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(<span class="type">int</span>[] nums, List&lt;List&lt;Integer&gt;&gt; ans, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line">            List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span>( <span class="type">int</span> num : nums )&#123;</span><br><span class="line">                list.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(list);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//从index位置开始，把index位置定下来，然后递归定下一个index+1的位置</span></span><br><span class="line">            <span class="comment">//即当前位置是index、index + 1, index + 2。。。的情况</span></span><br><span class="line">            <span class="comment">//然后递归下一个位置是上述的情况</span></span><br><span class="line">            <span class="comment">//当轮递归只用管当前位置是谁</span></span><br><span class="line">            <span class="comment">//[1,2,3,4....]</span></span><br><span class="line">            <span class="comment">//[1,.....],[2,.....],[3,.....]</span></span><br><span class="line">            <span class="comment">//[1,x,....],[2,x,...],[3,x...](定下一个位置x）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> index; j &lt; nums.length; j++) &#123;</span><br><span class="line">                <span class="comment">//定谁是当前位置：从index位置开始，每一个数都当当前位的情况。</span></span><br><span class="line">                <span class="comment">//即把数组中从index位置开始，都固定到当前位置来</span></span><br><span class="line">                swap(nums, index, j);</span><br><span class="line">                <span class="comment">//递归 固定下一个位置，下一个位置开始的每一个数都当下一位的情况</span></span><br><span class="line">                f(nums, ans, index + <span class="number">1</span>);</span><br><span class="line">                <span class="comment">//恢复原样，让下一个数当当前位</span></span><br><span class="line">                swap(nums, j, index);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i] = nums[i] ^ nums[j];</span><br><span class="line">        nums[j] = nums[i] ^ nums[j];</span><br><span class="line">        nums[i] = nums[i] ^ nums[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] nums = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;;</span><br><span class="line">        <span class="type">Permute</span> <span class="variable">permute</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Permute</span>();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = permute.permute(nums);</span><br><span class="line">        <span class="keyword">for</span> (List&lt;Integer&gt; list : ans) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> num : list) &#123;</span><br><span class="line">                System.out.print(num + <span class="string">&quot; &quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 常见经典递归 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常见经典递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SubsetsIi</title>
      <link href="/2024/03/13/SubsetsIi/"/>
      <url>/2024/03/13/SubsetsIi/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.常见经典递归;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> SubsetsIi</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> * 子集II</span></span><br><span class="line"><span class="comment"> * https://leetcode.cn/problems/subsets-ii/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/13 11:20</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SubsetsIi</span> &#123;</span><br><span class="line">    <span class="comment">//核心思想：这里重点在于剪枝，在对元素取和不取的基础上，跳过相同元素，对下一元素取和不取（剪枝）</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">subsetsWithDup</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        f(ans, list, nums, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(List&lt;List&lt;Integer&gt;&gt; ans, List&lt;Integer&gt; list, <span class="type">int</span>[] nums, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == nums.length) &#123;</span><br><span class="line">            ans.add(copy(list));</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//取当前元素</span></span><br><span class="line">            list.add(nums[index]);</span><br><span class="line">            f(ans, list, nums, index + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//不取当前元素，取下一个不同的元素</span></span><br><span class="line">            list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//如果next是结束边界，则递归会自动收尾</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">next</span> <span class="operator">=</span> nextOne(nums, index);</span><br><span class="line">            f(ans, list, nums, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; <span class="title function_">copy</span><span class="params">(List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Integer i : list)&#123;</span><br><span class="line">            ans.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//注意边界条件的收尾，如果没有下一个不同的元素，即到了nums.length时，也同样返回，证明要收尾了</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">nextOne</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">pre</span> <span class="operator">=</span> nums[index];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> index + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (ans &lt; nums.length &amp;&amp; nums[ans] == pre) &#123;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 常见经典递归 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常见经典递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GeneratePermutation</title>
      <link href="/2024/03/13/GeneratePermutation/"/>
      <url>/2024/03/13/GeneratePermutation/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.常见经典递归;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> GeneratePermutation1</span></span><br><span class="line"><span class="comment"> * 字符串的全部子序列</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> https://www.nowcoder.com/practice/92e6247998294f2c933906fdedbc6e6a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/13 9:46</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GeneratePermutation</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">char</span>[] arr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心思想:对每个字符 取和不取，然后看结果</span></span><br><span class="line">    <span class="comment">//细节：1、用char数组保存，用String.valueOf(char data[], int offset, int count)方法数组转为字符串</span></span><br><span class="line">    <span class="comment">//2、base 当前索引等于数组长度时才退出</span></span><br><span class="line">    <span class="keyword">public</span> String[] generatePermutation (String s) &#123;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">char</span>[s.length()];</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; ans = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        f(s, <span class="number">0</span>, <span class="number">0</span>, ans);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        String[] ansArr = <span class="keyword">new</span> <span class="title class_">String</span>[ans.size()];</span><br><span class="line">        <span class="keyword">for</span> (String an : ans) &#123;</span><br><span class="line">            ansArr[i++] = an;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] a = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">        Collections.singletonList(a);</span><br><span class="line">        <span class="keyword">return</span> ansArr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">f</span><span class="params">(String s, <span class="type">int</span> index, <span class="type">int</span> size, Set&lt;String&gt; set)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index == s.length()) &#123;</span><br><span class="line">            set.add(String.valueOf(arr, <span class="number">0</span>, size));</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//取当前字符,size放入当前字符，index继续下一个字符</span></span><br><span class="line">            arr[size] = s.charAt(index);</span><br><span class="line">            f(s, index + <span class="number">1</span>, size + <span class="number">1</span>, set);</span><br><span class="line">            <span class="comment">//不取当前字符， 直接走下一个字符</span></span><br><span class="line">            f(s, index + <span class="number">1</span>, size, set);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 常见经典递归 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 常见经典递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IsValidBST</title>
      <link href="/2024/03/11/IsValidBST/"/>
      <url>/2024/03/11/IsValidBST/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.二叉树高频题目;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> study.common.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> IsValidBST</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/11 17:37</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IsValidBST</span> &#123;</span><br><span class="line">    <span class="comment">//就是遍历一遍节点来判断。用中序遍历去判断，如果都是升序，则是二叉搜索树</span></span><br><span class="line">    <span class="comment">//中序遍历啊！核心是遍历啊！</span></span><br><span class="line">    <span class="comment">// 所以要用当前节点cur去遍历啊！ stack只是用来存放遍历的节点啊！不是重点啊！</span></span><br><span class="line">    <span class="comment">//遍历cur左树，cur为空时（左树到头了），弹出stack拿上一个遍历的节点啊！ 然后遍历这个节点的右树啊！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isValidBST</span><span class="params">(TreeNode cur)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中序遍历树</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isBst</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty() || cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur != <span class="literal">null</span>) &#123;<span class="comment">//有左节点就放入左节点</span></span><br><span class="line">                stack.push(cur);</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//拿出上一个节点(头节点）</span></span><br><span class="line">                cur = stack.pop();</span><br><span class="line">                <span class="keyword">if</span> (pre != <span class="literal">null</span> &amp;&amp; pre.val &gt;= cur.val) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                pre = cur;</span><br><span class="line">                <span class="comment">//遍历右子树</span></span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isBst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二叉树高频题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树高频题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BalancedBinaryTree</title>
      <link href="/2024/03/11/BalancedBinaryTree/"/>
      <url>/2024/03/11/BalancedBinaryTree/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.二叉树高频题目;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> study.common.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> BalancedBinaryTree</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/11 17:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">// 验证平衡二叉树</span></span><br><span class="line"><span class="comment">// 测试链接 : https://leetcode.cn/problems/balanced-binary-tree/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BalancedBinaryTree</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> isbalanced;</span><br><span class="line">    <span class="comment">//平衡二叉树，每个节点的左右子树高度差小于等于1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        isbalanced = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        getDepth(root);</span><br><span class="line">        <span class="keyword">return</span> isbalanced;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getDepth</span><span class="params">(TreeNode cur)</span>&#123;</span><br><span class="line">        <span class="comment">//总体来说就是写获取树高度的代码</span></span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span> || !isbalanced) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//叶子节点为1</span></span><br><span class="line">        <span class="keyword">if</span> (cur.left == <span class="literal">null</span> &amp;&amp; cur.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">leftD</span> <span class="operator">=</span> getDepth(cur.left);</span><br><span class="line">        <span class="type">int</span> <span class="variable">rightD</span> <span class="operator">=</span> getDepth(cur.right);</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(leftD - rightD) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            isbalanced = <span class="literal">false</span>;</span><br><span class="line">            <span class="comment">// return 0;</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//返回左右节点最大深度 在加1</span></span><br><span class="line">        <span class="keyword">return</span> Math.max(leftD, rightD) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二叉树高频题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树高频题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PathSum</title>
      <link href="/2024/03/11/PathSum/"/>
      <url>/2024/03/11/PathSum/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.二叉树高频题目;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> study.common.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> PathSum</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> *  * 路径总和 II</span></span><br><span class="line"><span class="comment"> *  *  https://leetcode.cn/problems/path-sum-ii/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/11 16:45</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PathSum</span> &#123;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回溯算法，用list记录路基</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> targetSum)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        find(root, targetSum, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//就递归遍历cur，每一次都记录当前节点到reord，递归完就删除节点</span></span><br><span class="line">    <span class="comment">//注意新增和删除节点的位置。</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">find</span><span class="params">(TreeNode cur, <span class="type">int</span> target, List&lt;Integer&gt; record)</span>&#123;</span><br><span class="line">        record.add(cur.val);</span><br><span class="line">        <span class="comment">//如果到了叶子节点，判断是否符合预期</span></span><br><span class="line">        <span class="keyword">if</span> (cur.left == <span class="literal">null</span> &amp;&amp; cur.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target == cur.val)&#123;</span><br><span class="line">                ans.add(copy(record));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//非叶子节点继续往下遍历</span></span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                find(cur.left, target - cur.val, record);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                find(cur.right, target - cur.val, record);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        record.remove(record.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Integer&gt; <span class="title function_">copy</span><span class="params">(List&lt;Integer&gt; list)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(list.size());</span><br><span class="line">        <span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">            ans.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二叉树高频题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树高频题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>lowestCommonAncestor1</title>
      <link href="/2024/03/11/lowestCommonAncestor1/"/>
      <url>/2024/03/11/lowestCommonAncestor1/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.二叉树高频题目;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> study.common.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> lowestCommonAncestor1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> *  二叉搜索树的最近公共祖先</span></span><br><span class="line"><span class="comment"> *  https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-search-tree/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/11 15:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">lowestCommonAncestor1</span> &#123;</span><br><span class="line">    <span class="comment">//因为是二叉搜素树，所以可以利用搜索树的性质（左边小右边大）来减少递归线路</span></span><br><span class="line">    <span class="comment">//核心点：用当前节点cur和p\q对比。</span></span><br><span class="line">    <span class="comment">//1、如果cur小于p\q最小值，则p\q在cur的右侧</span></span><br><span class="line">    <span class="comment">//2、如果cur大于p\q的最大值，则p\q在cur的左侧</span></span><br><span class="line">    <span class="comment">//3、如果cur介于p/q之间，则祖先就是cur</span></span><br><span class="line">    <span class="comment">//base:如果当前节点是p/q,先遇到谁就返回谁，他就是祖先节点</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//递归版</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor1</span><span class="params">(TreeNode cur, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span> || cur == p || cur == q)&#123;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur.val &gt; Math.min(p.val, q.val) &amp;&amp; cur.val &lt; Math.max(p.val, q.val))&#123;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cur.val &lt; Math.min(p.val, q.val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(cur.right, p, q);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> lowestCommonAncestor(cur.left, p, q);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//非递归版</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode cur, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (cur != p &amp;&amp; cur != q &amp;&amp; cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.val &lt; Math.max(p.val, q.val) &amp;&amp; cur.val &gt; Math.min(q.val,p.val))&#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cur.val &gt; Math.max(p.val, q.val))&#123;</span><br><span class="line">                cur = cur.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur = cur.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二叉树高频题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树高频题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LowestCommonAncestor</title>
      <link href="/2024/03/11/LowestCommonAncestor/"/>
      <url>/2024/03/11/LowestCommonAncestor/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.二叉树高频题目;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> study.common.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> LowestCommonAncestor</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 二叉树的最近公共祖先</span></span><br><span class="line"><span class="comment"> * 普通二叉树上寻找两个节点的最近公共祖先</span></span><br><span class="line"><span class="comment"> * 测试链接 : https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/11 15:32</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LowestCommonAncestor</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心点：</span></span><br><span class="line">    <span class="comment">//如果只找到p/q，另外一侧找不到节点，则祖先就是p/q；</span></span><br><span class="line">    <span class="comment">//如果左数找到p/q 且 右树找到p/q，则该节点就是祖先</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode cur, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span> || cur == p || cur == q) &#123;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(cur.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(cur.right, p, q);</span><br><span class="line">        <span class="keyword">if</span> (left != <span class="literal">null</span> &amp;&amp; right != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> left == <span class="literal">null</span> ? right : left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二叉树高频题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树高频题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CountNodes</title>
      <link href="/2024/03/08/CountNodes/"/>
      <url>/2024/03/08/CountNodes/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.二叉树高频题目;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> study.common.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> CountNodes</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span></span></span><br><span class="line"><span class="comment"> *  * 完全二叉树的节点个数</span></span><br><span class="line"><span class="comment"> *  * https://leetcode.cn/problems/count-complete-tree-nodes/description/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/8 17:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CountNodes</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//逻辑判断，如果最右树的深度不等于最大深度，则节点数 = 递归（左字数节点数） + 计算获取(右字数节点数 )+ 本身1</span></span><br><span class="line">    <span class="comment">//否则： 则节点数 = 计算获取（左字数节点数） + 递归获取(右字数节点数 )+ 本身1</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxD</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">countNodes</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        maxD = depth(root);</span><br><span class="line">        <span class="keyword">return</span> count(root, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//index为当前层</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">(TreeNode root, <span class="type">int</span> index)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算深度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">depth</span> <span class="operator">=</span> depth(root.right);</span><br><span class="line">        <span class="keyword">if</span> (depth != maxD - index)&#123; <span class="comment">//如果深度不是最大深度</span></span><br><span class="line">            <span class="keyword">return</span> count(root.left, index + <span class="number">1</span>) + (<span class="number">1</span> &lt;&lt; depth);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">leD</span> <span class="operator">=</span> depth(root.left);</span><br><span class="line">            <span class="keyword">return</span> count(root.right, index + <span class="number">1</span>) + (<span class="number">1</span> &lt;&lt; leD);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">depth</span><span class="params">(TreeNode root)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">null</span>)&#123;</span><br><span class="line">            root = root.left;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二叉树高频题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树高频题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IsCompleteTree</title>
      <link href="/2024/03/08/IsCompleteTree/"/>
      <url>/2024/03/08/IsCompleteTree/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.二叉树高频题目;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> study.common.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> isCompleteTree</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 二叉树的完全性检验</span></span><br><span class="line"><span class="comment"> *  https://leetcode.cn/problems/check-completeness-of-a-binary-tree/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/8 17:33</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IsCompleteTree</span> &#123;</span><br><span class="line">    <span class="comment">//核心思想为：层次遍历，当遇到孩子不全的节点时，剩下的都必须是叶子节点，否则为false</span></span><br><span class="line">    TreeNode[] arr = <span class="keyword">new</span> <span class="title class_">TreeNode</span>[<span class="number">101</span>];</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isCompleteTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        arr[r++] = root;</span><br><span class="line">        <span class="comment">//是否遇到过孩子不全的节点</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">leaf</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> r - l;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> arr[l++];</span><br><span class="line">                <span class="keyword">if</span> (node.left == <span class="literal">null</span> &amp;&amp; node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (leaf)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (node.left != <span class="literal">null</span> || node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">//只要遇到过孩子不全的节点，接下来的每个节点必须是叶子节点</span></span><br><span class="line">                    <span class="keyword">if</span> (node.left == <span class="literal">null</span> || node.right == <span class="literal">null</span>) &#123;</span><br><span class="line">                        leaf = <span class="literal">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    arr[r++] = node.left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    arr[r++] = node.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二叉树高频题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树高频题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BuildTree</title>
      <link href="/2024/03/08/BuildTree/"/>
      <url>/2024/03/08/BuildTree/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.二叉树高频题目;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> study.common.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> BuildTree</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 从前序与中序遍历序列构造二叉树</span></span><br><span class="line"><span class="comment"> * https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/description/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/8 16:28</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BuildTree</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心思想：先序遍历的头节点，将中序遍历分为左右两侧，</span></span><br><span class="line">    <span class="comment">// 且左右两侧节点长度和先序遍历的节点长度对应，从而找到先序遍历的左子树范围和右子树范围。</span></span><br><span class="line">    <span class="comment">//由此，递归遍历左子树和右子树，获取头节点</span></span><br><span class="line">    <span class="comment">//难点在于左右边界的界定。</span></span><br><span class="line">    <span class="comment">// 要注意细节：要记录上次中序数组的左边界，从而通过头节点减去左边界获取左子树长度</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="comment">//为了方便找先序节点在中序中的位置，用map存储中序位置</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++) &#123;</span><br><span class="line">            map.put(inorder[i], i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> findHead(preorder, inorder, <span class="number">0</span> , preorder.length - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//有点坑啊，要记录上一次中序数组中左边界的位置</span></span><br><span class="line">    <span class="comment">//左子树长度计算时，要不包含头节点范围</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">findHead</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> inL)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l &gt; r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[l]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[l]);</span><br><span class="line">        <span class="comment">//头节点所在位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> map.get(preorder[l]);</span><br><span class="line">        <span class="comment">//左子树长度（不包含头节点）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> index - inL;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> l + <span class="number">1</span>;<span class="comment">//左子树范围开始位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span>  l + len;<span class="comment">//左子树范围结束位置</span></span><br><span class="line">        <span class="comment">//找到head对应的左长度</span></span><br><span class="line">        node.left = findHead(preorder, inorder, left, end, inL);<span class="comment">//中序数组的左边界不变</span></span><br><span class="line">        node.right = findHead(preorder, inorder, end + <span class="number">1</span>, r, index + <span class="number">1</span>);<span class="comment">//中序数组的左边界变成头节点位置 + 1</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二叉树高频题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树高频题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SerializeAndDeserializeBinaryTree</title>
      <link href="/2024/03/08/SerializeAndDeserializeBinaryTree/"/>
      <url>/2024/03/08/SerializeAndDeserializeBinaryTree/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.二叉树高频题目;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> study.common.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> SerializeAndDeserializeBinaryTree</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>  二叉树的序列化和反序列化</span></span><br><span class="line"><span class="comment"> * https://leetcode.cn/problems/serialize-and-deserialize-binary-tree/description/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/8 15:10</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 核心思想： 用递归完成</span></span><br><span class="line"><span class="comment"> * 反序列化时注意索引的判断判断判断判读判断判断是不是</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SerializeAndDeserializeBinaryTree</span> &#123;</span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">builder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        toSer(root, builder);</span><br><span class="line">        <span class="keyword">return</span> builder.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toSer</span><span class="params">(TreeNode node, StringBuilder builder)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>)&#123;</span><br><span class="line">            builder.append(<span class="string">&quot;#,&quot;</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            builder.append(node.val + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">            toSer(node.left, builder);</span><br><span class="line">            toSer(node.right, builder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;&quot;</span>.equals(data) || <span class="literal">null</span> == data)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String[] arr = data.split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> toDes(arr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">toDes</span><span class="params">(String[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= arr.length)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> arr[index++];</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">&quot;#&quot;</span>.equals(s))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(s));</span><br><span class="line">        node.left = toDes(arr);</span><br><span class="line">        node.right = toDes(arr);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二叉树高频题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树高频题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MaxDepth</title>
      <link href="/2024/03/08/MaxDepth/"/>
      <url>/2024/03/08/MaxDepth/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.二叉树高频题目;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> MaxDepth</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 二叉树最大深度</span></span><br><span class="line"><span class="comment"> * https://leetcode.cn/problems/maximum-depth-of-binary-tree/description/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/8 13:58</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxDepth</span> &#123;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">         <span class="type">int</span> val;</span><br><span class="line">         TreeNode left;</span><br><span class="line">         TreeNode right;</span><br><span class="line">         TreeNode() &#123;&#125;</span><br><span class="line">         TreeNode(<span class="type">int</span> val) &#123; <span class="built_in">this</span>.val = val; &#125;</span><br><span class="line">         TreeNode(<span class="type">int</span> val, TreeNode left, TreeNode right) &#123;</span><br><span class="line">             <span class="built_in">this</span>.val = val;</span><br><span class="line">             <span class="built_in">this</span>.left = left;</span><br><span class="line">             <span class="built_in">this</span>.right = right;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//简单得很，很容易想到，求递归左节点最大深度和右节点最大深度，取最大值 加上本身深度1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二叉树高频题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树高频题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MaximumWidthOfBinaryTree</title>
      <link href="/2024/03/08/MaximumWidthOfBinaryTree/"/>
      <url>/2024/03/08/MaximumWidthOfBinaryTree/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.二叉树高频题目;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> study.common.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> MaximumWidthOfBinaryTree</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>  * 二叉树最大宽度</span></span><br><span class="line"><span class="comment"> * https://leetcode.cn/problems/maximum-width-of-binary-tree/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/8 13:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaximumWidthOfBinaryTree</span> &#123;</span><br><span class="line"></span><br><span class="line">    TreeNode[] arr = <span class="keyword">new</span> <span class="title class_">TreeNode</span>[<span class="number">3001</span>];</span><br><span class="line">    <span class="comment">//记录对应的节点的索引</span></span><br><span class="line">    <span class="type">int</span>[] ip = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">3001</span>];</span><br><span class="line">    <span class="comment">//层序遍历，把节点所在位置也存起来。定义个max做比较</span></span><br><span class="line">    <span class="comment">//因为遍历是按每一层，所以在每一层遍历时，计算第一个节点和最后一个节点的差</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">widthOfBinaryTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span>  <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        arr[r] = root;</span><br><span class="line">        ip[r++] = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> r - l;</span><br><span class="line">            <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> l, R = r - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> arr[l];</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    arr[r] = node.left;</span><br><span class="line">                    ip[r++] = ip[l] * <span class="number">2</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    arr[r] = node.right;</span><br><span class="line">                    ip[r++] = ip[l] * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                l++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (R &gt; L)&#123;</span><br><span class="line">                ans = Math.max(ans, ip[R] - ip[L] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二叉树高频题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树高频题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ZigzagLevelOrder</title>
      <link href="/2024/03/07/ZigzagLevelOrder/"/>
      <url>/2024/03/07/ZigzagLevelOrder/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.二叉树高频题目;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> study.common.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.LinkedList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> ZigzagLevelOrder</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 二叉树的锯齿形层序遍历</span></span><br><span class="line"><span class="comment"> * https://leetcode.cn/problems/binary-tree-zigzag-level-order-traversal/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/7 17:04</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ZigzagLevelOrder</span> &#123;</span><br><span class="line">    TreeNode[] arr = <span class="keyword">new</span> <span class="title class_">TreeNode</span>[<span class="number">2001</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//leetcode K神做法</span></span><br><span class="line">    <span class="comment">//推荐这个 比较简洁。用双端队列来实现正逆序输出</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        arr[r++] = root;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//代表输出是否正逆序</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">reverse</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> l, R = r - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> r - l;</span><br><span class="line">            LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> arr[l++];</span><br><span class="line">                <span class="keyword">if</span> (reverse)&#123;</span><br><span class="line">                    queue.addLast(node.val);</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    queue.addFirst(node.val);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    arr[r++] = node.left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    arr[r++] = node.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            reverse = !reverse;</span><br><span class="line">            ans.add(queue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这是先正逆序弹出</span></span><br><span class="line">    <span class="comment">//左神</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">zigzagLevelOrder1</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        arr[r++] = root;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">reverse</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">L</span> <span class="operator">=</span> l, R = r - <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> r - l;</span><br><span class="line">            List&lt;Integer&gt; nodeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="comment">//弹出再正逆序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> reverse ? R : L, j = reverse ? -<span class="number">1</span> : <span class="number">1</span>; i &gt;= L &amp;&amp; i &lt;= R; i += j) &#123;</span><br><span class="line">                <span class="comment">//reverse的话 ，从后面往前加</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> arr[i];</span><br><span class="line">                nodeList.add(node.val);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//正常收集，弹出时再正逆序</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> arr[l++];</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) &#123;</span><br><span class="line">                    arr[r++] = node.left;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) &#123;</span><br><span class="line">                    arr[r++] = node.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            reverse = !reverse;</span><br><span class="line">            ans.add(nodeList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二叉树高频题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树高频题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LevelOrder</title>
      <link href="/2024/03/07/LevelOrder/"/>
      <url>/2024/03/07/LevelOrder/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.二叉树高频题目;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> study.common.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> levelOrder</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 102 二叉树的层序遍历</span></span><br><span class="line"><span class="comment"> * https://leetcode.cn/problems/binary-tree-level-order-traversal/description/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/7 16:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LevelOrder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用数组和完成二叉树的层序遍历</span></span><br><span class="line">    <span class="comment">//每次遍历上一轮节点数（用size记录上一论节点数）</span></span><br><span class="line"></span><br><span class="line">    TreeNode[] arr = <span class="keyword">new</span> <span class="title class_">TreeNode</span>[<span class="number">2001</span>];</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数组范围</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//险加入头节点</span></span><br><span class="line">        arr[r++] = root;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//只要有节点</span></span><br><span class="line">        <span class="keyword">while</span> (l &lt; r)&#123;</span><br><span class="line">            List&lt;Integer&gt; nodeList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> r - l;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                <span class="comment">//弹出当前节点</span></span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">treeNode</span> <span class="operator">=</span> arr[l++];</span><br><span class="line">                nodeList.add(treeNode.val);</span><br><span class="line">                <span class="comment">//加入左右节点</span></span><br><span class="line">                <span class="keyword">if</span> (treeNode.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                    arr[r++] = treeNode.left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (treeNode.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                    arr[r++] = treeNode.right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans.add(nodeList);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 二叉树高频题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二叉树高频题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AllOne</title>
      <link href="/2024/03/06/AllOne/"/>
      <url>/2024/03/06/AllOne/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.数据结构设计高频题目;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> AllOne</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 432 全O(1)的数据结构</span></span><br><span class="line"><span class="comment"> * 核心思想：用双向链表维护节点次序</span></span><br><span class="line"><span class="comment"> * 注意新增和删除节点的细节，注意map对应的key也要一同删除</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/6 11:39</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="comment">//最大最小，让我想起来链表。因为要排序，那就涉及链表的调整噢</span></span><br><span class="line">    <span class="comment">//有点点感悟了：涉及最值，排序时，双向链表是一个不错的选择。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AllOne</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//真棒！写完提交，代码一次就过！</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">AllOne</span><span class="params">()</span> &#123;</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.pre = head;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录key对应的链表</span></span><br><span class="line">    HashMap&lt;String, DoubleNode&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="type">DoubleNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleNode</span>(<span class="string">&quot;&quot;</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="type">DoubleNode</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleNode</span>(<span class="string">&quot;&quot;</span>, Integer.MAX_VALUE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DoubleNode</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> String s;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> count;</span><br><span class="line"></span><br><span class="line">        DoubleNode pre;</span><br><span class="line">        DoubleNode next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DoubleNode</span><span class="params">(String s, <span class="type">int</span> count)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.s = s;</span><br><span class="line">            <span class="built_in">this</span>.count = count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向下调整</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">downToNext</span><span class="params">(DoubleNode node)</span>&#123;</span><br><span class="line">        <span class="type">DoubleNode</span> <span class="variable">cur</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != tail &amp;&amp; cur.count &lt; node.count)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur.pre == node) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//链接node前后节点</span></span><br><span class="line">        node.pre.next = node.next;</span><br><span class="line">        node.next.pre = node.pre;</span><br><span class="line">        <span class="comment">//链接node和当前节点的前节点</span></span><br><span class="line">        node.pre = cur.pre;</span><br><span class="line">        cur.pre.next = node;</span><br><span class="line">        <span class="comment">//链接node和当前节点</span></span><br><span class="line">        node.next = cur;</span><br><span class="line">        cur.pre = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向前调整</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">upToPre</span><span class="params">(DoubleNode node)</span>&#123;</span><br><span class="line">        <span class="type">DoubleNode</span> <span class="variable">cur</span> <span class="operator">=</span> node.pre;</span><br><span class="line">        <span class="keyword">while</span> (cur != head &amp;&amp; cur.count &gt; node.count)&#123;</span><br><span class="line">            cur = cur.pre;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (cur.next == node) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//链接node前后节点</span></span><br><span class="line">        node.pre.next = node.next;</span><br><span class="line">        node.next.pre = node.pre;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//链接node和当前节点的后节点</span></span><br><span class="line">        node.next = cur.next;</span><br><span class="line">        cur.next.pre = node;</span><br><span class="line">        <span class="comment">//链接node和当前节点</span></span><br><span class="line">        node.pre = cur;</span><br><span class="line">        cur.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNode</span><span class="params">(DoubleNode node)</span>&#123;</span><br><span class="line">        <span class="comment">//插入链表</span></span><br><span class="line">        node.next = head.next;</span><br><span class="line">        head.next.pre = node;</span><br><span class="line">        node.pre = head;</span><br><span class="line">        head.next = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeNode</span><span class="params">(DoubleNode node)</span>&#123;</span><br><span class="line">        node.pre.next = node.next;</span><br><span class="line">        node.next.pre = node.pre;</span><br><span class="line"></span><br><span class="line">        node.next = <span class="literal">null</span>;</span><br><span class="line">        node.pre = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">inc</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key))&#123;</span><br><span class="line">            <span class="type">DoubleNode</span> <span class="variable">doubleNode</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            doubleNode.count++;</span><br><span class="line">            downToNext(doubleNode);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">DoubleNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleNode</span>(key, <span class="number">1</span>);</span><br><span class="line">            map.put(key, node);</span><br><span class="line">            addNode(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">dec</span><span class="params">(String key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key))&#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">DoubleNode</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">        node.count--;</span><br><span class="line">        <span class="keyword">if</span> (node.count == <span class="number">0</span>)&#123;</span><br><span class="line">            removeNode(node);</span><br><span class="line">            map.remove(key);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            upToPre(node);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMaxKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> tail.pre.s;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getMinKey</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head.next.s;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> <span class="string">&quot;SELECT dap.PRODUCT_ID, dap.NATIONWIDE_UNIFY_PRICE, das.STORE_NO, &quot;</span> +</span><br><span class="line">                <span class="string">&quot; dac.CHANNEL, da.ID, dap.ORIGINAL_PRICE &quot;</span> +</span><br><span class="line">                <span class="string">&quot; FROM distribution_activity da &quot;</span> +</span><br><span class="line">                <span class="comment">//关联的门店、渠道</span></span><br><span class="line">                <span class="string">&quot; JOIN distribution_activity_channel dac on da.id = dac.DISTRIBUTION_ACTIVITY_ID &quot;</span> +</span><br><span class="line">                <span class="string">&quot; JOIN distribution_activity_store das on da.id = das.DISTRIBUTION_ACTIVITY_ID &quot;</span> +</span><br><span class="line">                <span class="comment">//找活动关联的商品</span></span><br><span class="line">                <span class="string">&quot; JOIN distribution_activity_product dap ON da.ID = dap.DISTRIBUTION_ACTIVITY_ID &quot;</span> +</span><br><span class="line">                <span class="string">&quot; JOIN distribution_activity_plate dapl ON dap.PLATE_ID = dapl.ID &quot;</span> +</span><br><span class="line">                <span class="string">&quot; WHERE dap.NATIONWIDE_UNIFY_PRICE is not null &quot;</span> +</span><br><span class="line">                <span class="comment">//未删除且 未结束 或未终止</span></span><br><span class="line">                <span class="string">&quot; and da.DR = 0 and da.STATUS in (1,2) &quot;</span> +</span><br><span class="line">                <span class="comment">//进行中的活动</span></span><br><span class="line">                <span class="string">&quot; and now() BETWEEN da.START_TIME and da.END_TIME &quot;</span> +</span><br><span class="line">                <span class="string">&quot; group by dap.PRODUCT_ID, dap.NATIONWIDE_UNIFY_PRICE, das.STORE_NO, dac.CHANNEL &quot;</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构设计高频题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构设计高频题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FreqStack</title>
      <link href="/2024/03/06/FreqStack/"/>
      <url>/2024/03/06/FreqStack/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.数据结构设计高频题目;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> FreqStack</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 895 最大频率栈</span></span><br><span class="line"><span class="comment"> * 核心思想为：记录元素的频次（map1)，以及频次对应的元素列表(map2)</span></span><br><span class="line"><span class="comment"> * 维护频次和链表即可</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/6 10:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FreqStack</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">maxSize</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//频次记录</span></span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map1 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="comment">//频次对应链表</span></span><br><span class="line">    HashMap&lt;Integer, List&lt;Integer&gt;&gt; map2 = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">FreqStack</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//维护频次</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (map1.containsKey(val))&#123;</span><br><span class="line">            <span class="comment">//更新频次</span></span><br><span class="line">            count = map1.get(val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map1.put(val, ++count);</span><br><span class="line">        <span class="comment">//对应频次列表新增数据</span></span><br><span class="line">        List&lt;Integer&gt; list = map2.getOrDefault(count, <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;());</span><br><span class="line">        list.add(val);</span><br><span class="line">        map2.put(count, list);</span><br><span class="line">        <span class="comment">//更新最大频次</span></span><br><span class="line">        maxSize = Math.max(maxSize, count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从频次记录拿到最高频次的，再到对应链表返回最后一个元素</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//删除频次列表对应元素</span></span><br><span class="line">        List&lt;Integer&gt; list = map2.get(maxSize);</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> list.get(list.size() - <span class="number">1</span>);</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (list.isEmpty())&#123;</span><br><span class="line">            map2.remove(maxSize);</span><br><span class="line">            maxSize--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// map1.get(ans)</span></span><br><span class="line">        <span class="comment">//更新频次</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> map1.get(ans);</span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">1</span>)&#123;</span><br><span class="line">            map1.remove(ans);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            map1.put(ans, count - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构设计高频题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构设计高频题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MedianFinder</title>
      <link href="/2024/03/05/MedianFinder/"/>
      <url>/2024/03/05/MedianFinder/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.数据结构设计高频题目;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> MedianFinder</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 295数据流的中位数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/5 18:02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> PriorityQueue&lt;Integer&gt; maxQ = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((x, y) -&gt; y - x);</span><br><span class="line">    <span class="keyword">public</span> PriorityQueue&lt;Integer&gt; minQ = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((x,y) -&gt; x - y);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接就一个小根堆，一个大根堆。</span></span><br><span class="line">    <span class="comment">//小根堆放较大数，大跟堆放较小数。中位数为两个堆顶取一</span></span><br><span class="line">    <span class="comment">//注意当两堆size差值大于1时，要调整堆元素数量。小根堆多的放大根堆，大根堆多的放小根堆</span></span><br><span class="line">    <span class="comment">//核心点在于：如果num比大根堆顶大，则加入小根堆</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxQ.isEmpty())&#123;</span><br><span class="line">            maxQ.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (num &gt; maxQ.peek())&#123;</span><br><span class="line">            minQ.add(num);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            maxQ.add(num);</span><br><span class="line">        &#125;</span><br><span class="line">        resize();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (((minQ.size() + maxQ.size()) &amp; <span class="number">1</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> (<span class="number">0.0d</span> + maxQ.peek() + minQ.peek()) / <span class="number">2</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> maxQ.size() &gt; minQ.size() ? maxQ.peek() : minQ.peek();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">resize</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">minS</span> <span class="operator">=</span> minQ.size();</span><br><span class="line">        <span class="type">int</span> <span class="variable">maxS</span> <span class="operator">=</span> maxQ.size();</span><br><span class="line">        <span class="keyword">if</span> (Math.abs(maxS - minS) &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (minS &gt; maxS)&#123;</span><br><span class="line">                maxQ.add(minQ.poll());</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                minQ.add(maxQ.poll());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构设计高频题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构设计高频题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RandomizedCollection</title>
      <link href="/2024/03/05/RandomizedCollection/"/>
      <url>/2024/03/05/RandomizedCollection/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.数据结构设计高频题目;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"><span class="keyword">import</span> java.util.Set;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> RandomizedCollection</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 381 O(1)时间插入、、、、允许重复数据</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/5 17:05</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">RandomizedCollection</span> &#123;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Integer&gt; arr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    HashMap&lt;Integer, Set&lt;Integer&gt;&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;Integer, Set&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RandomizedCollection</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(val)) &#123;</span><br><span class="line">            res = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr.add(val);</span><br><span class="line">        Set&lt;Integer&gt; set = map.getOrDefault(val, <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;());</span><br><span class="line">        set.add(arr.size() - <span class="number">1</span>);</span><br><span class="line">        map.put(val, set);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//要维护值的相对位序</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//被删除数字的位置</span></span><br><span class="line">        Set&lt;Integer&gt; set = map.get(val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> set.iterator().next();</span><br><span class="line">        <span class="comment">//数组最后一个数字</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">endValue</span> <span class="operator">=</span> arr.get(arr.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (index == (arr.size() - <span class="number">1</span>)) &#123;<span class="comment">//index == (arr.size() - 1) || val == endValue</span></span><br><span class="line">            <span class="comment">//直接删除该位置，不用补空</span></span><br><span class="line">            <span class="comment">// set.remove(index);</span></span><br><span class="line">            set.remove(arr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//获取数组最后一个数字的位置集合</span></span><br><span class="line">            Set&lt;Integer&gt; endSet = map.get(endValue);</span><br><span class="line">            <span class="comment">//删除最后一个数字的位置，并新增被删数字位置</span></span><br><span class="line">            endSet.remove(arr.size() - <span class="number">1</span>);</span><br><span class="line">            endSet.add(index);</span><br><span class="line">            <span class="comment">//将最后一个数字放到被删位置</span></span><br><span class="line">            arr.set(index, endValue);</span><br><span class="line">            <span class="comment">//删除该位置索引</span></span><br><span class="line">            set.remove(index);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//数组删除最后一个数字</span></span><br><span class="line">        arr.remove(arr.size() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (set.isEmpty()) &#123;</span><br><span class="line">            map.remove(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将数组中最后一个数字，补到呗删除的数字的位置</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> val</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove1</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Set&lt;Integer&gt; set = map.get(val);</span><br><span class="line">        <span class="comment">//移除了这个索引，要用最后的补上，并维护最后数字的索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> set.iterator().next();</span><br><span class="line">        <span class="keyword">if</span> (index == arr.size() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//若是最后一个节点则直接删掉位置索引</span></span><br><span class="line">            set.remove(index);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//最后值</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">endValue</span> <span class="operator">=</span> arr.get(arr.size() - <span class="number">1</span>);</span><br><span class="line">            Set&lt;Integer&gt; s = map.get(endValue);</span><br><span class="line">            <span class="comment">//将最后值的索引的最后位置删除，并设置新的索引位置</span></span><br><span class="line">            s.remove(arr.size() - <span class="number">1</span>);</span><br><span class="line">            s.add(index);</span><br><span class="line">            arr.set(index, endValue);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//删除最后值</span></span><br><span class="line">        arr.remove(arr.size() - <span class="number">1</span>);</span><br><span class="line">        set.remove(index);</span><br><span class="line">        <span class="keyword">if</span> (set.isEmpty()) &#123;</span><br><span class="line">            map.remove(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove0</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set&lt;Integer&gt; valSet = map.get(val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">valAnyIndex</span> <span class="operator">=</span> valSet.iterator().next();</span><br><span class="line">        <span class="type">int</span> <span class="variable">endValue</span> <span class="operator">=</span> arr.get(arr.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (val == endValue) &#123;</span><br><span class="line">            valSet.remove(arr.size() - <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Set&lt;Integer&gt; endValueSet = map.get(endValue);</span><br><span class="line">            endValueSet.add(valAnyIndex);</span><br><span class="line">            arr.set(valAnyIndex, endValue);</span><br><span class="line">            endValueSet.remove(arr.size() - <span class="number">1</span>);</span><br><span class="line">            valSet.remove(valAnyIndex);</span><br><span class="line">        &#125;</span><br><span class="line">        arr.remove(arr.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (valSet.isEmpty()) &#123;</span><br><span class="line">            map.remove(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRandom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> arr.get((<span class="type">int</span>) (Math.random() * arr.size()));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RandomizedCollection</span> <span class="variable">collection</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RandomizedCollection</span>();</span><br><span class="line">        collection.insert(<span class="number">4</span>);</span><br><span class="line">        collection.insert(<span class="number">3</span>);</span><br><span class="line">        collection.insert(<span class="number">4</span>);</span><br><span class="line">        collection.insert(<span class="number">2</span>);</span><br><span class="line">        collection.insert(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        collection.remove(<span class="number">4</span>);</span><br><span class="line">        collection.remove(<span class="number">3</span>);</span><br><span class="line">        collection.remove(<span class="number">4</span>);</span><br><span class="line">        collection.remove(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构设计高频题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构设计高频题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RandomizedSet</title>
      <link href="/2024/03/05/RandomizedSet/"/>
      <url>/2024/03/05/RandomizedSet/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.数据结构设计高频题目;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> RandomizedSet</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 380 设计O(1)时间的插入、删除、获取随机元素。</span></span><br><span class="line"><span class="comment"> * 核心思想是数组和map。用数组储存元素，用map记录每个数的数组索引</span></span><br><span class="line"><span class="comment"> * 注意删除时，要维护map中旧数字的索引</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/5 15:40</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RandomizedSet</span> &#123;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; map;</span><br><span class="line">    ArrayList&lt;Integer&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">RandomizedSet</span><span class="params">()</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insert</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        list.add(val);</span><br><span class="line">        map.put(val, list.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//为了保证map中key对应的value位置相对不变，所以这里要维护value位置</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">valIndex</span> <span class="operator">=</span> map.get(val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">endValue</span> <span class="operator">=</span> list.get(list.size() - <span class="number">1</span>);</span><br><span class="line">        map.put(endValue, valIndex);</span><br><span class="line">        list.set(valIndex, endValue);</span><br><span class="line">        map.remove(val);</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRandom</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * list.size());</span><br><span class="line">        <span class="keyword">return</span> list.get(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">remove1</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(val)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">valIndex</span> <span class="operator">=</span> map.get(val);</span><br><span class="line">        <span class="type">int</span> <span class="variable">endValue</span> <span class="operator">=</span> list.get(list.size() - <span class="number">1</span>);</span><br><span class="line">        map.put(endValue, valIndex);</span><br><span class="line">        list.set(valIndex, endValue);</span><br><span class="line">        map.remove(val);</span><br><span class="line">        list.remove(list.size() - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构设计高频题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构设计高频题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRUCache</title>
      <link href="/2024/03/01/LRUCache/"/>
      <url>/2024/03/01/LRUCache/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.数据结构设计高频题目;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> LRUCache2</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 146 LRU缓存</span></span><br><span class="line"><span class="comment"> * 核心思想：用双向链表记录节点，用上头尾指针简化条件判断。节点存放key和value</span></span><br><span class="line"><span class="comment"> * 用map记录key和节点地址，注意删除节点时，要同步删除map的key</span></span><br><span class="line"><span class="comment"> * 主要涉及的操作就是头尾节点的更新，注意边界条件判断（移除节点、没有节点、新增节点时）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/5 10:30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LRUCache</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">DoubleNode</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> key;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">        DoubleNode pre;</span><br><span class="line">        DoubleNode next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">DoubleNode</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    HashMap&lt;Integer, DoubleNode&gt; map;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//记录头尾节点</span></span><br><span class="line">    <span class="keyword">public</span> DoubleNode head;</span><br><span class="line">    <span class="keyword">public</span> DoubleNode tail;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache</span><span class="params">(<span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(size);</span><br><span class="line">        <span class="built_in">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//每次获取都要更新下节点</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">moveToLast</span><span class="params">(DoubleNode node)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tail == node) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//没有节点时，直接设置</span></span><br><span class="line">        <span class="keyword">if</span> (tail == <span class="literal">null</span>) &#123;</span><br><span class="line">            head = tail = node;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//特殊处理头节点，将该节点断出来</span></span><br><span class="line">        <span class="keyword">if</span> (head == node) &#123;</span><br><span class="line">            head = node.next;</span><br><span class="line">            head.pre = <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//链接前后节点</span></span><br><span class="line">            node.pre.next = node.next;</span><br><span class="line">            node.next.pre = node.pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//链接尾节点</span></span><br><span class="line">        tail.next = node;</span><br><span class="line">        node.pre = tail;</span><br><span class="line">        node.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//设置尾节点</span></span><br><span class="line">        tail = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//满了移除头节点</span></span><br><span class="line">    <span class="comment">//要注意移除map的key</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeHead</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">DoubleNode</span> <span class="variable">res</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">            head = <span class="literal">null</span>;</span><br><span class="line">            tail = <span class="literal">null</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            head = head.next;</span><br><span class="line">            head.pre = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        map.remove(res.key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key))&#123;</span><br><span class="line">            <span class="type">DoubleNode</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            moveToLast(node);</span><br><span class="line">            <span class="keyword">return</span> node.value;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key))&#123;</span><br><span class="line">            <span class="type">DoubleNode</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            node.value = value;</span><br><span class="line">            moveToLast(node);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//满了，先移除头部</span></span><br><span class="line">            <span class="keyword">if</span> (size == map.size()) &#123;</span><br><span class="line">                removeHead();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">DoubleNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DoubleNode</span>(key, value);</span><br><span class="line">            map.put(key, node);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (tail == <span class="literal">null</span>) &#123;</span><br><span class="line">                head = tail = node;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                tail.next = node;</span><br><span class="line">                node.pre = tail;</span><br><span class="line">                tail = node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构设计高频题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构设计高频题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRUCache0</title>
      <link href="/2024/03/01/LRUCache0/"/>
      <url>/2024/03/01/LRUCache0/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.数据结构设计高频题目;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 146 LRU 缓存</span></span><br><span class="line"><span class="comment"> * 核心思想：用链表来记录节点。头节点为最久未使用，尾节点为最近使用。</span></span><br><span class="line"><span class="comment"> * 再用一个map记录每个数据对应的节点地址。完美解决~~</span></span><br><span class="line"><span class="comment"> * 为什么是用链表呢？因为调整位置信息快</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 自己写的因为没有用头尾节点，所以增加了许多边界条件判断，特别麻烦</span></span><br><span class="line"><span class="comment"> * 要用头尾节点去做</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2024-03-01 16:56:36</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache0</span> &#123;</span><br><span class="line">    <span class="comment">//value为list中的位置</span></span><br><span class="line">    HashMap&lt;Integer, Link&gt; map;</span><br><span class="line">    <span class="type">Link</span> <span class="variable">tail</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这里用ArrayList代替链表。完蛋，踩坑了，用数组调整位置完蛋。一定要用链表</span></span><br><span class="line">    <span class="comment">// ArrayList&lt;int[]&gt; list;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Link</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> key;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> value;</span><br><span class="line">        <span class="keyword">public</span> Link pre;</span><br><span class="line">        <span class="keyword">public</span> Link next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Link</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.key = key;</span><br><span class="line">            <span class="built_in">this</span>.value = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">LRUCache0</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">        map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;(capacity);</span><br><span class="line">        size = capacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(Integer key)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Link</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将节点放到最后面</span></span><br><span class="line">        toLast(node);</span><br><span class="line">        <span class="keyword">return</span> node.value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">toLast</span><span class="params">(Link node)</span> &#123;</span><br><span class="line">        <span class="comment">//设置尾节点</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="literal">null</span> || tail == node) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (tail == <span class="literal">null</span>) &#123;</span><br><span class="line">            tail = node;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//断开前后节点</span></span><br><span class="line">        <span class="type">Link</span> <span class="variable">next</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="type">Link</span> <span class="variable">pre</span> <span class="operator">=</span> node.pre;</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">null</span>) &#123;</span><br><span class="line">            pre.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        next.pre = pre;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//链接尾节点</span></span><br><span class="line">        node.pre = tail;</span><br><span class="line">        tail.next = node;</span><br><span class="line">        node.next = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重设尾节点</span></span><br><span class="line">        tail = node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> Link <span class="title function_">findHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (tail == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">Link</span> <span class="variable">cur</span> <span class="operator">=</span> tail;</span><br><span class="line">        <span class="keyword">while</span> (cur.pre != <span class="literal">null</span>) &#123;</span><br><span class="line">            cur = cur.pre;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">removeHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Link</span> <span class="variable">head</span> <span class="operator">=</span> findHead();</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        map.remove(head.key);</span><br><span class="line">        <span class="keyword">if</span> (map.size() == <span class="number">0</span>) &#123;</span><br><span class="line">            tail = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">Link</span> <span class="variable">next</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="keyword">if</span> (next != <span class="literal">null</span>) &#123;</span><br><span class="line">            next.pre = <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        head.next = <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="comment">//更新索引</span></span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(key)) &#123;</span><br><span class="line">            <span class="type">Link</span> <span class="variable">node</span> <span class="operator">=</span> map.get(key);</span><br><span class="line">            node.value = value;</span><br><span class="line">            toLast(node);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//判断数据是否已满</span></span><br><span class="line">            <span class="keyword">if</span> (size == map.size()) &#123;</span><br><span class="line">                removeHead();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//链接节点</span></span><br><span class="line">            <span class="type">Link</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Link</span>(key, value);</span><br><span class="line">            <span class="keyword">if</span> (tail == <span class="literal">null</span>) &#123;</span><br><span class="line">                tail = node;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tail.next = node;</span><br><span class="line">                node.pre = tail;</span><br><span class="line">                tail = node;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//新增数据</span></span><br><span class="line">            map.put(key, node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// LRUCache lruCache = new LRUCache(2);</span></span><br><span class="line">        <span class="comment">// lruCache.put(1,1);</span></span><br><span class="line">        <span class="comment">// lruCache.put(2,2);</span></span><br><span class="line">        <span class="comment">// lruCache.get(1);</span></span><br><span class="line">        <span class="comment">// lruCache.put(3,3);</span></span><br><span class="line">        <span class="comment">// lruCache.get(2);</span></span><br><span class="line">        <span class="comment">// lruCache.put(4,4);</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// lruCache.get(1);</span></span><br><span class="line">        <span class="comment">// lruCache.get(3);</span></span><br><span class="line">        <span class="comment">// lruCache.get(4);</span></span><br><span class="line"></span><br><span class="line">        <span class="type">LRUCache0</span> <span class="variable">lruCache</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">LRUCache0</span>(<span class="number">1</span>);</span><br><span class="line">        lruCache.put(<span class="number">2</span>, <span class="number">1</span>);</span><br><span class="line">        lruCache.get(<span class="number">2</span>);</span><br><span class="line">        lruCache.put(<span class="number">3</span>, <span class="number">2</span>);</span><br><span class="line">        lruCache.get(<span class="number">2</span>);</span><br><span class="line">        lruCache.get(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构设计高频题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构设计高频题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SetAllMap</title>
      <link href="/2024/03/01/SetAllMap/"/>
      <url>/2024/03/01/SetAllMap/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.数据结构设计高频题目;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> SetAllMap</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> https://www.nowcoder.com/practice/7c4559f138e74ceb9ba57d76fd169967</span></span><br><span class="line"><span class="comment"> * 设计含有setAll功能的哈希表</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 核心思想：设置一个版本号来记录操作顺序，操作要和这个版本号关联</span></span><br><span class="line"><span class="comment"> * 设置一个setAllValue的值,初始版本号为1。当设置setAllValue时，版本号+1.</span></span><br><span class="line"><span class="comment"> * 设置元素时，key为元素值，value为value值和版本号。</span></span><br><span class="line"><span class="comment"> * 获取元素时，判断元素版本号是否小于当前版本号，小于则返回setAllValue值</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/3/1 16:06</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SetAllMap</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//牛客网的输入，要写io流读取</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">br</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(br);</span><br><span class="line">        <span class="type">SetAllMap</span> <span class="variable">map</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SetAllMap</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (in.nextToken() != StreamTokenizer.TT_EOF)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> (<span class="type">int</span>)in.nval;</span><br><span class="line">            in.nextToken();</span><br><span class="line">            <span class="type">int</span> <span class="variable">opt</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">key</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">int</span> <span class="variable">value</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (count-- &gt; <span class="number">0</span>)&#123;</span><br><span class="line">                opt = (<span class="type">int</span>) in.nval;</span><br><span class="line">                <span class="keyword">if</span> (opt == <span class="number">1</span>)&#123;</span><br><span class="line">                    in.nextToken();</span><br><span class="line">                    key = (<span class="type">int</span>) in.nval;</span><br><span class="line">                    in.nextToken();</span><br><span class="line">                    value = (<span class="type">int</span>) in.nval;</span><br><span class="line">                    map.put(key, value);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">2</span>) &#123;</span><br><span class="line">                    in.nextToken();</span><br><span class="line">                    key = (<span class="type">int</span>) in.nval;</span><br><span class="line">                    out.println(map.get(key));</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (opt == <span class="number">3</span>) &#123;</span><br><span class="line">                    in.nextToken();</span><br><span class="line">                    value = (<span class="type">int</span>) in.nval;</span><br><span class="line">                    map.setAll(value);</span><br><span class="line">                &#125;</span><br><span class="line">                in.nextToken();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.flush();</span><br><span class="line">        out.close();</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> setAllValue;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> ver;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> HashMap&lt;Integer, <span class="type">int</span>[]&gt; myMap = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (myMap.containsKey(key))&#123;</span><br><span class="line">            <span class="type">int</span>[] ints = myMap.get(key);</span><br><span class="line">            ints[<span class="number">0</span>] = value;</span><br><span class="line">            ints[<span class="number">1</span>] = ver;</span><br><span class="line">         &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            myMap.put(key, <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;value, ver&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">get</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] ints = myMap.get(key);</span><br><span class="line">        <span class="keyword">if</span> (ints == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ints[<span class="number">1</span>] &lt; ver ? setAllValue : ints[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">containsKey</span><span class="params">(<span class="type">int</span> key)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> myMap.containsKey(key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setAll</span><span class="params">(<span class="type">int</span> value)</span>&#123;</span><br><span class="line">        setAllValue = value;</span><br><span class="line">        ver++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 数据结构设计高频题目 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构设计高频题目 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SortList</title>
      <link href="/2024/02/29/SortList/"/>
      <url>/2024/02/29/SortList/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.链表;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> study.common.ListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> SortList</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 148排序链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/29 17:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SortList</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自己参考别人思想写的。链表很多细节要处理，特别要注意头节点和当前遍历节点的处理。</span></span><br><span class="line">    <span class="comment">// 以及要注意传参是当前节点的下一节点时，要用变量将传参节点保存下来，因为节点顺序会变。</span></span><br><span class="line">    <span class="comment">//核心思想：每次递归返回头节点</span></span><br><span class="line">    <span class="comment">//为什么是返回头节点而不是尾节点呢？因为每次递归后，原头节点都会变化，所以要返回新的头节点再次merge</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sortList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//快慢指针找中节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> findMid(head);</span><br><span class="line">        <span class="comment">//断开第一条链尾</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head2</span> <span class="operator">=</span> mid.next;</span><br><span class="line">        mid.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">res</span> <span class="operator">=</span> sort(head, head2);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">sort</span><span class="params">(ListNode node1, ListNode node2)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node1 == node2 || node1 == <span class="literal">null</span> || node2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> node1;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">mid</span> <span class="operator">=</span> findMid(node1);</span><br><span class="line">        <span class="comment">//第二条链头</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">h2</span> <span class="operator">=</span> mid.next;</span><br><span class="line">        <span class="comment">//断开第一条链末尾</span></span><br><span class="line">        mid.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//排序第一条链</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head1</span> <span class="operator">=</span> sort(node1, h2);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        mid = findMid(node2);</span><br><span class="line">        <span class="comment">//第二条链头</span></span><br><span class="line">        h2 = mid.next;</span><br><span class="line">        <span class="comment">//断开第一条链末尾</span></span><br><span class="line">        mid.next = <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//排序第二条链</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head2</span> <span class="operator">=</span> sort(node2, h2);</span><br><span class="line">        <span class="comment">//根据两个头节点合并两条链</span></span><br><span class="line">        <span class="keyword">return</span> merge(head1, head2);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ListNode <span class="title function_">findMid</span><span class="params">(ListNode node)</span>&#123;</span><br><span class="line">        <span class="comment">//快慢指针找中节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> node;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> slow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用归并吧</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">merge</span><span class="params">(ListNode head1, ListNode head2)</span>&#123;</span><br><span class="line">        <span class="comment">//辅助头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">H</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> H;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">h1</span> <span class="operator">=</span> head1;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">h2</span> <span class="operator">=</span> head2;</span><br><span class="line">        <span class="keyword">while</span> (h1 != <span class="literal">null</span> &amp;&amp; h2 != <span class="literal">null</span> )&#123;</span><br><span class="line">            <span class="keyword">if</span> (h1.val &gt; h2.val)&#123;</span><br><span class="line">                cur.next = h2;</span><br><span class="line">                h2 = h2.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = h1;</span><br><span class="line">                h1 = h1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (h1 != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur.next = h1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (h2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            cur.next = h2;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> H.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">SortList</span> <span class="variable">sortList</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SortList</span>();</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">        node4.next = node2;</span><br><span class="line">        node2.next = node;</span><br><span class="line">        node.next = node3;</span><br><span class="line">        sortList.sortList(node4);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>detectCycle</title>
      <link href="/2024/02/29/detectCycle/"/>
      <url>/2024/02/29/detectCycle/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.链表;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> study.common.ListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> detectCycle</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 142环形链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/29 15:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">detectCycle</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//简易版，用容器记录每个节点,如果有环，容器内肯定包含该节点，直接返回该节点</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle0</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        HashSet&lt;ListNode&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(cur))&#123;</span><br><span class="line">                <span class="keyword">return</span> cur;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                set.add(cur);</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//空间复杂度O(1) 版本</span></span><br><span class="line">    <span class="comment">//核心思想，用快慢指针 获取入环节点</span></span><br><span class="line">    <span class="comment">//快指针走两步，慢指针走一步，若有环，当他们相遇时，相遇节点再环内。</span></span><br><span class="line">    <span class="comment">// 此时快指针从头开始，每次走一步。慢指针在相遇节点继续每次走一步。当再次相遇时就是入环节点。</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">detectCycle</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="comment">//成环至少要3个节点</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span> || head.next.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//让他们提前走一步，以避免slow == fast的情况</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (slow != fast)&#123;</span><br><span class="line">            <span class="comment">//判断有没有环</span></span><br><span class="line">            <span class="keyword">if</span> (fast.next == <span class="literal">null</span> || fast.next.next == <span class="literal">null</span>)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != slow)&#123;</span><br><span class="line">            fast = fast.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IsPalindrome</title>
      <link href="/2024/02/29/IsPalindrome/"/>
      <url>/2024/02/29/IsPalindrome/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.链表;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> study.common.ListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> SsPalindrome</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 234回文链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/29 14:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">IsPalindrome</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//简单版 用容器</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome0</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//直接用栈存储节点，出栈时一一对比原链表</span></span><br><span class="line"></span><br><span class="line">        Stack&lt;ListNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;ListNode&gt;();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            stack.push(cur);</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cur = head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur.val != stack.pop().val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空间复杂度O(1) 版本</span></span><br><span class="line">    <span class="comment">//核心思想： 在链表中间截断，将中间后面的链表翻转，再和原头节点一一对比</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome1</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取链表长度</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//快慢指针找中点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中点位置</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> slow.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">headN</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//翻转链表</span></span><br><span class="line">        <span class="keyword">while</span> (tail != <span class="literal">null</span>)&#123;</span><br><span class="line">            next = tail.next;</span><br><span class="line">            tail.next = pre;</span><br><span class="line">            pre = tail;</span><br><span class="line">            tail = next;</span><br><span class="line">        &#125;</span><br><span class="line">        headN = pre;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对比每个节点val</span></span><br><span class="line">        <span class="keyword">while</span> (headN != <span class="literal">null</span> &amp;&amp; head != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (headN.val != head.val)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            headN = headN.next;</span><br><span class="line">            head =  head.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空间复杂度O(1) 版本 并还原原链表</span></span><br><span class="line">    <span class="comment">//核心思想： 在链表中间截断，将中间后面的链表翻转，再和原头节点一一对比</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPalindrome</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取链表长度</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//快慢指针找中点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (fast.next != <span class="literal">null</span> &amp;&amp; fast.next.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中点位置</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">tail</span> <span class="operator">=</span> slow.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">headN</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//翻转链表</span></span><br><span class="line">        <span class="keyword">while</span> (tail != <span class="literal">null</span>)&#123;</span><br><span class="line">            next = tail.next;</span><br><span class="line">            tail.next = pre;</span><br><span class="line">            pre = tail;</span><br><span class="line">            tail = next;</span><br><span class="line">        &#125;</span><br><span class="line">        headN = pre;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">curNew</span> <span class="operator">=</span> headN;</span><br><span class="line">        cur = head;</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//对比每个节点val</span></span><br><span class="line">        <span class="keyword">while</span> (curNew != <span class="literal">null</span> &amp;&amp; cur != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (curNew.val != cur.val)&#123;</span><br><span class="line">                ans = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            curNew = curNew.next;</span><br><span class="line">            cur =  cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//还原链表</span></span><br><span class="line">        curNew = headN;</span><br><span class="line">        pre = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (curNew != <span class="literal">null</span>)&#123;</span><br><span class="line">            next = curNew.next;</span><br><span class="line">            curNew.next = pre;</span><br><span class="line">            pre = curNew;</span><br><span class="line">            curNew = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">node4</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">4</span>);</span><br><span class="line">        node.next = node2;</span><br><span class="line">        node2.next = node3;</span><br><span class="line">        node3.next = node4;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CopyRandomList</title>
      <link href="/2024/02/29/CopyRandomList/"/>
      <url>/2024/02/29/CopyRandomList/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.链表;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashMap;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> CopyRandomList0</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 138随机链表的复制</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/29 11:40</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CopyRandomList</span> &#123;</span><br><span class="line">    <span class="comment">// 不要提交这个类</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">        <span class="keyword">public</span> Node next;</span><br><span class="line">        <span class="keyword">public</span> Node random;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span><span class="params">(<span class="type">int</span> v)</span> &#123;</span><br><span class="line">            val = v;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//简单版本，用容器</span></span><br><span class="line">    <span class="comment">//核心思想就是用map记录旧节点 -&gt; 新节点。 这样找random节点的时候，直接用map就可找到对应的新节点</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList0</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//用容器 构建 旧节点 -&gt; 新节点</span></span><br><span class="line">        HashMap&lt;Node, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//遍历一遍，记录上一个节点即可</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">headN</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">newN</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(node.val);</span><br><span class="line">            <span class="keyword">if</span> (pre != <span class="literal">null</span>)&#123;</span><br><span class="line">                pre.next = newN;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//记录新头节点</span></span><br><span class="line">                headN = newN;</span><br><span class="line">            &#125;</span><br><span class="line">            pre = newN;</span><br><span class="line">            <span class="comment">//同时记录旧节点和新节点的关系</span></span><br><span class="line">            map.put(node, newN);</span><br><span class="line">            node = node.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//连接random节点</span></span><br><span class="line">        node = head;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">nodeN</span> <span class="operator">=</span> headN;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (node.random != <span class="literal">null</span>)&#123;</span><br><span class="line">                nodeN.random = map.get(node.random);</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next;</span><br><span class="line">            nodeN = nodeN.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headN;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//空间复杂度O(1)版本</span></span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//核心思想是将原节点 1 》 2 》 3 储存新节点  1 》1‘ 》2 》 2’ 》3 》 3‘</span></span><br><span class="line">        <span class="comment">//即是原节点的next节点是新节点，next.next才是下一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Node</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//构建新节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">Node</span> <span class="variable">nodeNew</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Node</span>(node.val);</span><br><span class="line">            next = node.next;</span><br><span class="line">            node.next = nodeNew;</span><br><span class="line">            nodeNew.next = next;</span><br><span class="line">            <span class="comment">//跳下一个旧节点</span></span><br><span class="line">            node = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//连接random节点</span></span><br><span class="line">        node = head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span> &amp;&amp; node.next !=<span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//连接random节点</span></span><br><span class="line">            <span class="keyword">if</span> (node.random != <span class="literal">null</span>)&#123;</span><br><span class="line">                node.next.random = node.random.next;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node.next.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//再连接新节点</span></span><br><span class="line">        node = head;</span><br><span class="line">        <span class="type">Node</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="comment">//记录新节点的头节点</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">headN</span> <span class="operator">=</span> node.next;</span><br><span class="line">        <span class="comment">//前置链接  这个是自己写的 也能通过提交</span></span><br><span class="line">        <span class="comment">// while (node != null &amp;&amp; node.next != null)&#123;</span></span><br><span class="line">        <span class="comment">// //连接上一个新节点和当前新节点</span></span><br><span class="line">        <span class="comment">// if (pre != null)&#123;</span></span><br><span class="line">        <span class="comment">// pre.next = node.next;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// //当前新节点赋值为上一个新节点</span></span><br><span class="line">        <span class="comment">// pre = node.next;</span></span><br><span class="line">        <span class="comment">// //连接旧节点</span></span><br><span class="line">        <span class="comment">// node.next = node.next.next;</span></span><br><span class="line">        <span class="comment">// //遍历下一个节点</span></span><br><span class="line">        <span class="comment">// node = node.next;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//顺序连接</span></span><br><span class="line">        <span class="type">Node</span> <span class="variable">copy</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>)&#123;</span><br><span class="line">            next = node.next.next;</span><br><span class="line">            copy = node.next;</span><br><span class="line">            node.next = next;</span><br><span class="line">            copy.next = next == <span class="literal">null</span> ? <span class="literal">null</span> : next.next;</span><br><span class="line">            node = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> headN;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReverseKGroup</title>
      <link href="/2024/02/28/ReverseKGroup/"/>
      <url>/2024/02/28/ReverseKGroup/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.链表;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> study.common.ListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> ReverseKGroup</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 25 翻转列表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/28 16:41</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReverseKGroup</span> &#123;</span><br><span class="line">    <span class="comment">//自己的想法写的</span></span><br><span class="line">    <span class="comment">//纯code。涉及链表的翻转，其他的就是代码逻辑了</span></span><br><span class="line">    <span class="comment">//代码逻辑主要涉及，找到当前轮的尾节点，注意尾节点和下一轮头节点链接就是了。细节多</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseKGroup</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> reverse(head, k);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverse</span><span class="params">(ListNode head, <span class="type">int</span> k)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是否能反转</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">headN</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//找当前轮尾节点</span></span><br><span class="line">        <span class="keyword">while</span> (headN.next != <span class="literal">null</span> &amp;&amp; len &lt; k)&#123;</span><br><span class="line">            headN = headN.next;</span><br><span class="line">            len++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//尾节点的下一个节点，用于后续翻转链表的结束判断</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">end</span> <span class="operator">=</span> headN.next;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不能反转 直接返回头节点</span></span><br><span class="line">        <span class="keyword">if</span> (len &lt; k)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//翻转链表</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (cur != end)&#123;</span><br><span class="line">            next = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//连接尾部和下一个头部</span></span><br><span class="line">        head.next = reverse(end, k);</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">head2</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">head3</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">head4</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">4</span>);</span><br><span class="line">       <span class="type">ListNode</span> <span class="variable">head5</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">5</span>);</span><br><span class="line">       head.next = head2;</span><br><span class="line">       head2.next = head3;</span><br><span class="line">       head3.next = head4;</span><br><span class="line">       head4.next = head5;</span><br><span class="line">       <span class="keyword">new</span> <span class="title class_">ReverseKGroup</span>().reverse(head, <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GetIntersectionNode</title>
      <link href="/2024/02/28/GetIntersectionNode/"/>
      <url>/2024/02/28/GetIntersectionNode/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.链表;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> study.common.ListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.HashSet;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> GetIntersectionNode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 160 相交链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/28 15:32</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetIntersectionNode</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//简易版本，用容器</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode1</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line"></span><br><span class="line">        HashSet&lt;ListNode&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (headA != <span class="literal">null</span>)&#123;</span><br><span class="line">            set.add(headA);</span><br><span class="line">            headA = headA.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (headB != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (set.contains(headB))&#123;</span><br><span class="line">                <span class="keyword">return</span> headB;</span><br><span class="line">            &#125;</span><br><span class="line">            headB = headB.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不使用额外空间</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//核心思想:比较两节点的长度，让较长的节点先走，直到两节点同长，遍历对比两节点是否相同</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">A</span> <span class="operator">=</span> headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">B</span> <span class="operator">=</span> headB;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">diff</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (A != <span class="literal">null</span>)&#123;</span><br><span class="line">            A = A.next;</span><br><span class="line">            diff++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (B != <span class="literal">null</span>)&#123;</span><br><span class="line">            B = B.next;</span><br><span class="line">            diff--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">startH</span> <span class="operator">=</span> diff &lt; <span class="number">0</span> ? headB : headA;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">startS</span> <span class="operator">=</span> startH == headA ? headB : headA;</span><br><span class="line">        diff = diff &lt; <span class="number">0</span> ? -diff : diff;</span><br><span class="line">        <span class="keyword">while</span> (diff &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            startH = startH.next;</span><br><span class="line">            diff--;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (startH != <span class="literal">null</span> &amp;&amp; startS != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (startH == startS)&#123;</span><br><span class="line">                <span class="keyword">return</span> startH;</span><br><span class="line">            &#125;</span><br><span class="line">            startH = startH.next;</span><br><span class="line">            startS = startS.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 链表 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Divide</title>
      <link href="/2024/02/28/Divide/"/>
      <url>/2024/02/28/Divide/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.位运算;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Divide</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/28 9:54</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Divide</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//leetcode 答案 递归版</span></span><br><span class="line">    <span class="comment">//核心思想是 利用减法。被除数减去倍增的除数，直至被除数小于除数，此时得到第一个商。</span></span><br><span class="line">    <span class="comment">// 将剩下被除数继续面操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">divide</span><span class="params">(<span class="type">int</span> dividend, <span class="type">int</span> divisor)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (dividend == Integer.MIN_VALUE &amp;&amp; divisor == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dividend == Integer.MIN_VALUE &amp;&amp; divisor == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> Integer.MIN_VALUE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dividend &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -divide(-dividend, divisor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (divisor &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -divide(dividend, -divisor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (dividend &gt; divisor) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>, tmp = divisor;</span><br><span class="line">        <span class="keyword">while</span> ((dividend - divisor) &lt;= divisor) &#123;</span><br><span class="line">            res += res;</span><br><span class="line">            divisor += divisor;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res + divide(dividend - divisor, tmp);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下是只用位运算实现加减乘除版本</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> Integer.MIN_VALUE;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">divide0</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line">        <span class="comment">//要特殊处理最小数</span></span><br><span class="line">        <span class="comment">//都是最小数直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (x == min &amp;&amp; y == min)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (y == min) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (x == min)&#123;</span><br><span class="line">                <span class="comment">//返回最大</span></span><br><span class="line">                <span class="keyword">if</span>(y == neg(<span class="number">1</span>))&#123;</span><br><span class="line">                    <span class="keyword">return</span> Integer.MAX_VALUE;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//因为方法里要转成非负数，所以这里要处理下a的数值</span></span><br><span class="line">                x = plus(x, y &gt; <span class="number">0</span> ? y : neg(y));</span><br><span class="line">                <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> div(x, y);</span><br><span class="line">                <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> y &gt; <span class="number">0</span> ? neg(<span class="number">1</span>) : <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">return</span> plus(ans, offset);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> div(x, y);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//除法可标识为</span></span><br><span class="line">    <span class="comment">// a = b * 2^30 +  b * 2^29 + ..... b * 2^2 + b* 2^1 + b * 2^0</span></span><br><span class="line">    <span class="comment">//即 a / b后的结果为 二进制上的2的相应位数</span></span><br><span class="line">    <span class="comment">//保证不为最小数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="comment">//用非负数来表示</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> a &lt; <span class="number">0</span> ? neg(a) : a;</span><br><span class="line">        <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> b &lt; <span class="number">0</span> ? neg(b) : b;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//所以遍历每位二进制位上，x是否大于y</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">30</span>; i &gt;=<span class="number">0</span> ; i = sub(i, <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">//判断x在哪一个二进制位上还大于y，该位置赋值1</span></span><br><span class="line">            <span class="keyword">if</span> ((x &gt;&gt;&gt; i) &gt;= y)&#123;</span><br><span class="line">                <span class="comment">//减去y</span></span><br><span class="line">                x = sub(x , y &lt;&lt; i);</span><br><span class="line">                <span class="comment">//或上结果的1</span></span><br><span class="line">                ans |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a &lt; <span class="number">0</span> ^ b &lt; <span class="number">0</span> ? neg(ans) : ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相加</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">plus</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="comment">//相加就是 无进位相加（ ^) 加上 进位（两数相与 再左移）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> x ^ y;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> (x &amp; y) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//只要有进位</span></span><br><span class="line">        <span class="keyword">while</span> (b != <span class="number">0</span>)&#123;</span><br><span class="line">            c = a ^ b;</span><br><span class="line">            b = (a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            a = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a | b;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相减</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="comment">//相减就是 加上相反数</span></span><br><span class="line">        <span class="keyword">return</span> plus(x, neg(y));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//相乘</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">multi</span><span class="params">(<span class="type">int</span> x,<span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="comment">//相乘就是遍历每个y的1，将x加上 x向左移动 y的1偏移量(b向右移动 同时a向左移动即可解决）</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (y != <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> ((y &amp; <span class="number">1</span>) != <span class="number">0</span>)&#123;</span><br><span class="line">                res = plus(res, x);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//同时进退位</span></span><br><span class="line">            x &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">            y &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取反</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">neg</span><span class="params">(<span class="type">int</span> x)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> plus(~x, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HammingDistance</title>
      <link href="/2024/02/27/HammingDistance/"/>
      <url>/2024/02/27/HammingDistance/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.位运算;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> HammingDistance</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 461 汉明距离，求一个数的二进制有几个1</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/27 15:22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HammingDistance</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//就是求两数异或后右多少个1</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingDistance1</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//简单版本 循环每次减去最右边的1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> x ^ y;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (num != <span class="number">0</span>)&#123;</span><br><span class="line">            num -= num &amp; -num;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//大神超自然版本</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingDistance</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> x ^ y;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//核心思想：以步长1，步长2，步长4，步长8，步长16，依次记录每轮步长的所有1值。</span></span><br><span class="line">        <span class="comment">//当前步长的二进制值 等于 上一轮步长所有1的值。 累加所有步长的1的值，直到变为32位的int 二进制值</span></span><br><span class="line">        <span class="comment">//先把右边的1 保存下来，再将左边的1也保存下来，然后把所有1加起来。得到步长为1的所有1相加的结果（即当前步长下，所有1相加的数量）</span></span><br><span class="line">        n = (n &amp; <span class="number">0x55555555</span>) + ((n &gt;&gt;&gt; <span class="number">1</span>) &amp; <span class="number">0x55555555</span>);</span><br><span class="line">        n = (n &amp; <span class="number">0x33333333</span>) + ((n &gt;&gt;&gt; <span class="number">2</span>) &amp; <span class="number">0x33333333</span>);</span><br><span class="line">        n = (n &amp; <span class="number">0x0f0f0f0f</span>) + ((n &gt;&gt;&gt; <span class="number">4</span>) &amp; <span class="number">0x0f0f0f0f</span>);</span><br><span class="line">        n = (n &amp; <span class="number">0x00ff00ff</span>) + ((n &gt;&gt;&gt; <span class="number">8</span>) &amp; <span class="number">0x00ff00ff</span>);</span><br><span class="line">        n = (n &amp; <span class="number">0x0000ffff</span>) + ((n &gt;&gt;&gt; <span class="number">16</span>) &amp; <span class="number">0x0000ffff</span>);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReverseBits</title>
      <link href="/2024/02/27/ReverseBits/"/>
      <url>/2024/02/27/ReverseBits/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.位运算;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> ReverseBits</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 190 颠倒二进制位</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/27 15:05</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReverseBits</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reverseBits</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//核心思想：</span></span><br><span class="line">        <span class="comment">//按步骤：</span></span><br><span class="line">        <span class="comment">// 先按步长为1 互换位置。 再按步长为2互换位置 再按步长为4，步长为8，一直到步长为16.</span></span><br><span class="line">        <span class="comment">// 即可颠倒一个二进制位</span></span><br><span class="line">        n = ((n &amp; <span class="number">0x55555555</span>) &lt;&lt; <span class="number">1</span>) | ((n &amp; <span class="number">0xaaaaaaaa</span>) &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">        n = ((n &amp; <span class="number">0x33333333</span>) &lt;&lt; <span class="number">2</span>) | ((n &amp; <span class="number">0xcccccccc</span>) &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">        n = ((n &amp; <span class="number">0x0f0f0f0f</span>) &lt;&lt; <span class="number">4</span>) | ((n &amp; <span class="number">0xf0f0f0f0</span>) &gt;&gt;&gt; <span class="number">4</span>);</span><br><span class="line">        n = ((n &amp; <span class="number">0x00ff00ff</span>) &lt;&lt; <span class="number">8</span>) | ((n &amp; <span class="number">0xff00ff00</span>) &gt;&gt;&gt; <span class="number">8</span>);</span><br><span class="line">        n = (n &gt;&gt;&gt; <span class="number">16</span>) | (n &lt;&lt; <span class="number">16</span>);</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RangeBitwiseAnd</title>
      <link href="/2024/02/27/RangeBitwiseAnd/"/>
      <url>/2024/02/27/RangeBitwiseAnd/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.位运算;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> RangeBitwiseAnd</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 201 数字范围按位与</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/27 14:38</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RangeBitwiseAnd</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">rangeBitwiseAnd</span><span class="params">(<span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//因为是顺序的，所以只和right中1的个数有关</span></span><br><span class="line">        <span class="comment">//顺序的&amp; 相当于每次都减去right最右边的1</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)&#123;</span><br><span class="line">            right -= (right &amp; -right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RangeBitwiseAnd</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RangeBitwiseAnd</span>();</span><br><span class="line">        r.rangeBitwiseAnd(<span class="number">5</span>,<span class="number">7</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BigNumOfTwo</title>
      <link href="/2024/02/27/BigNumOfTwo/"/>
      <url>/2024/02/27/BigNumOfTwo/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.位运算;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> BigNumOfTwo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 给出一个数，返回大于等于这个数的最小2的次幂 和 小于等于这个数的最大2的次幂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/27 14:11</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BigNumOfTwo</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//核心思想就是将最左边的1，依次位移到右边所有位置上，</span></span><br><span class="line">    <span class="comment">// 得到的数+1 就是大于等于此数的2次幂 a. 将a右移就是小于等于次数的2次幂</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] find(<span class="type">int</span> n)&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理边界条件</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;<span class="number">0</span>,<span class="number">0</span>&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理n本身就是2次冥的情况</span></span><br><span class="line">        <span class="keyword">if</span> ((n ^ (n &amp; -n)) == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;n,n&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里 n - 1 也是为了兼容n本身是2次幂的情况，虽然前面处理了这个情况</span></span><br><span class="line">        n--;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;res, res &gt;&gt;&gt; <span class="number">1</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PowerOfThree</title>
      <link href="/2024/02/27/PowerOfThree/"/>
      <url>/2024/02/27/PowerOfThree/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.位运算;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> PowerOfThree</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 326    ---  3的幂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/27 11:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PowerOfThree</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPowerOfThree</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//先处理边界条件</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//int范围内，3次幂最大值 3^19，再对n求余，看是否等于0</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1162261467</span> % n) == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PowerOfTwo</title>
      <link href="/2024/02/27/PowerOfTwo/"/>
      <url>/2024/02/27/PowerOfTwo/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.位运算;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> PowerOfTwo</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 231 --- 2的幂</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/27 11:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PowerOfTwo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isPowerOfTwo</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//最小2的0次幂是1，所以小于等于0的整数都是false</span></span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//判断是不是只有一个1</span></span><br><span class="line">        <span class="comment">//取 n 异或 最右边的1</span></span><br><span class="line">        <span class="keyword">return</span>  (n ^ (n &amp; -n)) == <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//还能这样，比较简单和方便理解</span></span><br><span class="line">        <span class="comment">// return (n &amp; (n - 1)) == 0;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SingleNumber</title>
      <link href="/2024/02/27/SingleNumber/"/>
      <url>/2024/02/27/SingleNumber/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.位运算;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> SingleNumber</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 137 只出现一次的数字</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/27 11:04</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SingleNumber</span> &#123;</span><br><span class="line">    <span class="comment">//直接就用32位数组统计每位出现的次数，再对m求余数，剩下的就是出现的数的二进制</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findNum</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="type">int</span>[] cnts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">                cnts[i] += (num &gt;&gt;&gt; i) &amp; <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">31</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            cnts[i] = cnts[i] % m;</span><br><span class="line">            <span class="keyword">if</span> (cnts[i] != <span class="number">0</span>)&#123;</span><br><span class="line">                res |= (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 位运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 位运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GetMax</title>
      <link href="/2024/02/26/GetMax/"/>
      <url>/2024/02/26/GetMax/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.异或运算;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> GetMax</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>  leetcode16.07最大数值</span></span><br><span class="line"><span class="comment"> * 不用判断语句和符号，返回两数最大值</span></span><br><span class="line"><span class="comment"> * 核心思想就是负数返回0，非负数返回1（即只返回非负数那个，负数的变为0）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/26 18:08</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">GetMax</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当题目没规定系统范围时，可用long类型避免溢出问题</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMax</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="comment">//1代表a &gt; b</span></span><br><span class="line">        <span class="type">long</span> <span class="variable">c</span> <span class="operator">=</span> (<span class="type">long</span>) a - (<span class="type">long</span>)b;</span><br><span class="line">        <span class="type">int</span> <span class="variable">returnA</span> <span class="operator">=</span> sign(c);</span><br><span class="line">        <span class="comment">// int flag = (int)(c &gt;&gt;&gt; 63) ^ 1;</span></span><br><span class="line">        <span class="comment">//取反</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">returnB</span> <span class="operator">=</span> returnA ^ <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> a * returnA + b * returnB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当题目限定只能用32位</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getMax2</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span>&#123;</span><br><span class="line">        <span class="comment">//核心思想是</span></span><br><span class="line">        <span class="comment">// A负数返回0，非负数返回原本</span></span><br><span class="line">        <span class="comment">//1.判断a,b是否相同符号，如果不同符号直接参考A</span></span><br><span class="line">        <span class="comment">//2.如果a,b相同符号，则a-b一定不会溢出，所以用a-b的结果去判断非负，再参考A</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">flagA</span> <span class="operator">=</span> sign(a);</span><br><span class="line">        <span class="type">int</span> <span class="variable">flagB</span> <span class="operator">=</span> sign(b);</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a - b;</span><br><span class="line">        <span class="type">int</span> <span class="variable">flagC</span> <span class="operator">=</span> sign(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//判断AB是否相同符号</span></span><br><span class="line">        <span class="comment">//不同为1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">diffAB</span> <span class="operator">=</span> flagA ^ flagB;</span><br><span class="line">        <span class="comment">//相同为1</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">sameAB</span> <span class="operator">=</span> diffAB ^ <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//不同就用a的符号，相同就用c的符号</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">returnA</span> <span class="operator">=</span> diffAB * flagA + sameAB * flagC;</span><br><span class="line">        <span class="comment">//不同就用b的符号，相同就用c的符号的相反</span></span><br><span class="line">        <span class="comment">// int returnB = diffAB * flagB + sameAB * (flagC ^ 1);</span></span><br><span class="line">        <span class="comment">//直接就和A相反</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">returnB</span> <span class="operator">=</span> returnA ^ <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> returnA * a + returnB * b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断一个数是负数还是非负数</span></span><br><span class="line">    <span class="comment">//非负数数返回1 负数返回0</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sign</span><span class="params">(<span class="type">long</span> num)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)(num &gt;&gt;&gt; <span class="number">63</span>) ^ <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">GetMax</span> <span class="variable">getMax</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GetMax</span>();</span><br><span class="line">        System.out.println(getMax.getMax(<span class="number">2147483647</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> 异或运算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 异或运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HeapSort</title>
      <link href="/2024/02/26/HeapSort/"/>
      <url>/2024/02/26/HeapSort/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.sort;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> HeapSort</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/22 16:22</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HeapSort</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        heapSort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapSort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="comment">//堆排序</span></span><br><span class="line">        <span class="comment">//构建堆 从底层开始构建堆 时间复杂°能达到O(N)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> nums.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            heapify(nums, i, nums.length);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// //从顶层开始构建堆 时间复杂度 O(N * logN)</span></span><br><span class="line">        <span class="comment">// for (int i = 0; i &lt; nums.length; i++) &#123;</span></span><br><span class="line">        <span class="comment">//     heapInsert(nums, i);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//调整堆</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">//交换堆顶和堆低</span></span><br><span class="line">            swap(nums, <span class="number">0</span>, --size);</span><br><span class="line">            <span class="comment">//调整堆</span></span><br><span class="line">            heapify(nums, <span class="number">0</span>, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// //往最后插入，往上调整</span></span><br><span class="line">    <span class="comment">// public void heapInsert(int[] arr, int i)&#123;</span></span><br><span class="line">    <span class="comment">// while (arr[i] &gt; arr[(i - 1) / 2])&#123;</span></span><br><span class="line">    <span class="comment">// swap(arr, i, (i - 1)/2);</span></span><br><span class="line">    <span class="comment">// i = (i -1)  / 2;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// //往下调整</span></span><br><span class="line">    <span class="comment">// public void heapify(int[] arr, int i, int size)&#123;</span></span><br><span class="line">    <span class="comment">// int l = 2 * i +1;</span></span><br><span class="line">    <span class="comment">// while (l &lt; size)&#123;</span></span><br><span class="line">    <span class="comment">// //评选最强子节点</span></span><br><span class="line">    <span class="comment">// int best = l + 1 &lt; size &amp;&amp; arr[l + 1] &gt; arr[l] ? l + 1 : l;</span></span><br><span class="line">    <span class="comment">// //最强子节点和当前节点做对比</span></span><br><span class="line">    <span class="comment">// best = arr[i] &gt; arr[best] ? i : best;</span></span><br><span class="line">    <span class="comment">// //最强节点是自己，则不再往下遍历</span></span><br><span class="line">    <span class="comment">// if (best == i)&#123;</span></span><br><span class="line">    <span class="comment">// break;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// swap(arr, i, best);</span></span><br><span class="line">    <span class="comment">// i = best;</span></span><br><span class="line">    <span class="comment">// l = 2 * i +1;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// public void swap(int[] arr, int i , int j)&#123;</span></span><br><span class="line">    <span class="comment">// if (i == j)&#123;</span></span><br><span class="line">    <span class="comment">// return;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="comment">// arr[i] = arr[i] ^ arr[j];</span></span><br><span class="line">    <span class="comment">// arr[j] = arr[i] ^ arr[j];</span></span><br><span class="line">    <span class="comment">// arr[i] = arr[i] ^ arr[j];</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//?????????????????????////////////////</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// i位置的数，向上调整大根堆</span></span><br><span class="line">    <span class="comment">// arr[i] = x，x是新来的！往上看，直到不比父亲大，或者来到0位置(顶)</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">heapInsert</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (arr[i] &gt; arr[(i - <span class="number">1</span>) / <span class="number">2</span>]) &#123;</span><br><span class="line">            swap(arr, i, (i - <span class="number">1</span>) / <span class="number">2</span>);</span><br><span class="line">            i = (i - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// i位置的数，变小了，又想维持大根堆结构</span></span><br><span class="line">    <span class="comment">// 向下调整大根堆</span></span><br><span class="line">    <span class="comment">// 当前堆的大小为size</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">void</span> <span class="title function_">heapify</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> size)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; size) &#123;</span><br><span class="line">            <span class="comment">// 有左孩子，l</span></span><br><span class="line">            <span class="comment">// 右孩子，l+1</span></span><br><span class="line">            <span class="comment">// 评选，最强的孩子，是哪个下标的孩子</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">best</span> <span class="operator">=</span> l + <span class="number">1</span> &lt; size &amp;&amp; arr[l + <span class="number">1</span>] &gt; arr[l] ? l + <span class="number">1</span> : l;</span><br><span class="line">            <span class="comment">// 上面已经评选了最强的孩子，接下来，当前的数和最强的孩子之前，最强下标是谁</span></span><br><span class="line">            best = arr[best] &gt; arr[i] ? best : i;</span><br><span class="line">            <span class="keyword">if</span> (best == i) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            swap(arr, best, i);</span><br><span class="line">            i = best;</span><br><span class="line">            l = i * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">tmp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">        arr[i] = arr[j];</span><br><span class="line">        arr[j] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从顶到底建立大根堆，O(n * logn)</span></span><br><span class="line">    <span class="comment">// 依次弹出堆内最大值并排好序，O(n * logn)</span></span><br><span class="line">    <span class="comment">// 整体时间复杂度O(n * logn)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapSort1</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            heapInsert(arr, i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            swap(arr, <span class="number">0</span>, --size);</span><br><span class="line">            heapify(arr, <span class="number">0</span>, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从底到顶建立大根堆，O(n)</span></span><br><span class="line">    <span class="comment">// 依次弹出堆内最大值并排好序，O(n * logn)</span></span><br><span class="line">    <span class="comment">// 整体时间复杂度O(n * logn)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">heapSort2</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            heapify(arr, i, n);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">size</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="keyword">while</span> (size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            swap(arr, <span class="number">0</span>, --size);</span><br><span class="line">            heapify(arr, <span class="number">0</span>, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> sort </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RadixSort</title>
      <link href="/2024/02/26/RadixSort/"/>
      <url>/2024/02/26/RadixSort/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.sort;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> RadixSort</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 基数排序</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/26 16:02</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RadixSort</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">BASE</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] sortArray(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        radixSort(nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//基数排序</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">radixSort</span><span class="params">(<span class="type">int</span>[] nums)</span>&#123;</span><br><span class="line">        <span class="comment">//基数排序核心：从个位到最高位依次排序</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//处理负数的情况，将所有变成正数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            min = Math.min(min, num);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//获取最高位</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] -= min;</span><br><span class="line">            max = Math.max(max, nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">bit</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (max &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            max /= BASE;</span><br><span class="line">            bit++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        sort(nums, nums.length, bit);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            nums[i] += min;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//就是统计计数，将计数在在数组中倒序放入</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> size, <span class="type">int</span> bit)</span>&#123;</span><br><span class="line">        <span class="comment">//辅助数组</span></span><br><span class="line">        <span class="type">int</span>[] help = <span class="keyword">new</span> <span class="title class_">int</span>[size];</span><br><span class="line">        <span class="comment">//计数数组</span></span><br><span class="line">        <span class="type">int</span>[] cnts = <span class="keyword">new</span> <span class="title class_">int</span>[BASE];</span><br><span class="line">        <span class="comment">//从个位到最高位依次统计每位计数，并排序</span></span><br><span class="line">        <span class="comment">//offset 用来求每位数字的偏移量；bit 最高位循环次数</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> <span class="number">1</span>; bit &gt; <span class="number">0</span>; bit--, offset *= BASE)&#123;</span><br><span class="line">            <span class="comment">//初始化数组</span></span><br><span class="line">            Arrays.fill(cnts, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">//统计计数数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                cnts[ (arr[i] / offset) % BASE ]++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//统计计数数组中，大于某某数的有几个（增量）</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; BASE; i++) &#123;</span><br><span class="line">                cnts[i] = cnts[i] +  cnts[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//倒序放入辅助数组中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> size - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="comment">//原数组数字对应在help数组中的位置为</span></span><br><span class="line">                <span class="comment">//原数组数字对应计数</span></span><br><span class="line">                <span class="comment">// int count = cnts[(arr[i] / offset) % BASE];</span></span><br><span class="line">                <span class="comment">//将统计数字放回到辅助数组位置</span></span><br><span class="line">                <span class="comment">// help[--count] = arr[i];</span></span><br><span class="line"></span><br><span class="line">                <span class="comment">//合并上面为</span></span><br><span class="line">                help[--cnts[(arr[i] / offset) % BASE]] = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//放回原数组</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                arr[i] = help[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">RadixSort</span> <span class="variable">radixSort</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">RadixSort</span>();</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;-<span class="number">1</span>,<span class="number">2</span>,-<span class="number">8</span>,-<span class="number">10</span>&#125;;</span><br><span class="line">        radixSort.sortArray(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> sort </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HalveArray</title>
      <link href="/2024/02/26/HalveArray/"/>
      <url>/2024/02/26/HalveArray/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.day7;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> HalveArray</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 2208将数组和减半的最少操作次数</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/26 16:01</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">HalveArray</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">halveArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="comment">//贪心：将最大那个数减少一半</span></span><br><span class="line">        <span class="comment">//建立大顶堆获取最大的数</span></span><br><span class="line"></span><br><span class="line">        <span class="type">double</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        PriorityQueue&lt;Double&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((i1, i2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (i1 &lt; i2)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (i1 &gt; i2)&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            queue.add(<span class="number">0.0d</span> + nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//累计操作次数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 累计积累减少和</span></span><br><span class="line">        <span class="type">double</span> <span class="variable">num</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (num * <span class="number">2</span> &lt; sum )&#123;</span><br><span class="line">            <span class="type">double</span> <span class="variable">poll</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            num += poll / <span class="number">2</span>;</span><br><span class="line">            queue.add(poll / <span class="number">2</span>);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> day7 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> day7 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MaxAliveYear</title>
      <link href="/2024/02/26/MaxAliveYear/"/>
      <url>/2024/02/26/MaxAliveYear/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.day7;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> MaxAliveYear</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 生存人数</span></span><br><span class="line"><span class="comment"> * https://leetcode.cn/problems/living-people-lcci/description/</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/26 14:52</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MaxAliveYear</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">maxAliveYear</span><span class="params">(<span class="type">int</span>[] birth, <span class="type">int</span>[] death)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[][] arr = <span class="keyword">new</span> <span class="title class_">int</span>[birth.length][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            arr[i] = <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;birth[i],death[i]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按出生年份排序 贪心策略就是 出生年 大于死亡年的都要被淘汰，所以排序要以出生年正序，死亡年（堆中数据）等待被淘汰</span></span><br><span class="line">        <span class="comment">//为什么是按出生年份排序呢？堆里保存的是存活的人的死亡年份，</span></span><br><span class="line">        <span class="comment">// 当遍历数组时，将出生年份正序排序（可视为当前时间），堆里当前时间超过死亡年份的，都要被淘汰</span></span><br><span class="line">        Arrays.sort(arr, (a1, a2) -&gt; a1[<span class="number">0</span>] - a2[<span class="number">0</span>]);</span><br><span class="line">        <span class="comment">//记录最小年份，重叠人数</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">year</span> <span class="operator">=</span> arr[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//记录最右边界前的人数</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] rr : arr) &#123;</span><br><span class="line">            queue.add(rr[<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">//最右边界小于某个出生年份时，全部弹出，重新计数</span></span><br><span class="line">            <span class="comment">//这里不用等于是因为题目要求 死亡年份当年也属于生存时间</span></span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty() &amp;&amp; queue.peek() &lt; rr[<span class="number">0</span>])&#123;</span><br><span class="line">                queue.poll();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//计数</span></span><br><span class="line">            <span class="keyword">if</span> (queue.size() &gt;= count)&#123;</span><br><span class="line">                year = queue.size() == count ?  Math.min(rr[<span class="number">0</span>], year) : rr[<span class="number">0</span>];</span><br><span class="line">                count = queue.size();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> year;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] arr1 = &#123;<span class="number">1972</span>,<span class="number">1908</span>,<span class="number">1915</span>,<span class="number">1957</span>,<span class="number">1960</span>,<span class="number">1948</span>,<span class="number">1912</span>,<span class="number">1903</span>,<span class="number">1949</span>,<span class="number">1977</span>,<span class="number">1900</span>,<span class="number">1957</span>,<span class="number">1934</span>,<span class="number">1929</span>,<span class="number">1913</span>,<span class="number">1902</span>,<span class="number">1903</span>,<span class="number">1901</span>&#125;;</span><br><span class="line">        <span class="type">int</span>[] arr2 = &#123;<span class="number">1997</span>,<span class="number">1932</span>,<span class="number">1963</span>,<span class="number">1997</span>,<span class="number">1983</span>,<span class="number">2000</span>,<span class="number">1926</span>,<span class="number">1962</span>,<span class="number">1955</span>,<span class="number">1997</span>,<span class="number">1998</span>,<span class="number">1989</span>,<span class="number">1992</span>,<span class="number">1975</span>,<span class="number">1940</span>,<span class="number">1903</span>,<span class="number">1983</span>,<span class="number">1969</span>&#125;;</span><br><span class="line">        maxAliveYear(arr1, arr2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> day7 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> day7 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FindMinArrowShots</title>
      <link href="/2024/02/23/FindMinArrowShots/"/>
      <url>/2024/02/23/FindMinArrowShots/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.day6;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">import</span> java.util.Comparator;</span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> FindMinArrowShots</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> leetcode 452用最少数量的箭引爆气球</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/23 16:21</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindMinArrowShots</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//正解</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//一定存在一种最优（射出的箭数最小）的方法，</span></span><br><span class="line">    <span class="comment">// 使得每一支箭的射出位置都恰好对应着某一个气球的右边界。</span></span><br><span class="line">    <span class="comment">//贪心策略：某只箭一定恰好对应某个气球的右边界，</span></span><br><span class="line">    <span class="comment">// 所有开始位置小于该右边界的气球都会被引爆</span></span><br><span class="line">    <span class="comment">//所以贪心策略为：当最小左边界大于最小右边界时，要射另外一只箭</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findMinArrowShots1</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将左边界排序,按左边界升序</span></span><br><span class="line">        Arrays.sort(points, Comparator.comparingInt(a -&gt; a[<span class="number">0</span>]));</span><br><span class="line">        <span class="comment">//定义最小右边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minR</span> <span class="operator">=</span> points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//遍历数组左边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] arr : points) &#123;</span><br><span class="line">            <span class="comment">//左边界大于最小右边界时，要射出另外一只箭</span></span><br><span class="line">            <span class="keyword">if</span> (arr[<span class="number">0</span>] &gt; minR)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="comment">//下一只箭的右区间</span></span><br><span class="line">                minR = arr[<span class="number">1</span>];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//找最小右边界</span></span><br><span class="line">                minR = Math.min(minR, arr[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接排序右边界，按右边界去找.省去重新定义右边界了</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findMinArrowShots0</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将左边界排序,按左边界升序</span></span><br><span class="line">        Arrays.sort(points, (a1, a2) -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (a1[<span class="number">1</span>] &gt; a2[<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (a1[<span class="number">1</span>] &lt; a2[<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">//定义最小右边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">minR</span> <span class="operator">=</span> points[<span class="number">0</span>][<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//遍历数组左边界</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span>[] arr : points) &#123;</span><br><span class="line">            <span class="comment">//左边界大于最小右边界时，要射出另外一只箭</span></span><br><span class="line">            <span class="keyword">if</span> (arr[<span class="number">0</span>] &gt; minR)&#123;</span><br><span class="line">                ans++;</span><br><span class="line">                <span class="comment">//下一只箭的右区间</span></span><br><span class="line">                minR = arr[<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//****************以下错误解答****************//</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//简单的说就是求数组中最小段数（所有重合的也算一段）</span></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findMinArrowShots</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="comment">//所有能被箭射中的目标，xs 肯定小于x,采取类似</span></span><br><span class="line">        <span class="comment">//xs 按最小排序，确保能被箭射中</span></span><br><span class="line">        <span class="comment">//求在最小xe结束前，重合了几个气球，将这些气球都弹出</span></span><br><span class="line">        <span class="comment">//即求在最前的xs的xe结束前，箭能射中几个气球（xs&#x27;小于xe的都弹出）</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里将数组按照最小值排序，不能依赖堆add的时候来排序，</span></span><br><span class="line">        <span class="comment">// 因为缺少了hepify的步骤，所以堆add的排序并不是正确的排序，只能作为筛选出顶部节点的结果</span></span><br><span class="line">        Arrays.sort(points, c);</span><br><span class="line">        <span class="comment">//建立小顶堆排序 xs</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; xs = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(c);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">            xs.add(points[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// PriorityQueue&lt;Integer&gt; xe = new PriorityQueue&lt;&gt;();</span></span><br><span class="line">        <span class="comment">//求重合···即xe &gt;= xs&#x27; 的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!xs.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] arr = xs.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> arr[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (!xs.isEmpty() &amp;&amp; xs.peek()[<span class="number">0</span>] &lt;= end)&#123;</span><br><span class="line">                xs.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">findMinArrowShots2</span><span class="params">(<span class="type">int</span>[][] points)</span> &#123;</span><br><span class="line">        <span class="comment">//将xs 按正序构建最小堆</span></span><br><span class="line">        Arrays.sort(points, c);</span><br><span class="line">        <span class="comment">//建立小顶堆排序 xs</span></span><br><span class="line">        PriorityQueue&lt;<span class="type">int</span>[]&gt; xs = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(c);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">            xs.add(points[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将xe 按正序构建最小堆</span></span><br><span class="line">        PriorityQueue&lt;Integer&gt; xe = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">            xe.add(points[i][<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将xs的xe  对比 堆的xe&#x27;，弹出所有小于xe的</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!xs.isEmpty() &amp;&amp; !xe.isEmpty())&#123;</span><br><span class="line">            <span class="type">int</span>[] arr = xs.poll();</span><br><span class="line">            <span class="type">int</span> <span class="variable">end</span> <span class="operator">=</span> arr[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span> (!xe.isEmpty() &amp;&amp; xe.peek() &lt;= end)&#123;</span><br><span class="line">                xe.poll();</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(ans);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">static</span> <span class="type">Comparator</span> <span class="variable">c</span> <span class="operator">=</span>  <span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;<span class="type">int</span>[]&gt;()&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(<span class="type">int</span>[] l1, <span class="type">int</span>[] l2)</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1[<span class="number">0</span>] &lt; l2[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (l1[<span class="number">0</span>] &gt; l2[<span class="number">0</span>])&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (l1[<span class="number">1</span>] &lt; l2[<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (l1[<span class="number">1</span>] &gt; l2[<span class="number">1</span>])&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// int[][] arr = &#123;&#123;1,2&#125;,&#123;4,5&#125;,&#123;1,5&#125;&#125;;</span></span><br><span class="line">        <span class="type">int</span>[][] arr = &#123;&#123;<span class="number">3</span>,<span class="number">9</span>&#125;,&#123;<span class="number">7</span>,<span class="number">12</span>&#125;,&#123;<span class="number">3</span>,<span class="number">8</span>&#125;,&#123;<span class="number">6</span>,<span class="number">8</span>&#125;,&#123;<span class="number">9</span>,<span class="number">10</span>&#125;,&#123;<span class="number">2</span>,<span class="number">9</span>&#125;,&#123;<span class="number">0</span>,<span class="number">9</span>&#125;,&#123;<span class="number">3</span>,<span class="number">9</span>&#125;,&#123;<span class="number">0</span>,<span class="number">6</span>&#125;,&#123;<span class="number">2</span>,<span class="number">8</span>&#125;&#125;;</span><br><span class="line">        findMinArrowShots2(arr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> day6 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> day6 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MergeKSortedLists</title>
      <link href="/2024/02/22/MergeKSortedLists/"/>
      <url>/2024/02/22/MergeKSortedLists/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.day5;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> study.common.ListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.PriorityQueue;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> MergeKSortedLists</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 23 合并 K 个升序链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/22 17:52</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeKSortedLists</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeKLists</span><span class="params">(ListNode[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//利用小顶堆，将k个链表头部做排序，每次都弹出堆顶，再插入。很简单，相当于两链表合并</span></span><br><span class="line">        <span class="comment">//设置一个数组，存放k个链表的头部节点</span></span><br><span class="line">        PriorityQueue&lt;ListNode&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((l1, l2) -&gt; l1.val - l2.val);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] != <span class="literal">null</span>)&#123;</span><br><span class="line">                queue.add(arr[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//弹出一个节点当作头节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">        <span class="comment">//放入下一个节点</span></span><br><span class="line">        <span class="keyword">if</span> (head.next != <span class="literal">null</span>)&#123;</span><br><span class="line">            queue.offer(head.next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            pre.next = cur;</span><br><span class="line">            pre = cur;</span><br><span class="line">            <span class="keyword">if</span> (cur.next != <span class="literal">null</span>)&#123;</span><br><span class="line">                queue.offer(cur.next);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> day5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> day5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FindKthLargest</title>
      <link href="/2024/02/22/FindKthLargest/"/>
      <url>/2024/02/22/FindKthLargest/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.day5;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> FindKthLargest</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 215 数组中的第K个最大元素</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/22 17:51</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindKthLargest</span> &#123;</span><br><span class="line">    <span class="type">int</span> LEFT, RIGHT;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findKthLargest</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.length &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//排序好的数组中第k大的元素</span></span><br><span class="line">        <span class="keyword">return</span> find(nums, nums.length - k);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//思路：借用快排pattison的思路，和i位置做比较去pattison</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">find</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = arr.length  - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="comment">//定义分区的随机数</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">tar</span> <span class="operator">=</span> (<span class="type">int</span>) (Math.random() * arr.length);</span><br><span class="line">            <span class="comment">//分区</span></span><br><span class="line">            pattison(l,  r, arr[tar], arr);</span><br><span class="line">            <span class="comment">//比较分区排序后的结果和当前目标数的大小</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; LEFT)&#123;</span><br><span class="line">                r = LEFT - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i &gt; RIGHT) &#123;</span><br><span class="line">                l  = RIGHT  + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                ans = arr[LEFT];</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pattison</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> tar, <span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="comment">//定义左边界，，有边界，当前索引</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> l, b = r, index = l;</span><br><span class="line">        <span class="keyword">while</span> (index &lt;= b)&#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[index] &gt; tar) &#123;</span><br><span class="line">                swap(index, b--, arr);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (arr[index] &lt; tar)&#123;</span><br><span class="line">                swap(index++, a++, arr);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        LEFT = a;</span><br><span class="line">        RIGHT = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line">        arr[j] = arr[i] ^ arr[j];</span><br><span class="line">        arr[i] = arr[i] ^ arr[j];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> day5 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> day5 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SmallSum</title>
      <link href="/2024/02/21/SmallSum/"/>
      <url>/2024/02/21/SmallSum/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.day4;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> SmallSum</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 牛客网 计算数组最小和</span></span><br><span class="line"><span class="comment"> * https://www.nowcoder.com/questionTerminal/edfe05a1d45c4ea89101d936cac32469</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/21 15:12</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SmallSum</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="type">BufferedReader</span> <span class="variable">in</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">BufferedReader</span>(<span class="keyword">new</span> <span class="title class_">InputStreamReader</span>(System.in));</span><br><span class="line">        <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">PrintWriter</span>(<span class="keyword">new</span> <span class="title class_">OutputStreamWriter</span>(System.out));</span><br><span class="line">        <span class="type">StreamTokenizer</span> <span class="variable">st</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StreamTokenizer</span>(in);</span><br><span class="line"></span><br><span class="line">        <span class="type">Integer</span> <span class="variable">length</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        String line;</span><br><span class="line">        <span class="comment">// while ((line = in.readLine()) != null)&#123;</span></span><br><span class="line">        <span class="comment">//     if (length == null)&#123;</span></span><br><span class="line">        <span class="comment">//         length = (int) line.charAt(0);</span></span><br><span class="line">        <span class="comment">//         continue;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     arr = Stream.of(line.split(&quot; &quot;)).mapToInt(Integer::parseInt).toArray();</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (st.nextToken() != StreamTokenizer.TT_EOF)&#123;</span><br><span class="line">            length = (<span class="type">int</span>)st.nval;</span><br><span class="line">            arr = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">                st.nextToken();</span><br><span class="line">                arr[i] = (<span class="type">int</span>)st.nval;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        out.println(smallSum(<span class="number">0</span>, arr.length - <span class="number">1</span>, arr));</span><br><span class="line">        out.flush();</span><br><span class="line"></span><br><span class="line">        in.close();</span><br><span class="line">        out.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">smallSum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//左答案 + 右答案 + 左跨右答案</span></span><br><span class="line">        <span class="keyword">return</span> smallSum(l, m, arr) + smallSum(m + <span class="number">1</span>,  r, arr) + merge(l, r, arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算左跨右答案</span></span><br><span class="line">        <span class="comment">//左边的数小于右边的(因为排序是从小到大排，所以算左边小于右边的数才能用上排序的效果），计算和</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> m + <span class="number">1</span>, i = l, sum = <span class="number">0</span>; j &lt;= r; j++) &#123;<span class="comment">//以右边的数为定点，遍历左边的数</span></span><br><span class="line">            <span class="keyword">while</span> ( i &lt;= m &amp;&amp; arr[i] &lt;= arr[j])&#123;</span><br><span class="line">                sum += arr[i];<span class="comment">//当前的j中，所有小于j的i的和</span></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            ans += sum;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> l, rig = m + <span class="number">1</span>, index = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[r - l + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= m &amp;&amp; rig &lt;= r)&#123;</span><br><span class="line">            res[index++] = arr[left] &gt; arr[rig] ? arr[rig++] : arr[left++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (left &lt;= m)&#123;</span><br><span class="line">            res[index++] = arr[left++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (rig &lt;= r)&#123;</span><br><span class="line">            res[index++] = arr[rig++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; res.length)&#123;</span><br><span class="line">            arr[l++] = res[index++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> day4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> day4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReversePairs</title>
      <link href="/2024/02/21/ReversePairs/"/>
      <url>/2024/02/21/ReversePairs/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.day4;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> ReversePairs</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 翻转对 leetcode493</span></span><br><span class="line"><span class="comment"> * 归并分治思想</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/21 11:53</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReversePairs</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归并分治思想：</span></span><br><span class="line">    <span class="comment">//符合答案 = 左答案 + 右答案 + 左跨右答案</span></span><br><span class="line">    <span class="comment">//符合排序利于答案求解的便利性</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reversePairs</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr.length == <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count(<span class="number">0</span> , arr.length - <span class="number">1</span>, arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">count</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (l == r)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="comment">//左半边答案 + 右半边答案 + 左跨右答案</span></span><br><span class="line">        <span class="keyword">return</span> count(l, m, arr) + count(m + <span class="number">1</span>, r, arr) + merge(l, r, arr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span> L, <span class="type">int</span> R, <span class="type">int</span>[] arr)</span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//计算从左跨右答案</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> L + ((R-L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> L; i &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (k &lt;= R)&#123;</span><br><span class="line">                <span class="comment">//注意乘法时，超出int界限</span></span><br><span class="line">                <span class="keyword">if</span> ((<span class="type">long</span>) arr[i] &gt; (<span class="type">long</span>) arr[k] * <span class="number">2</span>)&#123;</span><br><span class="line">                    k++;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            sum += k - m - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//排序</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> L;</span><br><span class="line">        <span class="type">int</span> <span class="variable">r</span> <span class="operator">=</span> m + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span>[] larr = <span class="keyword">new</span> <span class="title class_">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= m &amp;&amp; r &lt;= R)&#123;</span><br><span class="line">            larr[index++] = arr[l] &gt; arr[r] ? arr[r++] : arr[l++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= m)&#123;</span><br><span class="line">            larr[index++] = arr[l++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (r &lt;= R)&#123;</span><br><span class="line">            larr[index++] = arr[r++];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (L &lt;= R)&#123;</span><br><span class="line">            arr[L++] = larr[index++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ReversePairs</span> <span class="variable">reversePairs</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReversePairs</span>();</span><br><span class="line">        <span class="type">int</span>[] arr = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>&#125;;</span><br><span class="line">        reversePairs.reversePairs(arr);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> day4 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> day4 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BinaryTreePostorderTraversal</title>
      <link href="/2024/02/20/BinaryTreePostorderTraversal/"/>
      <url>/2024/02/20/BinaryTreePostorderTraversal/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.day3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> study.common.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> BinaryTreePostorderTraversal</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 用栈实现 后续遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/20 11:07</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTreePostorderTraversal</span> &#123;</span><br><span class="line">    <span class="comment">//用两个栈的版本：镜像先序遍历的思想再倒出来</span></span><br><span class="line">    <span class="comment">//先序：中左右，镜像：中右左，后序遍历：左右中</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal</span><span class="params">(TreeNode head)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; arr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//镜像先序遍历的思想</span></span><br><span class="line">        Stack&lt;TreeNode&gt; in = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">        Stack&lt;TreeNode&gt; out = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">        in.push(head);</span><br><span class="line">        <span class="keyword">while</span> (!in.empty())&#123;</span><br><span class="line">            head = in.pop();</span><br><span class="line">            out.push(head);</span><br><span class="line">            <span class="comment">//镜像先序遍历，先放左边，再放右边</span></span><br><span class="line">            <span class="keyword">if</span> (head.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                in.push(head.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                in.push(head.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!out.empty())&#123;</span><br><span class="line">            arr.add(out.pop().val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用一个栈实现的版本，使用节点记录上一个输出的节点</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">postorderTraversal2</span><span class="params">(TreeNode head)</span>&#123;</span><br><span class="line">        List&lt;Integer&gt; arr = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> arr;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="comment">//如果没有输出节点，则h为头节点</span></span><br><span class="line">        <span class="comment">//否则h为上一个输出的节点</span></span><br><span class="line">        <span class="comment">//指导思想：处理当前节点的子节点入栈顺序</span></span><br><span class="line">        <span class="comment">//核心思想为；判断上一个节点是否处理过，</span></span><br><span class="line">        <span class="comment">//上一个节点是否处理完：</span></span><br><span class="line">        <span class="comment">//a.上一个节点不为当前节点的子节点，则处理当前节点左节点</span></span><br><span class="line">        <span class="comment">//b.上一个节点为当前节点的左节点，则处理右节点</span></span><br><span class="line">        <span class="comment">//c.上一个节点为当前节点的右节点，证明当前节点已处理完，记录当前节点，继续遍历</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">h</span> <span class="operator">=</span> head;</span><br><span class="line">        stack.push(head);</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty())&#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">cur</span> <span class="operator">=</span> stack.peek();</span><br><span class="line">            <span class="comment">//有左树且 左树没处理过（左右节点均不是h）</span></span><br><span class="line">            <span class="comment">//左树全入栈，什么时候打印看条件</span></span><br><span class="line">            <span class="keyword">if</span> (cur.left != <span class="literal">null</span> &amp;&amp; cur.left != h &amp;&amp; cur.right != h)&#123;</span><br><span class="line">                stack.push(cur.left);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cur.right != <span class="literal">null</span> &amp;&amp; cur.right != h)&#123;</span><br><span class="line">                <span class="comment">//有右树且 右树没处理过</span></span><br><span class="line">                stack.push(cur.right);</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//当前节点左右节点为空 或者 当前节点左右节点都处理完</span></span><br><span class="line">                h = stack.pop();</span><br><span class="line">                arr.add(h.val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> day3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> day3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BinaryTreeInorderTraversal</title>
      <link href="/2024/02/20/BinaryTreeInorderTraversal/"/>
      <url>/2024/02/20/BinaryTreeInorderTraversal/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.day3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> study.common.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> BinaryTreeInorderTraversal</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 递推二叉树中序遍历</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/20 10:57</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTreeInorderTraversal</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode head)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; tree = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="comment">//迭代，用栈完成遍历</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">        <span class="comment">//核心思想，把左树全部入栈，再通过栈弹出节点遍历右树</span></span><br><span class="line">        <span class="keyword">while</span> (!stack.empty() || head != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//左树全部入栈</span></span><br><span class="line">            <span class="keyword">if</span> (head != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(head);</span><br><span class="line">                head = head.left;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                head = stack.pop();</span><br><span class="line">                tree.add(head.val);</span><br><span class="line">                head = head.right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> day3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> day3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>TreeNode</title>
      <link href="/2024/02/20/TreeNode/"/>
      <url>/2024/02/20/TreeNode/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.common;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> TreeNode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/20 10:30</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TreeNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> TreeNode left;</span><br><span class="line">    <span class="keyword">public</span> TreeNode right;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">TreeNode</span><span class="params">(<span class="type">int</span> val, TreeNode left, TreeNode right)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.left = left;</span><br><span class="line">        <span class="built_in">this</span>.right = right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> common </category>
          
      </categories>
      
      
        <tags>
            
            <tag> common </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BinaryTreePreorderTraversal</title>
      <link href="/2024/02/20/BinaryTreePreorderTraversal/"/>
      <url>/2024/02/20/BinaryTreePreorderTraversal/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.day3;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> study.common.TreeNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> java.util.Stack;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> BinaryTreePreorderTraversal</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 递推 先序遍历二叉树</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/20 10:29</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BinaryTreePreorderTraversal</span> &#123;</span><br><span class="line">    <span class="comment">//先序遍历，核心思想就是要把子树的节点都放进栈里，</span></span><br><span class="line">    <span class="comment">// 因为要用栈先序，所以要先放右再放左，使之先序</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;Integer&gt; <span class="title function_">inorderTraversal</span><span class="params">(TreeNode head)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; tree = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> tree;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//迭代，用栈完成遍历</span></span><br><span class="line">        Stack&lt;TreeNode&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;TreeNode&gt;();</span><br><span class="line">        stack.push(head);</span><br><span class="line">        <span class="keyword">while</span> (!stack.empty())&#123;</span><br><span class="line">            head = stack.pop();</span><br><span class="line">            tree.add(head.val);</span><br><span class="line">            <span class="comment">//先压右再压左</span></span><br><span class="line">            <span class="keyword">if</span> (head.right != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(head.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (head.left != <span class="literal">null</span>)&#123;</span><br><span class="line">                stack.push(head.left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tree;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> day3 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> day3 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyCircularDeque</title>
      <link href="/2024/02/20/MyCircularDeque/"/>
      <url>/2024/02/20/MyCircularDeque/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.day2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> MyCircularDeque</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/20 9:49</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircularDeque</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//用循环数组实现双端队列</span></span><br><span class="line">    <span class="comment">//注意左右边界和左右两端入队、出队的关系</span></span><br><span class="line">    <span class="comment">//注意数组边界的处理</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l, r, size, limit;</span><br><span class="line">    <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCircularDeque</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        l = r = size = <span class="number">0</span>;</span><br><span class="line">        limit = k;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insertFront</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            l = r = size = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//l为0</span></span><br><span class="line">            <span class="keyword">if</span> (l == <span class="number">0</span>)&#123;</span><br><span class="line">                l = limit - <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                l--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[l] = value;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">insertLast</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            l = r = size = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (r == limit - <span class="number">1</span>)&#123;</span><br><span class="line">                r = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                r++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[r] = value;</span><br><span class="line">        size++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteFront</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l == limit - <span class="number">1</span>)&#123;</span><br><span class="line">            l = <span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deleteLast</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="number">0</span>)&#123;</span><br><span class="line">            r = limit - <span class="number">1</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            r--;</span><br><span class="line">        &#125;</span><br><span class="line">        size--;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getFront</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[l];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getRear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[r];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> size == limit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> day2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> day2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyCircularQueue</title>
      <link href="/2024/02/07/MyCircularQueue/"/>
      <url>/2024/02/07/MyCircularQueue/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.day2;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> MyCircularQueue</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 622 设计循环队列</span></span><br><span class="line"><span class="comment"> * 妙在结构的设计</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/7 16:50</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCircularQueue</span> &#123;</span><br><span class="line">    <span class="comment">//用左右指针标识队列头和尾，用size标识队列范围</span></span><br><span class="line">    <span class="comment">//用limit判断队列是否满，当左右指针到头时要回到</span></span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = <span class="number">0</span>, size = <span class="number">0</span>, limit = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span>[] arr;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCircularQueue</span><span class="params">(<span class="type">int</span> k)</span> &#123;</span><br><span class="line">        limit = k;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="title class_">int</span>[k];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">enQueue</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isFull())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            arr[r++] = value;</span><br><span class="line">            r = r == limit ? <span class="number">0</span> : r;</span><br><span class="line">            size++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">deQueue</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            size--;</span><br><span class="line">            l = l == limit - <span class="number">1</span> ? <span class="number">0</span> : l + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Front</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arr[l];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">Rear</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (isEmpty())&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//队尾元素判断</span></span><br><span class="line">        <span class="keyword">return</span> arr[r == <span class="number">0</span> ? limit - <span class="number">1</span> : r - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isEmpty</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isFull</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> size == limit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> day2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> day2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Partition</title>
      <link href="/2024/02/07/Partition/"/>
      <url>/2024/02/07/Partition/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.day2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> study.common.ListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> Partition</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 86分隔链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/7 15:05</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Partition</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">partition</span><span class="params">(ListNode head, <span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//定义左右两列表头尾</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">leftHead</span> <span class="operator">=</span> <span class="literal">null</span>, rightHead = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">leftTail</span> <span class="operator">=</span> <span class="literal">null</span>, rightTail = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//大于节点放置左/右边头尾节点，用尾节点链接下一节点，头节点做记录返回</span></span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="comment">//标记下一节点</span></span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = <span class="literal">null</span>;<span class="comment">//断开节点</span></span><br><span class="line">            <span class="keyword">if</span> (head.val &gt;= x)&#123;<span class="comment">//放右边</span></span><br><span class="line">                <span class="keyword">if</span> (rightHead == <span class="literal">null</span>)&#123;</span><br><span class="line">                    rightHead = head;</span><br><span class="line">                    rightTail = head;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    rightTail.next = head;</span><br><span class="line">                    rightTail = head;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;<span class="comment">//放左边</span></span><br><span class="line">                <span class="keyword">if</span> (leftHead == <span class="literal">null</span>)&#123;</span><br><span class="line">                    leftHead = head;</span><br><span class="line">                    leftTail = head;</span><br><span class="line">                &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                    leftTail.next = head;</span><br><span class="line">                    leftTail = head;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            head = next;<span class="comment">//遍历下一节点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//链接左右链表</span></span><br><span class="line">        <span class="keyword">if</span> (leftHead != <span class="literal">null</span>)&#123;</span><br><span class="line">            leftTail.next = rightHead;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            leftHead = rightHead;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> leftHead;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> day2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> day2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AddTwoNumbers</title>
      <link href="/2024/02/07/AddTwoNumbers/"/>
      <url>/2024/02/07/AddTwoNumbers/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.day2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> study.common.ListNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> AddTwoNumbers</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/7 11:34</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AddTwoNumbers</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自己按思路写的</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="comment">//指针</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur1</span> <span class="operator">=</span> l1;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur2</span> <span class="operator">=</span> l2;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>();</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//只要没遍历完就继续</span></span><br><span class="line">        <span class="keyword">while</span> (cur1 != <span class="literal">null</span> || cur2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c1</span> <span class="operator">=</span> cur1 == <span class="literal">null</span> ? <span class="number">0</span> : cur1.val;</span><br><span class="line">            <span class="type">int</span> <span class="variable">c2</span> <span class="operator">=</span> cur2 == <span class="literal">null</span> ? <span class="number">0</span> : cur2.val;</span><br><span class="line">            res = (c1 + c2 + carry) % <span class="number">10</span>;</span><br><span class="line">            carry = (c1 + c2 + carry) / <span class="number">10</span>;</span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(res);</span><br><span class="line">            cur.next = r;</span><br><span class="line">            cur = r;</span><br><span class="line">            <span class="keyword">if</span> (cur1 != <span class="literal">null</span>)&#123;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur2 != <span class="literal">null</span>)&#123;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry != <span class="number">0</span>)&#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(carry);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//左神的</span></span><br><span class="line">    <span class="comment">// 也可以复用老链表</span></span><br><span class="line">    <span class="comment">// 不过这个实现没有这么做，都是生成的新节点(为了教学好懂)</span></span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">addTwoNumbers2</span><span class="params">(ListNode h1, ListNode h2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="literal">null</span>, cur = <span class="literal">null</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">carry</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> sum, val; <span class="comment">// 声明变量</span></span><br><span class="line">             h1 != <span class="literal">null</span> || h2 != <span class="literal">null</span>; <span class="comment">// 终止条件</span></span><br><span class="line">             h1 = h1 == <span class="literal">null</span> ? <span class="literal">null</span> : h1.next, <span class="comment">// 每一步h1的跳转</span></span><br><span class="line">                     h2 = h2 == <span class="literal">null</span> ? <span class="literal">null</span> : h2.next <span class="comment">// 每一步h2的跳转</span></span><br><span class="line">        ) &#123;</span><br><span class="line"></span><br><span class="line">            sum = (h1 == <span class="literal">null</span> ? <span class="number">0</span> : h1.val)</span><br><span class="line">                    + (h2 == <span class="literal">null</span> ? <span class="number">0</span> : h2.val)</span><br><span class="line">                    + carry;</span><br><span class="line"></span><br><span class="line">            val = sum % <span class="number">10</span>;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (ans == <span class="literal">null</span>) &#123;</span><br><span class="line">                ans = <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">                cur = ans;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(val);</span><br><span class="line">                cur = cur.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (carry == <span class="number">1</span>) &#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> day2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> day2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MergeTwoLists</title>
      <link href="/2024/02/07/MergeTwoLists/"/>
      <url>/2024/02/07/MergeTwoLists/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.day2;</span><br><span class="line"><span class="keyword">import</span> study.common.ListNode;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> MergeTwoLists</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 21 合并两个链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/7 10:36</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MergeTwoLists</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode list1, ListNode list2)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (list1 == <span class="literal">null</span> || list2 == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> list1 == <span class="literal">null</span> ? list2 : list1;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//两个指针指向各自链表，一个前指针指向确定的前一个节点</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">head</span> <span class="operator">=</span> list1.val &gt;= list2.val ? list2 : list1;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur1</span> <span class="operator">=</span> head == list1 ? list1.next : list1; <span class="comment">//不能和头节点相同</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur2</span> <span class="operator">=</span> head == list2 ? list2.next : list2;<span class="comment">//不能和头节点相同</span></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">while</span> (cur1 != <span class="literal">null</span> &amp;&amp; cur2 != <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span> (cur1.val &lt;= cur2.val)&#123;</span><br><span class="line">                pre.next = cur1;</span><br><span class="line">                pre = cur1;</span><br><span class="line">                cur1 = cur1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                pre.next = cur2;</span><br><span class="line">                pre = cur2;</span><br><span class="line">                cur2 = cur2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当某节点遍历完，续上剩余节点</span></span><br><span class="line">        pre.next = cur1 == <span class="literal">null</span> ? cur2 : cur1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> day2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> day2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ListNode</title>
      <link href="/2024/02/07/ListNode/"/>
      <url>/2024/02/07/ListNode/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.common;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> ListNode</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> TODO</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/7 10:16</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ListNode</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> val;</span><br><span class="line">    <span class="keyword">public</span> ListNode next;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">ListNode</span><span class="params">(<span class="type">int</span> val, ListNode next)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.val = val;</span><br><span class="line">        <span class="built_in">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> common </category>
          
      </categories>
      
      
        <tags>
            
            <tag> common </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ReverseList</title>
      <link href="/2024/02/07/ReverseList/"/>
      <url>/2024/02/07/ReverseList/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.day2;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> study.common.ListNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> RevertList</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 206 反转链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/7 10:15</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ReverseList</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">null</span> || head.next == <span class="literal">null</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">next</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>)&#123;</span><br><span class="line">            next = head.next;</span><br><span class="line">            head.next = pre;</span><br><span class="line">            pre = head;</span><br><span class="line">            head = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> day2 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> day2 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>FindPeekElement</title>
      <link href="/2024/02/02/FindPeekElement/"/>
      <url>/2024/02/02/FindPeekElement/</url>
      
        <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> study.day1;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.Collection;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@ClassName</span> FindPeekElement</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span> 二分法找峰值点</span></span><br><span class="line"><span class="comment"> * https://leetcode.cn/problems/find-peak-element/description/</span></span><br><span class="line"><span class="comment"> * 峰值元素是指其值严格大于左右相邻值的元素。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你可以假设 nums[-1] = nums[n] = -∞ 。</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 你必须实现时间复杂度为 O(log n) 的算法来解决此问题</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Author</span> LJH</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Date</span> 2024/2/2 16:44</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Version</span> 1.0</span></span><br><span class="line"><span class="comment"> **/</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FindPeekElement</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findPeakElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//验证左右节点是否是峰值</span></span><br><span class="line">        <span class="comment">//找边界</span></span><br><span class="line">        <span class="keyword">if</span> (nums.length == <span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> nums.length;</span><br><span class="line">        <span class="keyword">if</span> (nums[<span class="number">0</span>] &gt; nums[<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nums[len - <span class="number">1</span>] &gt; nums[len - <span class="number">2</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> len - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//中间肯定有峰值</span></span><br><span class="line">        <span class="comment">//二分找峰值</span></span><br><span class="line">        <span class="comment">//定义左右边界</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">1</span>, r = len - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r)&#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (l + r) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid] &gt; nums[mid - <span class="number">1</span>])&#123;<span class="comment">//峰值在右边</span></span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> ( nums[mid] &gt; nums[mid + <span class="number">1</span>])&#123;<span class="comment">//峰值在左边</span></span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;Object&gt; objects = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        System.out.println(objects <span class="keyword">instanceof</span> Collection);</span><br><span class="line">        System.out.println(objects <span class="keyword">instanceof</span> List);</span><br><span class="line">        System.out.println(objects <span class="keyword">instanceof</span> ArrayList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
          <category> day1 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> day1 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
